{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/material/source/css/disqus-proxy.css","path":"css/disqus-proxy.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/disqus-proxy.min.css","path":"css/disqus-proxy.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/gallery.min.css","path":"css/gallery.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/ie-blocker.css","path":"css/ie-blocker.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/duoshuo.css","path":"css/duoshuo.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/duoshuo.min.css","path":"css/duoshuo.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/fontawesome.min.css","path":"css/fontawesome.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/material-icons.css","path":"css/material-icons.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify.css","path":"css/prettify.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify.min.css","path":"css/prettify.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff","path":"fonts/MaterialIcons-Regular.woff","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff2","path":"fonts/MaterialIcons-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/material/source/css/uc.css","path":"css/uc.css","modified":0,"renderable":1},{"_id":"themes/material/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/browserstack_logo.png","path":"img/browserstack_logo.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/bg.png","path":"img/bg.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/upyun_logo.svg","path":"img/upyun_logo.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/sidebar_header.png","path":"img/sidebar_header.png","modified":0,"renderable":1},{"_id":"themes/material/source/js/MathJax.js","path":"js/MathJax.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/hanabi-browser-bundle.js","path":"js/hanabi-browser-bundle.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/Valine.min.js","path":"js/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/ie-blocker.en.js","path":"js/ie-blocker.en.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/ie-blocker.zhCN.js","path":"js/ie-blocker.zhCN.js","modified":0,"renderable":1},{"_id":"themes/material/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/material/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/lsloader.min.js","path":"js/lsloader.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/prettify.min.js","path":"js/prettify.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/queue.js","path":"js/queue.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/nprogress.js","path":"js/nprogress.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/smoothscroll.js","path":"js/smoothscroll.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/queue.min.js","path":"js/queue.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/lsloader.js","path":"js/lsloader.js","modified":0,"renderable":1},{"_id":"themes/material/source/css/material.css","path":"css/material.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/material.min.css","path":"css/material.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.ttf","path":"fonts/MaterialIcons-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/css/style.min.css","path":"css/style.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/material/source/img/daily_pic.png","path":"img/daily_pic.png","modified":0,"renderable":1},{"_id":"themes/material/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/js.js","path":"js/js.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/js.min.js","path":"js/js.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-cave-light.min.css","path":"css/prettify/atelier-cave-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-cave-dark.min.css","path":"css/prettify/atelier-cave-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-dune-dark.min.css","path":"css/prettify/atelier-dune-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-dune-light.min.css","path":"css/prettify/atelier-dune-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-estuary-dark.min.css","path":"css/prettify/atelier-estuary-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-estuary-light.min.css","path":"css/prettify/atelier-estuary-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-forest-dark.min.css","path":"css/prettify/atelier-forest-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-forest-light.min.css","path":"css/prettify/atelier-forest-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-heath-dark.min.css","path":"css/prettify/atelier-heath-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-heath-light.min.css","path":"css/prettify/atelier-heath-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-lakeside-dark.min.css","path":"css/prettify/atelier-lakeside-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-lakeside-light.min.css","path":"css/prettify/atelier-lakeside-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-plateau-dark.min.css","path":"css/prettify/atelier-plateau-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-plateau-light.min.css","path":"css/prettify/atelier-plateau-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-savanna-dark.min.css","path":"css/prettify/atelier-savanna-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-savanna-light.min.css","path":"css/prettify/atelier-savanna-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-seaside-dark.min.css","path":"css/prettify/atelier-seaside-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-seaside-light.min.css","path":"css/prettify/atelier-seaside-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-dark.min.css","path":"css/prettify/atelier-sulphurpool-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-light.min.css","path":"css/prettify/atelier-sulphurpool-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/github-v2.min.css","path":"css/prettify/github-v2.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/github.min.css","path":"css/prettify/github.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/hemisu-dark.min.css","path":"css/prettify/hemisu-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/hemisu-light.min.css","path":"css/prettify/hemisu-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-blue.min.css","path":"css/prettify/tomorrow-night-blue.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-bright.min.css","path":"css/prettify/tomorrow-night-bright.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-eighties.min.css","path":"css/prettify/tomorrow-night-eighties.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night.min.css","path":"css/prettify/tomorrow-night.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.eot","path":"fonts/MaterialIcons-Regular.eot","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow.min.css","path":"css/prettify/tomorrow.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tranquil-heart.min.css","path":"css/prettify/tranquil-heart.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/vibrant-ink.min.css","path":"css/prettify/vibrant-ink.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-bilibili.svg","path":"img/footer/footer_ico-bilibili.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-facebook.svg","path":"img/footer/footer_ico-facebook.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-github.svg","path":"img/footer/footer_ico-github.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-gplus.svg","path":"img/footer/footer_ico-gplus.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-instagram.svg","path":"img/footer/footer_ico-instagram.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-linkedin.svg","path":"img/footer/footer_ico-linkedin.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-telegram.svg","path":"img/footer/footer_ico-telegram.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-tumblr.svg","path":"img/footer/footer_ico-tumblr.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-twitter.svg","path":"img/footer/footer_ico-twitter.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-v2ex.svg","path":"img/footer/footer_ico-v2ex.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-weibo.svg","path":"img/footer/footer_ico-weibo.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-zhihu.svg","path":"img/footer/footer_ico-zhihu.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/gallery/arrow.svg","path":"img/gallery/arrow.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/gallery/close.svg","path":"img/gallery/close.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/gallery/spinner.svg","path":"img/gallery/spinner.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-10.png","path":"img/random/material-10.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-12.png","path":"img/random/material-12.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-19.png","path":"img/random/material-19.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-6.png","path":"img/random/material-6.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-8.png","path":"img/random/material-8.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-17.png","path":"img/random/material-17.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-9.png","path":"img/random/material-9.png","modified":0,"renderable":1},{"_id":"themes/material/source/js/gallery/gallery.js","path":"js/gallery/gallery.js","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-1.png","path":"img/random/material-1.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-15.png","path":"img/random/material-15.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-11.png","path":"img/random/material-11.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-14.png","path":"img/random/material-14.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-18.png","path":"img/random/material-18.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-2.png","path":"img/random/material-2.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-13.png","path":"img/random/material-13.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-16.png","path":"img/random/material-16.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-5.png","path":"img/random/material-5.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-7.png","path":"img/random/material-7.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-4.png","path":"img/random/material-4.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-3.png","path":"img/random/material-3.png","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Black.ttf","path":"fonts/Roboto-Black.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Bold.ttf","path":"fonts/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Light.ttf","path":"fonts/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Medium.ttf","path":"fonts/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Regular.ttf","path":"fonts/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Thin.ttf","path":"fonts/Roboto-Thin.ttf","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"c70db20561d5c3991cf864d9935c6706a5ec2cf1","modified":1528205169106},{"_id":"themes/material/LICENSE","hash":"12d81f50767d4e09aa7877da077ad9d1b915d75b","modified":1528205169110},{"_id":"themes/material/_config.template.yml","hash":"909c9b66c782311a0fe16bca4e75dc13e1b289ea","modified":1528205169110},{"_id":"themes/material/CONTRIBUTING.md","hash":"148f555e47d4725fe1faac775107a4d7b03f7136","modified":1528205169110},{"_id":"themes/material/CONTRIBUTING.zh-cn.md","hash":"ef3ccef0451d6ac616b3a35fbfedb6abd35e6b41","modified":1528205169110},{"_id":"themes/material/lint.sh","hash":"49c3a65f8ca65754ec7fefcd2dcb6adc187f3856","modified":1528205169114},{"_id":"themes/material/package.json","hash":"e00885ee25ac548685af9869cf4cf895118a744c","modified":1528205169114},{"_id":"themes/material/_config.yml","hash":"aadbf61a3db4498fc03b38059b46f8740b186b69","modified":1528205169110},{"_id":"themes/material/contributing.json","hash":"1bc0871b1c7822b82533b614090ac0ab7c55282c","modified":1528205169110},{"_id":"source/_posts/Android从0开始的菜鸡学习之路.md","hash":"72f771083f203caa7d6d3c0179f356ded4dc5632","modified":1528871673022},{"_id":"source/_posts/my-test-aritical.md","hash":"a579e41386e9a0ba32453b83edbdc3287e47acb3","modified":1528205169106},{"_id":"themes/material/languages/ar.yml","hash":"472d71f052e08f3c03b15dd67d11ad41f2eee7bf","modified":1528205169110},{"_id":"themes/material/README.md","hash":"408e36745a8aeb187a25f309752c5e7da66f7e67","modified":1528205169110},{"_id":"themes/material/languages/de.yml","hash":"bce37d066ffa82f3e249d41d0ee883c913cc2c5f","modified":1528205169110},{"_id":"themes/material/languages/en.yml","hash":"b59136a1b4d0a77e550b0e7e2e430cac44230dd3","modified":1528205169110},{"_id":"themes/material/languages/es.yml","hash":"d35f5411bc87277cc2d3a58d9499ddb9cfd46f1b","modified":1528205169110},{"_id":"source/_discarded/test.md","hash":"9c2e89a4bb3de4c9d3d40a4fd16ac16dee9e73a7","modified":1528205169106},{"_id":"source/_discarded/hello-world.md","hash":"b3d629f35a899bd9c7814fc3ff90980a1ec79521","modified":1528205169106},{"_id":"themes/material/languages/fr.yml","hash":"f456cf31a72d97f2f18e3bb6cf735285d2b9d2c5","modified":1528205169110},{"_id":"themes/material/languages/ja.yml","hash":"768b8330c9c73287efd475e68741ce4ebad29fd1","modified":1528205169110},{"_id":"themes/material/languages/ms.yml","hash":"237a39bbfcce33e7b918f6c5dc0f01bc79900262","modified":1528205169110},{"_id":"themes/material/languages/nl_NL.yml","hash":"b71e59807716185627d6b9b84e44a79401df639f","modified":1528205169110},{"_id":"themes/material/languages/pt-BR.yml","hash":"a070c2c4d0d3d54f8ca70513cff73c3f7c306db1","modified":1528205169110},{"_id":"themes/material/languages/ru.yml","hash":"fbff2cf48dbde45adcad781e2fd6c30b523a4ac1","modified":1528205169110},{"_id":"themes/material/languages/zh-CN.yml","hash":"c188cad1a16ab0651e2d2d03cb3fa79962cf65ff","modified":1528205169110},{"_id":"themes/material/languages/zh-TW.yml","hash":"ec55953f0330f81bf1ffb37ff34de258dfda642a","modified":1528205169110},{"_id":"themes/material/scripts/helper.js","hash":"e7111a8b1f0ab5bf3466378c48c260a4f6e527d6","modified":1528205169114},{"_id":"themes/material/layout/_partial/Isolation-post-info.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528205169110},{"_id":"themes/material/layout/index.ejs","hash":"aca1abb741f891776913c8ea2e6ff626a0ea5736","modified":1528205169114},{"_id":"themes/material/scripts/lib/font_lsload.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528205169114},{"_id":"themes/material/layout/layout.ejs","hash":"94f66850b815a262c0f8ff112a32a0a6f43066e3","modified":1528205169114},{"_id":"themes/material/layout/post.ejs","hash":"4dd572a9e84f3a6baa5e3f16d270e58e3cd31a23","modified":1528205169114},{"_id":"themes/material/layout/_partial/Isolation-post_entry.ejs","hash":"134dc82320b7aed7d4d78960be63e16c5c4a30fb","modified":1528205169110},{"_id":"themes/material/layout/_partial/Paradox-post-thumbnail.ejs","hash":"6f1e9a85c089ce98a36a2954839fb9ce3e53739e","modified":1528205169110},{"_id":"themes/material/layout/_partial/Paradox-post_entry-thumbnail.ejs","hash":"4d740eba338517d4e10d011a157cdefad45a8e1f","modified":1528205169110},{"_id":"themes/material/layout/_partial/Paradox-post_entry.ejs","hash":"5f4d67e5bd70f635203706cf344b036d891073e6","modified":1528205169110},{"_id":"themes/material/layout/_partial/Paradox-search.ejs","hash":"18a6971b04feccd124a096b8c7cecf1fd4bb914e","modified":1528205169110},{"_id":"themes/material/layout/_partial/Paradox-post-info.ejs","hash":"125cfa5cd9e6e1ca5e958026fdd42f3c3141e34f","modified":1528205169110},{"_id":"themes/material/layout/_partial/comment.ejs","hash":"c9fb1f98a18ca484cb52d60e2ad2bad25b56dfb2","modified":1528205169110},{"_id":"themes/material/layout/_partial/config_css.ejs","hash":"2b1e27faa0446a5e756e61ddf3e969e50948f1ce","modified":1528205169110},{"_id":"themes/material/layout/_partial/daily_pic.ejs","hash":"e780fbdb79b5e27091c408545cfd5b64892c9b01","modified":1528205169110},{"_id":"themes/material/layout/_partial/blog_info.ejs","hash":"5e95796e6f9a81163554ca4198573860f7328d4e","modified":1528205169110},{"_id":"themes/material/layout/_partial/config_font.ejs","hash":"730abeb681758ce288d5541930c46bc4b041a0b1","modified":1528205169110},{"_id":"themes/material/layout/_partial/footer_top.ejs","hash":"9eaace4feb951c96c0033e7271497f3f300d2476","modified":1528205169110},{"_id":"themes/material/layout/_partial/head.ejs","hash":"8167f995c7cc21a6a8ddbfbdd03f2f74a7bd904d","modified":1528205169110},{"_id":"themes/material/layout/_partial/footer-left.ejs","hash":"372cdf718e01fea2736b8e427e57bfcfaa8a557f","modified":1528205169110},{"_id":"themes/material/layout/_partial/footer-option.ejs","hash":"be20394eaeaf2d20db28946b948962c839da6ea9","modified":1528205169110},{"_id":"themes/material/layout/_partial/footer.ejs","hash":"530626c347882579d09d71df68993e25076ca8e2","modified":1528205169110},{"_id":"themes/material/layout/_partial/isolate-sns_list.ejs","hash":"fc5f03ebb847f85975676a9dfee8870e7c908008","modified":1528205169110},{"_id":"themes/material/layout/_partial/isolate_info.ejs","hash":"b8ec76716bfa2e6513b4df6814fe8676536a94c1","modified":1528205169110},{"_id":"themes/material/layout/_partial/import_js.ejs","hash":"961b8a0059875e4044fe80bbe91ca6a225f113e5","modified":1528205169110},{"_id":"themes/material/layout/_partial/post-content.ejs","hash":"ad626e3b60bc4a17bacff02cf9b0a8beaba2ad1e","modified":1528205169110},{"_id":"themes/material/layout/_partial/post-header.ejs","hash":"b0b8973c48db6376a24d4b4b1d2eb15d18d6508c","modified":1528205169110},{"_id":"themes/material/layout/_partial/post-info-share.ejs","hash":"9f28d62bf728c2bd89411688426a65d7ee55400c","modified":1528205169110},{"_id":"themes/material/layout/_partial/post-nav.ejs","hash":"3b6d4568cc46f60c697ad9ec85a4aa5971f3eecc","modified":1528205169110},{"_id":"themes/material/layout/_partial/sidebar-footer.ejs","hash":"6c3486b846473e0d58666f7a8720f5bf4a14e030","modified":1528205169110},{"_id":"themes/material/layout/_partial/sidebar-footer_image.ejs","hash":"b9157d2072028a1db3c3419f76bde6637e85cf0e","modified":1528205169110},{"_id":"themes/material/layout/_partial/sidebar-header.ejs","hash":"06295e01092f55504d30a343c3fdc5091280e495","modified":1528205169110},{"_id":"themes/material/layout/_partial/sidebar-navigation.ejs","hash":"ff44901fdfdd952174b0d22e86df7163d7fba9ba","modified":1528205169110},{"_id":"themes/material/layout/_partial/sidebar.ejs","hash":"c5ce6136e82895cb80dab8a918a7cdf2fe820fea","modified":1528205169110},{"_id":"themes/material/layout/_partial/structured-data.ejs","hash":"e845df290185dc300cc4edcc08b50fddc5b6909b","modified":1528205169110},{"_id":"themes/material/layout/_partial/toc_button.ejs","hash":"688c3fc12e2548ff27fe60688f79dcce2881fd50","modified":1528205169110},{"_id":"themes/material/layout/_widget/dnsprefetch.ejs","hash":"5e4c5359d69a64042183db13f6dd771b1f7f6b31","modified":1528205169110},{"_id":"themes/material/layout/_widget/leancloud-like.ejs","hash":"e4780fe3bbb049db38d694fc18dee13d799bd51d","modified":1528205169110},{"_id":"themes/material/layout/_widget/leancloud-views.ejs","hash":"211dc183b8e84f71b2c25b3ac6659d162d81662b","modified":1528205169110},{"_id":"themes/material/layout/_widget/leancloud-views_num.ejs","hash":"e27baba6a2de406463735d276606b15fb40f5eba","modified":1528205169114},{"_id":"themes/material/layout/_widget/mathjax.ejs","hash":"b68befe1fea84739c8429c344e570a8bc0357401","modified":1528205169114},{"_id":"themes/material/layout/_widget/nprogress.ejs","hash":"901a64600854b312209287c702278183600e06b9","modified":1528205169114},{"_id":"themes/material/layout/_widget/page-gallery.ejs","hash":"81b9410deef7a83ef5bc7cd18ad042df70d70b94","modified":1528205169114},{"_id":"themes/material/layout/_widget/page-links.ejs","hash":"0ebe18e4326f921d6010df8479a08c2d403ba717","modified":1528205169114},{"_id":"themes/material/layout/_widget/page-tagcloud.ejs","hash":"e71de74e4067cc4e6aef1e09ac429c92bcd178b3","modified":1528205169114},{"_id":"themes/material/layout/_widget/qrcode.ejs","hash":"3212e5d29fe8490c5d9a844ec9c2ce9925532de8","modified":1528205169114},{"_id":"themes/material/scripts/lib/css_lsload.js","hash":"179f5f5e3297a7fb7d90545ddd94eb468a11046e","modified":1528205169114},{"_id":"themes/material/scripts/lib/get_file_hex.js","hash":"eb3b9a45f8ca45ef40d5421baef7d4484023982c","modified":1528205169114},{"_id":"themes/material/scripts/lib/js_hex.js","hash":"2704583aa036d538544ce31c2e924c0c125309dd","modified":1528205169114},{"_id":"themes/material/scripts/lib/js_lsload.js","hash":"72f885b13fe0028a0e2acb7168dcc66e39ea1592","modified":1528205169114},{"_id":"themes/material/scripts/lib/path_for.js","hash":"f944e3b53a468962121aa3357cc0bc18ac27a34c","modified":1528205169114},{"_id":"themes/material/layout/_widget/search-local-js.ejs","hash":"f42cc040adf47fc7d74f64b0be3c3230e8a3339e","modified":1528205169114},{"_id":"themes/material/layout/_widget/search-swiftype-js.ejs","hash":"7ad1e843e620ccd9b3c041dccfdcee97921247a1","modified":1528205169114},{"_id":"themes/material/layout/_widget/page-timeline.ejs","hash":"9fa0195e08d9fd40aa0333e9279c98bc65acf604","modified":1528205169114},{"_id":"themes/material/source/css/disqus-proxy.css","hash":"770776d8cec27cd5661bdfd59eff9af263439989","modified":1528205169114},{"_id":"themes/material/source/css/disqus-proxy.min.css","hash":"3f8f99f71d361302288b0ba11fd36072564b08c2","modified":1528205169114},{"_id":"themes/material/source/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1528205169114},{"_id":"themes/material/source/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1528205169114},{"_id":"themes/material/source/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1528205169114},{"_id":"themes/material/source/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1528205169114},{"_id":"themes/material/source/css/fontawesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1528205169114},{"_id":"themes/material/source/css/material-icons.css","hash":"f6f95fe5190f3c65931847246621fb83754eb00c","modified":1528205169114},{"_id":"themes/material/source/css/prettify.css","hash":"c395f20ee64e80c2b6b15c7dade02f9aaaeab2c8","modified":1528205169114},{"_id":"themes/material/source/css/prettify.min.css","hash":"62edd8f08656463b0e077dcf893faa3cc8eb5fe4","modified":1528205169114},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1528205169114},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1528205169114},{"_id":"themes/material/source/css/uc.css","hash":"1e0977a2c9bdf721cc05654dfc025dd250655852","modified":1528205169114},{"_id":"themes/material/source/img/avatar.png","hash":"bf483b0d495dbbcfb308348a945818e1c1cc9696","modified":1528205169118},{"_id":"themes/material/source/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1528205169118},{"_id":"themes/material/source/img/favicon.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1528205169118},{"_id":"themes/material/source/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1528205169118},{"_id":"themes/material/source/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1528205169122},{"_id":"themes/material/source/img/sidebar_header.png","hash":"c47f4d39f421c0a950279d050ae82f9ae6dd19ff","modified":1528205169122},{"_id":"themes/material/source/js/MathJax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1528205169122},{"_id":"themes/material/source/js/hanabi-browser-bundle.js","hash":"d646647bda386140c8315d60e3ff4ddbdb15c1ea","modified":1528205169122},{"_id":"themes/material/source/js/Valine.min.js","hash":"6a287a99a772a0ea8f98b133523429c9250cc67f","modified":1528205169122},{"_id":"themes/material/source/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1528205169122},{"_id":"themes/material/source/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1528205169122},{"_id":"themes/material/source/img/logo.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1528205169118},{"_id":"themes/material/source/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1528205169122},{"_id":"themes/material/source/js/lsloader.min.js","hash":"1a68a8d267948ea8475245b7d365a1a1bd8f732e","modified":1528205169122},{"_id":"themes/material/source/js/prettify.min.js","hash":"69908fe0a09cee107c25cb5d769b861723e7b7bb","modified":1528205169122},{"_id":"themes/material/source/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1528205169122},{"_id":"themes/material/source/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1528205169122},{"_id":"themes/material/source/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1528205169122},{"_id":"themes/material/source/js/queue.min.js","hash":"21aab782ca33efbb1386cc960b6be0a02106760d","modified":1528205169122},{"_id":"themes/material/source/js/lsloader.js","hash":"2b14e57784fb6b5f58d71584189c61af45f393e8","modified":1528205169122},{"_id":"themes/material/source/css/material.css","hash":"068e2b00f686157b6e8b78b9b808112adbedf4de","modified":1528205169114},{"_id":"themes/material/source/css/material.min.css","hash":"1a19febb9214ab689b02f5bb8ccb23579e6c1181","modified":1528205169114},{"_id":"themes/material/source/css/style.css","hash":"a2f27c40f412dc24e1ed5f62a4117523a226eed0","modified":1528205169114},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1528205169114},{"_id":"themes/material/source/css/style.min.css","hash":"a9e9b33e1fcf818f08a04b909c86f2460a05f060","modified":1528205169114},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1528205169118},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1528205169118},{"_id":"themes/material/source/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1528205169118},{"_id":"themes/material/source/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1528205169122},{"_id":"themes/material/source/js/js.js","hash":"64b3f20e7138674ecf21e6e3982565ea63feae26","modified":1528205169122},{"_id":"themes/material/source/js/js.min.js","hash":"709d347d3be033b841de0493b7cf532b594bb1f6","modified":1528205169122},{"_id":"themes/material/layout/_widget/analytics/baidu-analytics.ejs","hash":"3866a7fead3c1f94a517f1f9d629f092670b1520","modified":1528205169110},{"_id":"themes/material/layout/_widget/analytics/google-analytics.ejs","hash":"3b10ebf524baf0c24b22dcd110b39d15c5acb9b5","modified":1528205169110},{"_id":"themes/material/layout/_widget/analytics/cnzz-analytics.ejs","hash":"1765e3dcd92961292f40d1812e593186c77b17ef","modified":1528205169110},{"_id":"themes/material/source/css/prettify/atelier-cave-light.min.css","hash":"4b62dc45aa351b071d6a434dc54fe8c2e15c85cc","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-cave-dark.min.css","hash":"cb0156cdc36500a26b232ae1c81fdc880eba85e7","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-dune-dark.min.css","hash":"c5094d99ca0e619d97860c88211bf908fdf830b1","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-dune-light.min.css","hash":"b3ad98483e4d5bde72d52a15423d98e0d086db09","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-estuary-dark.min.css","hash":"7e3a065cafeb3acc1d7178f64ef4265f5d5ad2b9","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-estuary-light.min.css","hash":"1d12d8f7fa9c122a186ee76fdf681c191a68f104","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-forest-dark.min.css","hash":"9296b851a5b66785a60afa5da5fe9080bda96bf5","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-forest-light.min.css","hash":"3532f6e86bf4afbba05f7a074b791b73174f9622","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-heath-dark.min.css","hash":"954309acd7918422382a3ff2f9c2988aec0ff956","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-heath-light.min.css","hash":"a67199fa580b3aa2df031e5d2028929d29ca3b45","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-lakeside-dark.min.css","hash":"18575fc6dff855e395a39d0383d2f18807091f0d","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-lakeside-light.min.css","hash":"e20e8ac64432fa1aa6f74792b58196af7cf79c12","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-plateau-dark.min.css","hash":"137e3c499a720da3c1d57b4dc53264b1d623e1c5","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-plateau-light.min.css","hash":"153801640fdcbb74c0de3f15345110f2210eb991","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-savanna-dark.min.css","hash":"fba92c652fd6704422b8f2bbc11706805a6faed0","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-savanna-light.min.css","hash":"d9425ffb7c60d646190c22b9a5f72091ee5f9ace","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-seaside-dark.min.css","hash":"e0e6bbacc75a349b1e49c236d374b0e42f1fd485","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-seaside-light.min.css","hash":"732750b75389c1c49204f37705e6abeee40ce64f","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-dark.min.css","hash":"015a35dddaee153fa8bb71d7f3818a6ba4d120d8","modified":1528205169114},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-light.min.css","hash":"ab1a6200eab648cab443c3df77fde9b237ef27b6","modified":1528205169114},{"_id":"themes/material/source/css/prettify/github-v2.min.css","hash":"57630621d20842a529bdea7b17fc90f520e562ef","modified":1528205169114},{"_id":"themes/material/source/css/prettify/github.min.css","hash":"19cf828225288fa5c006f1d8f66c39d11f4ef7f2","modified":1528205169114},{"_id":"themes/material/source/css/prettify/hemisu-dark.min.css","hash":"a671248cfd573292026d2174817e82e593691052","modified":1528205169114},{"_id":"themes/material/source/css/prettify/hemisu-light.min.css","hash":"b2556ff41e513fd13d032ec84a37ee260a905815","modified":1528205169114},{"_id":"themes/material/source/css/prettify/tomorrow-night-blue.min.css","hash":"c442728d96485bcf816151fe6bd96993aae09852","modified":1528205169114},{"_id":"themes/material/source/css/prettify/tomorrow-night-bright.min.css","hash":"cf251fd3edfd736695272a0f1b41d509b7bb1fb9","modified":1528205169114},{"_id":"themes/material/source/css/prettify/tomorrow-night-eighties.min.css","hash":"6ce259d674bb4edda23eea32b2379be17d0e0e6e","modified":1528205169114},{"_id":"themes/material/source/css/prettify/tomorrow-night.min.css","hash":"d989206d124035494acb4b0cdc7fbc89f3b7d108","modified":1528205169114},{"_id":"themes/material/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1528205169114},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1528205169114},{"_id":"themes/material/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1528205169118},{"_id":"themes/material/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1528205169118},{"_id":"themes/material/source/css/prettify/tomorrow.min.css","hash":"b2c6d610b77f0273fefab5aa4ad26a7f58956f87","modified":1528205169114},{"_id":"themes/material/source/css/prettify/tranquil-heart.min.css","hash":"0f6eefbdda8e410832e9c516a5dd19899217ef06","modified":1528205169114},{"_id":"themes/material/source/css/prettify/vibrant-ink.min.css","hash":"c265bac6c31cf622b536b29c8a6bc46955d6fe63","modified":1528205169114},{"_id":"themes/material/source/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1528205169118},{"_id":"themes/material/source/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1528205169118},{"_id":"themes/material/source/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1528205169118},{"_id":"themes/material/source/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1528205169118},{"_id":"themes/material/source/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1528205169118},{"_id":"themes/material/source/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1528205169118},{"_id":"themes/material/source/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1528205169118},{"_id":"themes/material/source/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1528205169118},{"_id":"themes/material/source/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1528205169118},{"_id":"themes/material/source/img/footer/footer_ico-v2ex.svg","hash":"c5ffaf67a97e534c266d1585a9a3b56f1bfe3052","modified":1528205169118},{"_id":"themes/material/source/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1528205169118},{"_id":"themes/material/source/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1528205169118},{"_id":"themes/material/source/img/gallery/arrow.svg","hash":"144d73877e52acc5068bc0c9d1e69ef450e69f26","modified":1528205169118},{"_id":"themes/material/source/img/gallery/close.svg","hash":"2690088060811f01c9360df75be80070156ff176","modified":1528205169118},{"_id":"themes/material/source/img/gallery/spinner.svg","hash":"fc9d1cd1118ac896d4f5326e110a653f3ea32b11","modified":1528205169118},{"_id":"themes/material/source/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1528205169118},{"_id":"themes/material/source/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1528205169118},{"_id":"themes/material/source/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1528205169122},{"_id":"themes/material/source/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1528205169122},{"_id":"themes/material/source/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1528205169122},{"_id":"themes/material/source/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1528205169122},{"_id":"themes/material/source/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1528205169122},{"_id":"themes/material/source/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1528205169122},{"_id":"themes/material/source/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1528205169118},{"_id":"themes/material/source/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1528205169118},{"_id":"themes/material/source/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1528205169118},{"_id":"themes/material/source/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1528205169118},{"_id":"themes/material/source/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1528205169122},{"_id":"themes/material/source/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1528205169122},{"_id":"themes/material/source/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1528205169118},{"_id":"themes/material/source/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1528205169118},{"_id":"themes/material/source/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1528205169122},{"_id":"themes/material/source/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1528205169122},{"_id":"themes/material/layout/_widget/comment/livere/common.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528205169110},{"_id":"themes/material/source/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1528205169122},{"_id":"themes/material/layout/_widget/comment/changyan/common.ejs","hash":"40e1fc76d6b7f64e226693fb2fe1a6bb17bae245","modified":1528205169110},{"_id":"themes/material/source/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1528205169122},{"_id":"themes/material/layout/_widget/comment/changyan/enter.ejs","hash":"e3cfb4f37ea35457f112f3e822e130c930086497","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/changyan/main.ejs","hash":"77539ff32cc9d1204b848e01b5277fff5cbd61e0","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/disqus/common.ejs","hash":"c11cfceb0906a96399dede5da01ff7fe4787f8a5","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/disqus/enter.ejs","hash":"39192034766349e47967da63184f9104fdded2ab","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/disqus/main.ejs","hash":"21e0eeff664191b818d7a0071ae7edcdfc270442","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/disqus_click/common.ejs","hash":"d243f576b366a62191066459efcc6fd0ab79d00a","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/disqus_click/enter.ejs","hash":"d82f0296f8bae25223ec44e6e05b817d3a234884","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/disqus_click/main.ejs","hash":"f53de208ca46c669a868a1922488e39509c6fe3b","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/valine/common.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/gitalk/common.ejs","hash":"f739897518011e1b3de7807c8c5d734984711282","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/gitalk/enter.ejs","hash":"4d70d76465469a57def29a221962a5520fb34ebe","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/gitalk/main.ejs","hash":"1ee7a7b2b9b5ae8c4fa8c4b09c7973b9e085bdf2","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/gitment/common.ejs","hash":"9c6c8d1b448c32afb01c2d0351e87f4d4a17ec3c","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/gitment/enter.ejs","hash":"46d904fde9233694b95c6a3d91b9a2b7a6805850","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/gitment/main.ejs","hash":"e622660eda38cda05847aadc2a3e31a228fc519b","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/livere/enter.ejs","hash":"194b7bb581a3b8608a7ab135b6953d7908f51cc8","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/livere/main.ejs","hash":"1c4be9ba104a8cbcc11d45f11bf8cfe7704b93a5","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/valine/enter.ejs","hash":"ab528aad46237d9e7f1c5b4b2b310dd628b2de63","modified":1528205169110},{"_id":"themes/material/layout/_widget/comment/valine/main.ejs","hash":"3d5d8559e6ad4ffb58a61d96439b2718eb9999b6","modified":1528205169110},{"_id":"themes/material/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1528205169118},{"_id":"themes/material/source/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1528205169114},{"_id":"themes/material/source/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1528205169114},{"_id":"themes/material/source/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1528205169114},{"_id":"themes/material/source/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1528205169114},{"_id":"themes/material/source/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1528205169114},{"_id":"themes/material/source/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1528205169118},{"_id":"source/Untitled/index.md","hash":"52d552c164988e3b839ded9aac01a24474af9bc8","modified":1528272560250},{"_id":"source/Untitled/index-1.md","hash":"c59f9ba71f98e1e9b1b5b59b7e68c75943f94204","modified":1528272564738},{"_id":"source/Untitled/index-2.md","hash":"1cdfdde7c331776a9f3170dc32ed6445f974caf5","modified":1528272680275},{"_id":"public/search.xml","hash":"c5cc2f68ef489ceb735d4e343d1e41a0d0126104","modified":1528963903462},{"_id":"public/Untitled/index.html","hash":"8304bacef58f3ece0f1284d2462e48a0824d3f03","modified":1528296457881},{"_id":"public/Untitled/index-1.html","hash":"3100d1baa0ed482c203b0bcb8a35fc2053a201d0","modified":1528296457881},{"_id":"public/Untitled/index-2.html","hash":"71e4a68568060085ca48197bf5cb56905bfa1a20","modified":1528296457881},{"_id":"public/archives/index.html","hash":"83f4d13dd34ee04476701e2c1ac9d5e9b0ccb785","modified":1528296457881},{"_id":"public/archives/2018/index.html","hash":"070fdf1195b17913d985f153bfb1c18e9ba81ec8","modified":1528296457882},{"_id":"public/archives/2018/04/index.html","hash":"7d9dffd546887260ece28c65ebc5b15f7369720e","modified":1528296457882},{"_id":"public/archives/2018/06/index.html","hash":"d0390df01a09a3a0e90209a1f456033dee5e282b","modified":1528296457882},{"_id":"public/2018/06/04/Android从0开始的菜鸡学习之路/index.html","hash":"2801e4e63baffda52d4d97116119f2f9f08afa34","modified":1528963903713},{"_id":"public/2018/04/12/my-test-aritical/index.html","hash":"4df2129c93d0221b41b55b1e80421735cacbaa3f","modified":1528296457882},{"_id":"public/index.html","hash":"5b9bcc21f95f3e5d7b33b0ec75d3b03a580fa8ab","modified":1528296457884},{"_id":"public/categories/数据结构/index.html","hash":"1253e8c62c754783f38f235dc5eca035de81bef4","modified":1528296457884},{"_id":"public/categories/Android/index.html","hash":"ac5fd1cf707a8a6e16a07b3eab4a9dbcbbeb4987","modified":1528296457884},{"_id":"public/tags/0基础/index.html","hash":"1829636b9983e0d60e514ab54afba2ec4689fa83","modified":1528296457885},{"_id":"public/tags/客户端/index.html","hash":"f62182c561066b9c0b41388f3f72dd4e54c5cf29","modified":1528296457885},{"_id":"public/categories/Android/客户端/index.html","hash":"d7fb65d09017f63df53d28355361bd4a29f8042a","modified":1528296457885},{"_id":"public/tags/Android/index.html","hash":"fe5c6b52d66a0321c967313d6a966beb731d95b9","modified":1528296457885},{"_id":"public/tags/学习笔记/index.html","hash":"178dbad583e50574e7ce79eeea697666a0a3417e","modified":1528296457885}],"Category":[{"name":"Android","_id":"cji2hzkb10002pvi1pnhd75o6"},{"name":"数据结构","_id":"cji2hzkb50004pvi11zl7024a"},{"name":"客户端","parent":"cji2hzkb10002pvi1pnhd75o6","_id":"cji2hzkb60006pvi1wn3kitn8"}],"Data":[],"Page":[],"Post":[{"title":"Android从0开始的菜鸡学习之路","author":"howard","date":"2018-06-04T08:05:00.000Z","_content":"开头先说几句：\n\n* 我很久没有更新这个博客了，好不容易搭建的差不多，还没有来的及修改一些细节部分，不过还好，不影响使用，之后有空了再改吧。后面会把一些学习的历程、学习笔记或者一些乱七八糟的感想什么的等等东西更新上来，应该也没有什么人来看吧~\n* 这个Android的学习历程其实并不是我学客户端开发的开头——虽然博客里之前也并没有写关于其他的学习历程。。。我其实之前学的是iOS开发，OC写了挺久，最近也在接触Swift，本来是做好了做一个正经的iOS开发实习生（虽然我从来没有过iPhone），但是呢，今天实习公司的导师加了微信，我才得知我去了之后是要做Android的。一开始有点懵，我没写过这个东西呀，Java也掌握的很一般很一般，这意味着我有很多东西需要学习。那，如果我实习留不下呢？我写了一个月的Android然后回来匆匆忙忙复习iOS再投秋招的iOS岗位么？有点纠结，也很难抉择。\n* 后来一想，反正实习还是要去的，那我现在开始了解一些开发Android相关的东西，去了以后能调岗位就最好，不能调的话就尽量争取留下来吧。也问了一些学长的看法作为参考。这不过就是一次挑战而已，总不可能事事如意，这个就当是一个学习能力的挑战吧，能不能在固定的一段时间里学到尽量多的东西。反正iOS的学习基本上也到了瓶颈期，不如，换换口味？\n* 再者说，我也算个安卓机的爱好者吧，因为穷我用的从来都是安卓机，也很早开始折腾安卓系统，root、刷系统、玩xposed……算是从安卓2.x一直到8.1的体验者了。\n* 塞翁失马，焉知非福\n* 那就这么开始学习安卓吧\n\n# 开始前的准备\n## 教材\n我用的是学长推荐的《第一行代码Android》\n## 运行环境\n用了很久的黑苹果10.12.6，AS最新版，不想用模拟器，就用了我刷了8.1的一加2\n\n# HelloWorld\n新建了一个只有一个Activity的项目，它自己就写了“hello，world” 所以其实不算是我自己写的。\n但是比起新建一个EmptyActivity什么都没有一脸懵逼来说好很多了\n## 项目文件夹结构\n### .gradle 和 .idea\n自动生成的文件，不用管\n### app\n主要文件都在这里\n#### build \n也是编译生成的文件，更多更杂，不用管\n#### libs\n第三方包的文件夹，会自动加到构建的路径里\n#### src\n这个文件里的东西是编写的时候需要关注的文件夹，需要自己写的内容基本上都在这里面\n##### androidTest\n可以在这里写测试用例，可以自动化测试\n##### main\n基本上java文件就都在这里了\n###### java\njava文件就在这个文件夹下，比如刚才创建的Activity.java\n###### res \n项目里要用到的所有图片（drawable）、布局（layout）、字符串（values）等\n###### AndroidManifest.xml\n这个是整个项目的配置文件，在程序里定义的所有的四大组件都需要在这里注册，另外还可以写权限声明，这个要经常用到\n##### test\n又是一个测试，先不管\n##### .gitignore\ngit忽略的文件\n##### app.imi\n不用管\n##### build.gradle\napp这个模块的构建脚本\n##### proguard-rules.pro\n用于指定混淆规则，厉害了，用于防止代码被破解\n### build\n编译时自动生成的文件，不用管\n### gradle\n包含了gradle wrapper的配置文件，默认不启用这个方式\n### gitignore\ngit的忽略文件\n### build.gradle\n全局gradle构建脚本，gradle是一个自动化构建脚本，一般不用改\n### gradle.properties\n全局gradle配置文件，会影响整个项目的编译\n### gradlew和gradlew.bat\n是用来执行gradle的，不用管\n### XXX.imi\n是这个IDE的存在感的标识，不用管\n### local.properties\n指定本机的Android SDK的路径，是自动生成的一般不用改\n### setting.gradle\n用来指定项目中所有引入的模块，目前为止一共就用了app这么一个模块，所以现在还就只写了\n```\ninclude ':app'\n```\n\n** 好了，关于文件目录就是这些，总结起来就是外层的文件夹什么的基本上先不用管，要注意的就是app这个文件夹里的 **\n\n## 如何运行起来的\n先看Android-Manifest.xml里做了什么\n### Android-Manifest.xml\n里面有一部分代码长这样：\n```\n<activity android:name=\".MainActivity\">\n\t<intent-filter>\n    \t<action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.LAUNCHER\" />\n    </intent-filter>\n</activity>\n```\n指定了点击应用之后首先启动哪个Activity，这里当然是MainActivity这个类\n那MainActivity这个类里面做了什么操作呢？\n### MainActivity.java\n```\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n}\n```\n这个类是一个继承自AppCompatActivity的类，这个类类似于iOS里的ViewController\n这个类的onCreate方法是一个Activity被创建的时候一定会执行的方法（类似于iOS里的ViewDidLoad）\n这里并没有看到“hello world”的字样。\nAndroid编程讲究逻辑和视图分离，所以setContentView这个方法引入了一个布局文件（res/layout）\n\n### activity_main.xml\n这个文件里面有一部分是这样的：\n```\n<TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n```\n表示布局里添加了一个TextView的控件，设置了ndroid:text=\"Hello World!\"所以会显示出Hello World。这个控件类似于iOS里的UILable\n\n** 这样就大致搞清楚了HelloWorld是怎么运行起来的，并且各种文件是怎么组织起来的。其实和iOS类似的地方很多，AndroidManifest.xml有些类似APPDelegate，Activity类似于ViewController，activity_main.xml类似于xib，但是之前都是直接用代码写的布局类，所以这种的还需要适应一下 **\n\n** 大致过程大概就是，先在AndroidManifest.xml配置Activity，然后在布局文件里面写界面相关的代码，然后在Activity.java里面写对布局里面的控件的操控，也是类似MVC的经典的逻辑分离的设计方法。 **\n\n# 从0开始自己构建一个APP\n前面的HelloWorld是人机自动生成的，这一次开始自己从0开始写一个，选择Empty，这时候没有Acitvity，所以不会有显示的。\n## 新建一个Activity\n在app/src/main/java/com.example.ifan.activitytest右键从new里面选择一个EmptyActivity。这里新建的Activity是会自动在AndroidManifest.xml里面自动添加注册的代码的，但是不会自动设置为最先启动后展示的第一个页面，所以还需要在activity的标签里手动添加：\n```\n<intent-filter>\n\t<action android:name=\"android.intent.action.MAIN\"/>\n    <category android:name=\"android.intent.category.LAUNCHER\"/>\n</intent-filter>\n```\n这样，新添加的acticity就是启动页了。\n## 新建页面布局文件\n虽然已经有了一个空的Activity，但是还没有东西可以显示。\n在res文件夹立新建一个layout文件夹，用来存放布局文件，然后新建一个Layout resources file，是一个xml格式的文件，在这里写布局：\n```\n<Button\n        android:id=\"@+id/button_1\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button 1\"\n        />\n```\n添加了一个button，然后在标签里写的id是这个空间的唯一标示，layout_width和layout_height是控件的大小（match_parent是屏幕宽度，wrap_content是刚好能容纳控件内容的高度），text就是button上面显示的文字\n\n## 在Activity里操作布局里面的控件\n刚才已经建好了一个button，我们可以在Activity里面操作这个控件：\n```\nsetContentView(R.layout.first_layout);\nButton button1 = (Button) findViewById(R.id.button_1);\nbutton1.setOnClickListener(new View.OnClickListener() {\n\t@Override\n    public void onClick(View view) {\n    Toast.makeText(FirstActivity.this,\"You Clicked Me!\",Toast.LENGTH_SHORT).show();\n    }\n});\n```\n* 第一行的setContentView是把布局文件添加到当前Activity里面，R.layout.xxx是在引用res里面的layout文件夹里面的资源文件。\n* 第二行从布局文件里面获取一个View，然后显式转换为button类型赋值给一个button类的实例变量。\n* 第三行setOnClickListener是对button实例变量调用的方法（监听器），传入的一个参数为新建的View.onClickListener，然后对这个setOnClickListener方法进行覆写。\n* 后面的onClick是button监听器里的默认会执行的单击方法，所以在这个方法里写Toast\n* Toast.makeText（）是一个静态方法，传入（上下文，文本内容，显示时长），然后调用show（）方法显示出来\n\n### Activity的基本使用\n刚才已经使用了Toast，还有一个常用的控件Menu\n#### Menu\n* 首先在res文件夹下新建文件夹menu文件夹，再在menu文件夹下新建Menu resource file\n* 在这个文件里添加：\n```\n \t<item\n        android:id=\"@+id/add_item\"\n        android:title=\"Add\"\n        />\n    <item\n        android:id=\"@+id/remove_item\"\n        android:title=\"Remove\"\n        />\n```\n在Menu的布局里添加了两个item，分别设置它们的id和title\n\n* 回到Activity.java的文件里，重写onCreateOptionsMenu（）方法，先getMenuInflater（）获取到一个菜单展开器，然后调用inflate把资源文件里的menu展开\n```\n\t@Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main,menu);\n        return true;\n    }\n```\n* 返回值表示是否允许创建的菜单显示出来\n上面的代码能够将menu显示出来，如何响应按钮的item?\n\n* 覆写：\n```\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId())\n    {\n        case R.id.add_item:\n        \tToast.makeText(FirstActivity.this,\"You clicked item named add\",Toast.LENGTH_SHORT).show();\n            break;\n        case R.id.remove_item:\n            Toast.makeText(FirstActivity.this,\"You clicked item named remove\",Toast.LENGTH_SHORT).show();\n            break;\n    }\n    return true;\n}\n```\n通过switch判断不同的item的id去做不同的动作响应\n\n#### Intent\nIntent不仅是各组件中交互的重要方式，可以指明当前组件想要执行的动作，还可以在组件之间传递数据。\n** Intent 一般可以用于启动活动、启动服务、发送广播等场景 **\n##### 显式Intent\n* 在某一个触发事件里可以创建一个Intent的实例：\n```\nIntent intent = new Intent(FirstActivity.this , SecondActivity.class);\n```\n第一个参数提供启动活动的上下文，第二个参数是目标活动\n* Activity类提供了一个方法，专门用于启动活动，接受一个intent参数\n```\nstartActivity(intent);\n```\n至于如何返回（即销毁当前的Activity），可以手动绑定方法去执行finish（），也可以是手机上的返回键\n\n##### 隐式Intent\n隐式的用法是通过AndroidManifest.xml中的Activity的配置相关信息，然后在Activity.java中调用符合配置的Activity，而不是直接指定某个Activity的类。\n下面举例：\n```\n<activity android:name=\".SecondActivity\">\n\t<intent-filter>\n    \t<action android:name=\"com.example.activitytest.ACTION_START\"/>\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n    </intent-filter>\n</activity>\n```\n然后在FirstAcitvity.java里面写的和显式的不同：\n```\nIntent intent1 = new Intent(\"com.example.activitytest.ACTION_START\");\nstartActivity(intent1);\n```\n直接写为Activity支持的action名。\n** 另外，每个intent只可以对应一个action，但是可以对应多个category，只有当category和action同时满足范围的时候才可以正常调用，否则会崩溃并抛出异常 **\n\n其实还有别的隐式intent的用法，比如跨应用唤起某个页面：\n```\nIntent intent1 = new Intent(Intent.ACTION_VIEW);\nintent1.setData(Uri.parse(\"http://google.com\"));\nstartActivity(intent1);\n```\n这样就可以唤起浏览器并打开http://google.com\nACTION_VIEW是安卓系统内置的动作，然后Uri.parse（）是将字符串解析为Uri对象，最后用setDdata（）把Uri对象传入。\n\n除此之外，还可以在<intent-filter>中配置 data 标签，实现更精确地响应：\n```\n<activity android:name=\".SecondActivity\">\n\t<intent-filter>\n        <action android:name=\"android.intent.action.VIEW\"/>\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n        <data android:scheme=\"\"/>\n        <data android:host=\"\"/>\n        <data android:port=\"\"/>\n        ...\n    </intent-filter>\n</activity>\n```\n这里的action的值配置为；鹅Intent.ACTION_VIEW的常量值，同时data字段也配置了可以响应的协议类型等字段，假如我们设置的scheme字段是http，那么用户在打开一个http网页的时候，会提示用户选择我们的这个Activity打开。\n\n安卓系统内部其实有很多中intent.ACTION的类型，有唤起地理位置界面的、拨号的等等。\n\n#### 页面间传值\nIntent不仅可以用来启动Activity，还可以在页面跳转同时传值\n\nIntent提供了一系列对putExtra（）的重载，可以在调度Activity的同时把数据暂存在Intent中，到达了另外一个Activity的时候，再由目的Activity把数据从Intent中取出就可以了。\n```\nintent2.putExtra(\"string_from_firstActivity\", \"hello second\");\n```\n上面的这是设值\n```\nIntent intent = getIntent();\nLog.v(\"SecondActivty\",intent.getStringExtra(\"string_from_firstActivity\"));\n```\n这是取值\n\n这种适合用来做单向正向传值。除了这种之外还有反向传值：\n```\nstartActivityForResult(intent2,1);\n```\n这个方法能够期望SecondActivity销毁时能够返回结果给FirstActivity。\n然后需要在FirstActivity中覆写onActivityResult方法：\n```\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    switch (requestCode){\n        case 1:\n            if (resultCode==RESULT_OK){\n                Log.v(\"FirstActivity\",data.getStringExtra(\"back_to_first\"));\n            }\n    }\n```\n通过对Intent data调用getStringExtra方法得到返回回来的数据。、\nrequestCode是前面写的数字。用来标示从FirstACtivity跳转到的不同Activity\nresultCode是SecondActivity返回数据时传入的参数。用来标示是否处理成功。\ndata就是携带的数据。\n\n对于SecondActivity来说，只要设值，然后调用setResult（）就可以了\n```\nintent.putExtra(\"back_to_first\",\"hello,first\");\nsetResult(RESULT_OK,intent);\n```\n\n除此之外，还可以直接监听到返回键的事件来处理响应的事件：\n```\n@Override\npublic void onBackPressed() {\nToast.makeText(SecondActivity.this,\"onBackPassed\",Toast.LENGTH_SHORT).show();\n}\n```\n### Activity的生命周期\n\n#### 返回栈\nAndroid也是用栈的方式去管理Activity，用Task去管理，返回栈是BackStack\n#### 活动的四个状态\n每个Activity有四种状态：\n##### 运行状态\n最栈顶的Activity就是处于运行状态的，系统最不喜欢回收这种状态的Activity\n##### 暂停状态\n因为并不是所有的Activity都是全屏状态，所以会存在一个Activity是可见的，但是上面有一个小的Activity部分遮挡，这样一来，后面的Activity既不在栈顶（非运行态），又是可见的。这种状态就是暂停状态。一般系统也是不考虑去回收这种状态的Activity，只有在内存极低的时候才有可能被系统回收。\n##### 停止状态\n如果一个活动在栈中，并且完全不可见的时候，就处于停止状态，系统会保存Activity的状态和成员变量。这个时候它并不是完全可靠的，当内存不足的时候就可能被系统回收。\n##### 销毁状态\n如果一个Activity从返回栈中被移除掉的话，它就会成为销毁状态，系统最优先回收这种状态的Activity。\n\n#### 活动在三种生存期的七个回调方法\n\n##### 完整生存期\n从onCreate（）开始到onDestory（）结束\n###### onCreate（）\n每个Activity中都重写这个方法，它会在每个Activity创建的时候调用，所以这个方法中应该完成一些例如加载布局文件、绑定事件等初始化操作。\n###### onDestory（）\n这个方法在Activity被销毁之前调用，调用完成之后Activity就进入销毁状态\n\n##### 可见生存期\nActivity从onStart（）到onStop（）之间的部分就是可见生存期。可见生存期的可见二字就意味着Activity是显示的，就算不能交互，也要算在内。\n开发者就可以通过在onStart（）方法中加载资源，在onStop（）方法中释放资源，来保证停止状态的Activity不会占用过多的资源。\n###### onStart（）\n这个方法在Activity由不可见变成可见的时候调用\n###### onStop（）\n相反的，当Activity变得**完全**不可见的时候调用\n\n##### 前台生存期\n在onResume（）方法和onPause（）方法之间的Activity就是前台生存期。这时候Activity子那个是处于运行状态，可以与用户交互\n###### onResume（）\n这个方法是Activity已经准备好和用户交互的时候调用。这个时候的Activity在栈顶并且一定是运行状态。\n###### onPause（）\n这个方法是系统准备去启动某个Activity或者恢复到某个Activity的时候调用，这个方法中一般用于把一些消耗系统资源的释放掉，或者保存一些关键数据，但是这个方法里执行的不能是一些耗时操作。\n**如果是一个对话框出现在某个Activity上面的时候，如果没有完全遮挡，那么会调用onPause（）而不是onStop（）**\n\n除此之外，还有一个独立在这三种生存期之外的回调方法：\n###### onRestart（）\n这个方法是Activity在由停止状态重新变成运行状态的时候调用的。\n\n下面附一张Activity的生命周期图（书上原图）：\n![Activity的生命周期](https://s1.ax1x.com/2018/06/07/CH124K.jpg)\n\n下面做一个测试用于FirstActivity到SecondActivity然后再跳转回来的一个状态跟踪打印：\n```\n06-07 14:45:16.457 16551-16551/com.example.ifan.activitytest V/life: onCreate is called\n06-07 14:45:16.736 16551-16551/com.example.ifan.activitytest V/life: onStart is called\n06-07 14:45:16.742 16551-16551/com.example.ifan.activitytest V/life: onResume is called\n06-07 14:45:29.731 16551-16551/com.example.ifan.activitytest V/life: onPause is called\n06-07 14:45:30.536 16551-16551/com.example.ifan.activitytest V/life: onStop is called\n06-07 14:46:24.588 16551-16551/com.example.ifan.activitytest V/life: onRestart is called\n06-07 14:46:24.590 16551-16551/com.example.ifan.activitytest V/life: onStart is called\n06-07 14:46:24.591 16551-16551/com.example.ifan.activitytest V/life: onResume is called\n06-07 14:46:41.625 16551-16551/com.example.ifan.activitytest V/life: onPause is called\n06-07 14:46:42.003 16551-16551/com.example.ifan.activitytest V/life: onStop is called\n06-07 14:46:42.004 16551-16551/com.example.ifan.activitytest V/life: onDestory is called\n```\n可以看出来从FirstActivity到SecondActivity的时候，经过了onPause（）和onStop（）的方法的调用；从SecondActivity回到FirstActivity的时候，经过了onRestart（）、onStart（）和onResume（）的调用\n\n\n再做一个部分遮挡的例子：SecondActivity是一个对话框式的Activity时候，从FirstActivity到SecondActivity打印出来的是：\n```\n06-07 14:56:10.743 17244-17244/com.example.ifan.activitytest V/life: onCreate is called\n06-07 14:56:11.011 17244-17244/com.example.ifan.activitytest V/life: onStart is called\n06-07 14:56:11.019 17244-17244/com.example.ifan.activitytest V/life: onResume is called\n06-07 14:56:14.760 17244-17244/com.example.ifan.activitytest V/life: onPause is called\n06-07 14:56:24.734 17244-17244/com.example.ifan.activitytest V/life: onResume is called\n```\n可以看到这种情况少了onStop（）、onRestart（）和onStart（）的调用过程。\n\n另外还可以看到在按返回键的时候的调用过程如下：\n```\n06-07 15:22:38.832 18596-18596/com.example.ifan.activitytest V/life: onPause is called\n06-07 15:22:39.261 18596-18596/com.example.ifan.activitytest V/life: onStop is called\n06-07 15:22:39.262 18596-18596/com.example.ifan.activitytest V/life: onDestory is called\n```\n看到有博客说按home、返回、在后台杀进程的调用过程会有差异。\n另外在onStop（）的覆写中如果不写对父类方法的调用会导致Activity直接被回收，下一次还需要重新create。也很好理解，因为不调用父类方法的话其实就少了状态、变量的保存过程，所以会出现这样的结果。\n\n#### Activity在停止状态被回收的情况\nActivity在活动状态是可能被回收的，也就是可能存在以下场景：\nA跳转到B，然后A进入停止状态，但是A被销毁了，这时候从B回来就不会调用onRestart（）方法，而是调用onCreate（）方法。这时候因为A在onStop（）方法里写入的数据也随着之前停止状态的Activity被销毁了，所以这时候从B回去之后看到的A就是一个新创建的A了。\n怎么解决呢？\nActivity提供了一个onSaveInstanceState（）的回调方法，这个方法能够保证在Activity被Destory之前一定会被执行。所以我们可以在在这里保存A的Stop数据。\n\n这个onSaveInstanceState（）携带一个Bundle类型的参数，Bundle提供了一系列用于保存数据的方法。\n```\n@Override\nprotected void onSaveInstanceState(Bundle outState) {\n\toutState.putString(\"FirstActivityDataOut\",\"help~\");\n    super.onSaveInstanceState(outState);\n}\n```\n然后在onCreate（）方法中携带的Bundle类型的参数里获取这个Bundle中的数据就可以了。\n```\nif(savedInstanceState.getString(\"FirstActivityDataOut\")!=null)\n\tLog.v(\"FirstActivityDataOut\",savedInstanceState.getString(\"FirstActivityDataOut\"));\n```\n除此之外，在Intent的使用中也可以使用Bundle来传值。\n\n### Activity的四种启动模式\n四种启动模式是在AndroidManifest.xml里面的Activity对应的标签里面指定的。\n#### standard\n标准模式，也就是默认模式，在一个Activity建好的初始设置就是这个，每次启动一个新的Activity的时候，它就在返回栈中入栈，处于栈顶位置。这样的话，当此Activity递归地跳转到本类的Activity，栈中也会不停地新建、入栈。\n#### singleTop\n栈顶单例，顾名思义，处于栈顶的Activity在进行上面的操作的时候，会被直接使用本activity，而不是不断新建、入栈。但是前提条件必须是：** 当前的Activity必须处于栈顶。**\n\n**一个有意思的现象是使用startActivityForResult（）去启动这个singleTop的Activity的时候，是无视它的singleTop模式的，google这样设计的原因可能是考虑到回调的内容没有接受者**\n#### singleTask\n上一种的singleTop是只检查栈顶，避免了单个Activity的递归启动。除此之外还可以让某个Activity在整个返回栈中成为唯一的一个Activity。\n例如：\n\nA->B->C->D->E->B\n\n如果B的启动类型为singleTask，那么在从E到B的时候实际上是回到了最前面B，而且最前面的B之后的都会被从栈里弹出。\n\n#### singleInstance\n这个是不同于上面的三种的一种特殊的启动方式——这种启动模式的Activity会启用一个另外的返回栈去管理这个活动。应用场景就是当别的程序要共享访问这个Activity，其他的三种模式就不能完成了。（每个程序都有自己的返回栈，如果访问了这个Activity，那必定是在当前的程序和别的那个程序里面都会分别加入一个新建的这个Activity，那就是不同的实例了，达不到共享的目的。）\n\n而这个singleInstance就是解决这种情况的——**它会连同Activity一块返回一个单独的返回栈，然后任何一个应用来访问这个Activity，都公用同一个返回栈。**\n例如：\n\nA -> B -> C\n\n如果B的启动模式为singleInstance的话，实际的栈是这样的：\nA — C\nB\n第一个栈是本程序自己的栈，因为A、C都是普通的模式，所以都默认入栈到程序自己的默认栈里了。而第二个栈就是随着B一同创建的新栈，这个栈是所有程序调用时公用的。\n\n所以返回键连续按下之后，先是C所在的栈先出栈C，然后是A，因为是同一个栈，最后才是B，因为程序自己所在的栈已经空了，就轮到B所在的栈出栈了。\n\n### 一些实践\n了解了Activity的基础知识后，这里还有一些关于Activity的应用技巧。\n#### 获知当前所处Activity\n当拿到别人的代码时候，可能就不方便知道当前的界面是处于哪一个Activity了，一个个对应也很麻烦，所以有一个办法去获知当前所处的Activity：\n使用间接继承的原理，新建一个中间类BaseActivity继承自AppCompatActivity，在onCreate（）的方法中扩展一个打印当前类的语句：\n```\nLog.v(\"BaseActivity\",getClass().getSimpleName());\n```\n然后让所有的Activity都继承自这个BaseActivity，然后就可以显示出当前类的类名了。\n**但是同时也有一个让人没有办法接受的缺点：难道我拿到别人的代码要把所有的Activity的继承类都修改一遍么？！**\n\n#### 退回到任意Activity\n用一个List去手动维护一个返回栈，从而能够对这个返回栈的Activity手动操控，就可以返回到任意Activity：\n```\npublic static boolean backToIndexOfStack(int index){\n        if (index>=activityList.size()){\n            return false;\n        }\n        for (int i = activityList.size()-1;i > index;i--){\n            activityList.get(i).finish();\n            activityList.remove(activityList.size()-1);\n        }\n\treturn true;\n}\n```\nindex从0开始，这里依次从栈里finsh（）掉Activity，并且从手动维护的栈中remove掉。\n#### 启动Activity的最佳写法\n在多人协作开发的时候，协定传参总是一个要考虑的点。可以在启动Activity的时候封装一个activityStart（）方法，专门用来构建Intent，这样一来参数就在这个activityStart（）方法的参数列表里体现出来了。\n```\n\tpublic void activityStart(Context context,String firstName,String lastName){\n        Intent intent = new Intent(context,SecondActivity.class);\n        intent.putExtra(\"param1\",\"hello\");\n        intent.putExtra(\"param2\",\"there\");\n        startActivity(intent);\n    }\n```\n# Android UI的开发\n前面的一节是从探究Activity的角度去了解Activity的用法和特点。接下来就是学习如何编写UI，结合Activity去编写完整的UI已经交互逻辑。\n\n## 常用控件的使用\n### TextView\n这个控件类似于iOS里面的UILabel，用于展示文字信息。\n```\n    <TextView\n        android:id=\"@+id/text_view\"\n        android:text=\"This is a TextView\"\n        android:gravity=\"center\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\" />\n```\nandroid:layout_width、android:layout_height这两个属性是所有控件里面都有的，就像iOS里面的Frame一样用来设置大小，但是这个只是表示了大小并不明位置。\n后面的值可选三种值：\n* match_parent：表示让当前的控件和父布局的大小一样大。\n* fill_parent：和match_parent的意义一样，现在官方推荐使用match_parent。\n* wrap_content：表示让控件的大小刚好能包含控件中展示的内容，控件大小由控件内容决定。\n\n当然了，也可以手动指定固定值作为width、height的值，但是这样会导致适配出现问题。\n \n**gravity**：指定的是对齐方式，和iOS里TextAlignment类似。可选的有top、bottom、left、right、center。（center是默认指定\"center_vertical|center_horizontal\"的，表示垂直和水平方向都居中）\n\n**textSize**：指定文字大小。在Android里字体大小是使用sp作单位的。其实在打出24这个将要指定大小的数字的时候，自动补全了几个选项：dp、in、mm、pt、px、sp。好奇这几个有什么区别。之后我会另外开一个文去写这个的。\n**textColor**：#+6位16进制数表示颜色。\n\n更多的使用细节去查文档就好。\n\n### Button\n它在布局文件里的写法大同小异，它有一个textAllCaps属性，如果不设置为false的话默认为true就会把所有出现的字母都变为大写的。\n然后就可以在Activity的类里面去获取这个控件了：\n```\n\t\tButton button1 = (Button) findViewById(R.id.button_1);\n        button1.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                //点击之后的代码\n            }\n        });\n```\n这是一种类似闭包的方式，其实还有一种通过实现接口的方式，需要在本类的声明部分写明实现哪一个接口，然后在设置button的监听者为本类，然后覆写onClick（）方法，方法内部通过判断id来分别实现不同button的点击事件。\n\n### EditText\n这个控件实际上就是iOS里的TextView，支持多行输入和排版。\n特别的属性：\n\n**hint**：这一个是iOS里面的TextView里面没有的类似于placeHolder的设置。\n\n**maxLines**：EditText如果高度不是定值，就会随着输入内容的增多而拉长。如果指定了这个属性，则EditText不会被拉长，但是内容视图的长度还是会被拉长。而且，它只是限制了EditText这个控件的最大显示行数，并没有限制内容的行数。\n\n另外，还可以在Activity里面获取到EditText里面的文字信息：\n```\nEditText editText = findViewById(R.id.edit_text);\neditText.getText().toString()\n```\n### ImageView\n这个倒是和iOS里的UIImageView差别不大,不过现在资源大多都同意放在res目录下的drawable目录下，但是这个目录没有制定具体的分辨率，所以书上的建议是新建一个drawable-xhdpi文件夹，然后把图片放进去。\n\n对于图片的设置有两种方法，一种是直接写在布局文件里，一种是在Activity类里去修改。这两种可以同时使用。\n\n**有意思的是，Android的图片文件并不能带大写字母，不然会报错说只支持小写字母、数字和下划线。**\n\n同时对文件名里带“.”的文件也不能支持，会报错。\n\n\n**另外，在一开始设置的height为wrap_content其实也没有起作用。**\n### ProgressBar\n显示一个进度条（默认样式是一个不断循环转动的圈圈）。布局文件里写的是默认可见的（当然也可以手动指定为其他值），就可以在Activity里去判断它当前是否是可见的，如果是可见的，可以设为不可见。\n\n在布局文件里设置:\n```\n        android:visibility=\"invisible\"\n```\n在Activity里设置：\n```\n\t\tif (findViewById(R.id.progress_bar).getVisibility() ==View.VISIBLE){\n            findViewById(R.id.progress_bar).setVisibility(View.INVISIBLE);\n        }\n\n```\n对于ProgressBar来说有三种可见选项：visible、invisible、gone\n\n**visible**：可见的。\n\n**invisible**：不可见，但是还占据着原来的位置和大小，可以理解为透明状态。\n\n**gone**：不仅是不可见的，而且完全从屏幕上消失。\n\n除了上面的那种圈圈的样式，还有一种样式是条状的。可以通过在布局文件里设置style为：\n```\nstyle=\"?android:progressBarStyleHorizontal\"\n```\n对于这种样式，可以设置一个最大值，以便在Activity中动态的改变进度条的状态。\n\n布局文件：\n```\n\nandroid:max=\"100\"\n```\nActivity：\n```\nProgressBar progressBar = findViewById(R.id.progress_bar);\nprogressBar.setProgress(progressBar.getProgress()+10);\n```\n### AlertDialog\n弹出一个对话框，一般用于警告用户，下方有三个按钮可以响应用户的点击事件\n```\nAlertDialog.Builder dialog = new AlertDialog.Builder(FirstActivity.this);\ndialog.setTitle(\"this will change image\");\ndialog.setMessage(\"this is very importent\");\ndialog.setCancelable(true);\n\ndialog.setNeutralButton(\"NeutralButton\", new DialogInterface.OnClickListener() {\n    @Override\n    public void onClick(DialogInterface dialogInterface, int i) {}\n});\ndialog.setNegativeButton(\"Cancle\", new DialogInterface.OnClickListener() {\n    @Override\n    public void onClick(DialogInterface dialogInterface, int i) {}\n});\ndialog.setPositiveButton(\"OK\", new DialogInterface.OnClickListener() {\n\t@Override\n    public void onClick(DialogInterface dialogInterface, int i) {}\n});\n\ndialog.show();\n```\n可以在示例代码中看到，使用一般是三个步骤，先用Builder新建一个AlertDialog实例出来（指定Activity），然后设置标题、信息内容、可否在点击别的空白处取消这个AlertDialog。\n\n然后分别设置三个按钮（从左到右依次为NeutralButton、NegativeButton、PositiveButton）的点击回调事件。\n\n### ProgressDialog\n和上面的那个AlertDialog很类似，也可选两种样式——转圈圈或者一个条状的进度条。\n```\nProgressDialog progressDialog = new ProgressDialog(FirstActivity.this);\nprogressDialog.setTitle(\"progressDialog\");\nprogressDialog.setMessage(\"this is a progressDialog\");\nprogressDialog.setCancelable(true);\nprogressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\nprogressDialog.setMax(256);\nprogressDialog.show();\n```\n这种的是和前面的ProgressBar是一样的，可以设置最大的长度、动态改变进度状态。\n默认是转圈的样式。\n\n**需要注意的是，如果这个也设置为不允许失焦取消，那不知道何时会结束的progressDialog就会导致当前应用卡死，无法继续交互。如果设置为允许失焦消失，那就要处理好消失的逻辑，是否是用户选择取消当前进度？如果误操作怎么处理？如果是取消应该处理当前进度的任务？**\n\n## 四种基本布局\n布局是一种可用于放置很多控件的容器。布局是可以嵌套的。可以通过布局的嵌套来完成一些复杂的布局效果。这一部分将用一个新的项目去学习和练习。\n### 线性布局-LinearLayout\n是一种非常常用的布局，这种布局会将内部包含的控件在线性方向上依次排列。\n还记得最开始接触布局文件么？那个就是默认的线性布局（因为是根元素），有横向和竖向两种。\n\n可以通过orientation来指定线性到底是竖向还是横向。\n```\nandroid:orientation=\"horizontal\"\nandroid:orientation=\"vertical\"\n```\n**需要注意的是，这时候控件的size就要设置合理。比如水平线性布局的时候，控件的宽度就不能match_parent了**\n\nlayout的几个重要属性：\n#### layout_gravity\n和gravity属性有点相似，但是其实完全没有关系。\n\n**gravity**属性是指定某个控件内部的内容（如文字）在控件内是靠向哪一边的。\n\n**gravity_layout**是指定当前控件在父布局中的位置是在如何对齐的。\n同样的，在父布局已经处于某种方式的时候要做合理的设置，例如：父布局是水平布局（horizontal），只有设置控件在竖向位置的对齐（top、center、bottom等）才会生效。\n\n#### layout_weight\n这个属性是用比例的方式去指定控件的大小的，有一些自动布局的感觉。\n需要区别的是控件的width属性，虽然可能长的像，但是二者是完全不同的：\n\n**width**：用数值或者一些定义过的常量或者宏指定宽度。\n\n**weight**：用比例去指定当前控件在水平方向上占用多少比例。\n\n当weight存在的时候，width是不生效的，也就是随便写多少都没用，但是比较规范的写法是写为0dp。（dp是Android里用于指定控件大小、间距的单位）\n\n然后weight里写的是比例，如果控件1里面写的是1，另一个控件里写的2，那么就表示两个控件的宽度比例是1:2。\n\n有的控件里没有写weight，只写了width为wrap，这时候就还是保证控件的宽度刚够包含控件自己的内容。\n\n如果控件1写了weight的值为1，控件2没有写weight但是写了width为wrap，那就是控件1尽量宽，然后控件2的宽度刚够包含自己的内容。\n\n### 相对布局：RelativeLayout\n这种布局也是非常常用的布局，这种布局更随意一些，它可以用相对定位的方式让控件出现在布局的任意位置。\n\n正因如此，相对布局的属性就多了一些，但是好在都是有规律的。\n```\n\t<Button\n        android:text=\"hello3\"\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"wrap_content\"\n        android:layout_alignParentEnd=\"true\"\n        android:layout_alignParentTop=\"true\"\n        />\n```\n可以看到，里面的位置相关的代码里面有Parent字段，也就是说，这些控件是相对于父布局来定位的。当然了也可以不依据父布局进行定位：\n```\n\t<Button\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"wrap_content\"\n        android:layout_above=\"@+id/text_view\"\n        android:layout_toLeftOf=\"@+id/text_view\"\n        android:text=\"hello1\"\n        />\n```\n可以通过id去选定相对的参考控件，去选择相对位置。\n**但是只能去参考前面出现过的控件，不然就找不到id了。**\n\n另外还有layout_alignLeft表示和目标控件左对齐，其他的其他方向都是一样的。\n\n### 帧布局 FrameLayout\n这种布局非常简单，相比前面的两种来说，使用场景也较少。\n\n这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角。多个控件按照默认方式放置会重叠在一起。\n\n当然，也可以用layout_gravity属性去指定控件的对齐方式，但是比起前面的几种来说还是太简单了，导致实际的应用场景也不是那么多。\n### 百分比布局\n安卓引用了一种全新的布局方式来解决线性布局不够强大的比例式布局的缺点，这种布局中，可以不再用wrap_content、match_parent等方式去指定控件的大小，而是直接指定控件在布局中所占的百分比，这样就可以轻松实现任意比例分割布局了。\n\n百分比布局对FrameLayout和RelativeLayout进行了功能扩展，提供了PercentFrameLayout和PercentRelativeLayout的全新布局。\n\n为了让这种布局方式能够兼容就的安卓版本上使用，这种布局定义在support库中，只需要在项目的build.gradle中添加百分比布局的依赖保证兼容性。\n```\n<android.support.percent.PercentFrameLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n\n    <TextView\n        android:id=\"@+id/text_view\"\n        android:layout_gravity=\"start\"\n        app:layout_widthPercent=\"50%\"\n        app:layout_heightPercent=\"50%\"\n        android:text=\"hello~\"\n        />\n    \n\n</android.support.percent.PercentFrameLayout>\n```\n这里的app并没有补全，想来应该是因为这个并不在内置在系统的SDK中的，所以没有自动补全。\n\n**这种布局有一个大坑：写50%的时候总是先写50再写%，写这里的时候我写了50然后手抖后面多跟了个0，成了500，然后就直接卡死，告诉我Out of Memory。其实也很好解释，因为AndroidStudio是可以自动预览布局的，所以这里还来不及修改的时候，已经自动按照500去算百分比了，1是100%，那么500就是50000%，所以就内存不够了。**\n\n对于另一种PercentRelativeLayout，它继承了RelativeLayout的所有属性并且加入了app:layout_widthPercent和app:layout_heightPercent来指定控件的宽高。\n\n### 约束布局——ConstraintLayout\n因为书上的几种布局方式比较老，其实在现在的AndroidStudio里面新建一个project的时候，已经默认设置为这种约束布局了，所以换句话说，这个应该重点学习，它被默认支持一定是有它的优点的。\n\n之前一直是用代码去编写布局，是因为前面的几种布局对于用代码的表达更好一些。但是归根结底来说，布局这种的用可视化去编辑是最直观最合适的，所以这个就是为了解决这种问题的一种新的布局方式。（这个书的作者也说了，当时在写书的时候这个布局方式刚出来，就没有加入到书里。）\n\n这种布局方式是使用控件的相对位置去布局的，有点类似相对布局，但是比相对布局还要强大。\n\n这种布局同时还解决了传统的几种布局的嵌套问题。传统布局要实现复杂的布局往往需要多重嵌套，但是多重嵌套会降低性能，所以这种布局应对复杂布局的时候可能会更好。\n\n这种布局暂时看到的教程都说适合用Design界面去拖拽完成布局操作，所以这里就先不写了。\n\n## 自定义控件\n和iOS一样，Android里的控件也都是直接或者间接的继承自View，所有的布局都是直接或间接继承自ViewGroup。View是Android里的最基本的UI组件。ViewGroup是一种特殊的View，可以包含很多子View和ViewGroup，是用于防止控件和布局的容器。\n\n需要接触几个前面没有接触到的属性：\n\n**background**：为布局或者控件指定一个背景，可以使颜色或者图片。\n\n**margin**：指定控件在四个方向的偏移量，也可以用margin_left等指定单一某个方向上的偏移量。\n\n先写好某一个自定义布局，然后在另一个布局里面引用这个布局就可以了。\n\ntitle.xml：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:layout_margin=\"5dp\"\n        android:text=\"Back\"\n        />\n    <TextView\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:layout_weight=\"1\"\n        android:gravity=\"center\"\n        android:text=\"title\"\n        android:textSize=\"24sp\"\n        />\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:layout_margin=\"5dp\"\n        android:text=\"edit\"\n        />\n\n</LinearLayout>\n```\n\nactivity_miain.xml：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <include layout=\"@layout/title\"/>\n\n</LinearLayout>\n```\n\n这个的实现效果就是自定义了个ActionBar并且加载到主布局中。\n\n## 最常用、最难用的控件——ListView\n这里的ListView就类似于iOS里面的UITableView，重要性不用多说。\n\n先从最简单的用法开始：\n### ListView的简单用法\n先在布局里面写一个ListView进去，这里先写好大小和id就可以。\n\n然后在Activity里面写一个和这个listView相关的实例，把它的适配器指定为某个适配器的实例就好了：\n```\nListView listView = findViewById(R.id.list_view);\nArrayAdapter<String> adapter = new ArrayAdapter<String>(\n\tMainActivity.this,\n    android.R.layout.simple_list_item_1,\n    data\n    );\nlistView.setAdapter(adapter);\n```\n这个适配器只是众多适配器中的一种，这个据说是最好用的，可以通过泛型来指定钥匙胚的数据类型，然后在构造函数里传参进去。\n\nArrayAdapter有很多重载，这里是因为用到的数据都是String类型，所以这里写 了String。然后依次传入当前的上下文、listView的id，以及具体的数据数组。\n\n这里的android.R.layout.simple_list_item_1相当于是iOS里面UITableView的style，可以有很多种style，根据具体的使用场景自行切换。\n\n### 自定义ListView的界面\n自定义的过程和iOS的自定义cell的基本上相似，都是新建一个布局，然后让ListView去加载这个布局作为item，然后把构造好的数据展示到界面上就好了。\n\n* 先新建一个布局：\n```\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n    <ImageView\n        android:id=\"@+id/fruit_image\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"@drawable/ic_launcher_background\"/>\n\n    <TextView\n        android:id=\"@+id/fruit_textview\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center_vertical\"\n        android:layout_margin=\"10dp\"/>\n</LinearLayout>\n```\n这个就是cell（也就是item）的展示布局。\n\n* 新建一个容器类\n这个容器类就是作为ListView的适配器类型：\n```\npublic class Fruit {\n    private String name;\n    private int imageId;\n\n    public Fruit(String name,int imageId){\n        this.name = name;\n        this.imageId = imageId;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getImageId() {\n        return imageId;\n    }\n}\n```\n这个部分就相当于model类的部分，用来存储ListView将来要展示的数据。\n\n* 新建一个适配器类\n```\npublic class FruitAdapter extends ArrayAdapter<Fruit> {\n    private int resourceId;\n    public FruitAdapter(Context context, int textViewResourceId, List<Fruit>object){\n        super(context,textViewResourceId,object);\n        resourceId = textViewResourceId;\n    }\n\n    @NonNull\n    @Override\n    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {\n        Fruit fruit = getItem(position);\n        View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);\n        ImageView fruitImage = (ImageView)view.findViewById(R.id.fruit_image);\n        TextView fruitName=(TextView)view.findViewById(R.id.fruit_textview);\n        fruitImage.setImageResource(fruit.getImageId());\n        fruitName.setText(fruit.getName());\n        return view;\n    }\n}\n```\n可以看到这个适配器类是继承自ArrayAdapter的，声明了一个私有属性resourceId，然后在这个类的构造函数里传入三个参数：上下文、textViewResourceId、和一个model类的List对象。调用父类的方法，对私有属性赋值。\n\n然后需要重写一个父类的方法getView（），这个方法就相当于iOS里面的cellForRowAtIndex，在每次item要出现在屏幕上的时候就会调用。\n\n\n这个getView传入了三个参数：position相当于是index，因为前面在构造函数里面已经设置过了List对象，所以这个方法是把数组中当前要处理的cell的对应元素取出来。\n\n然后要新建一个View对象，这个view是：先获取到Activity的布局渲染器，然后对这个布局渲染器LayoutInflater调用inflate方法。inflate方法需要传三个参数：resourceId（具体的item的那个布局的xml文件）、parent（父布局，和缓存有关）、false（表示这个resourceId所引用的布局是不带父布局的，因为如果带了父布局，就不能添加到目标要添加的父布局了）。\n\n然后从这个view中通过findViewById的方法去找到具体的控件，接着分别从对应顺序的model的元素（第一行的getItem方法已经取出来了的那个）里面取出需要显示在item上面的值，赋值给对应的控件，然后返回这个view作为ListView的item。\n\n* 在Activity中：\n\n```\nprivate List<Fruit> fruits = new ArrayList<>();\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n\tsuper.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    ListView listView = findViewById(R.id.list_view);\n\n    initFruit();\n    FruitAdapter adapter = new FruitAdapter(MainActivity.this,R.layout.fruit_item,fruits);\n\n    listView.setAdapter(adapter);\n}\n\nprivate void initFruit(){\n\tfor (int i =0;i<100;i++){\n    \tFruit fruit = new Fruit(\"apple\"+i,R.drawable.ic_launcher_background);\n        fruits.add(fruit);\n    }\n}\n```\n\n前面的其实都是准备的工作，要生效还是在Activity里面建立数据数组，然后对数据数组进行初始化，然后新建一个自定义的适配器，最后把listview的适配器设置为刚才建立好的自定义适配器实例。\n\n要实现更复杂的item，只要修改model和item的布局文件就可以了。\n\n### 提升ListView的效率\n\nListView之所以难用就是因为它的使用初看比较简单，但是实际上有很多可以优化的点，比如提升效率。\n\n前面写的代码的运行效率就很低，因为在适配器的代码中，每次item出现的时候，都会调用的getView方法中都会加载一遍布局。当ListView快速滑动的时候，就会带来不小的负担。\n\n其实前面没有注意到的是，getView还有一个参数：convertView。\n\n这个参数是将之前加载好的布局缓存起来，以便之后再次使用。\n\n所以其实可以这样用：\n```\nView view;\nif (convertView == null)\n\tLayoutInflater.from(getContext()).inflate(resourceId,parent,false);\nelse\n    view = convertView;\n```\n这样一来，就不会每次都不分青红皂白地去加载布局了，而是先判断缓存的布局是不是为空，如果为空，再去加载布局，如果不为空，就直接变动要显示的数据就好了。\n\n**纵使这样，代码的性能还能继续优化：**\n虽然已经可以不用重复地去加载布局了，但是对于getView方法，还是需要每次从view里面通过findViewById去找到具体的控件。所以这里就可通过新建一个ViewHolder类去缓存每个控件了：\n```\n@NonNull\n@Override\npublic View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {\n\tFruit fruit = getItem(position);\n\n    ViewHolder viewHolder;\n    View view;\n    if (convertView == null){\n    \tview = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);\n    \tviewHolder = new ViewHolder();\n        viewHolder.fruitImage = (ImageView)view.findViewById(R.id.fruit_image);\n        viewHolder.fruitName = (TextView)view.findViewById(R.id.fruit_textview);\n        view.setTag(viewHolder);\n    }\n    else{\n    \tview = convertView;\n        viewHolder = (ViewHolder)view.getTag();\n    }\n\n    assert fruit != null;\n    viewHolder.fruitImage.setImageResource(fruit.getImageId());\n    viewHolder.fruitName.setText(fruit.getName());\n    return view;\n}\n\npublic class ViewHolder{\n\tImageView fruitImage;\n    TextView fruitName;\n}\n```\n可以看到这里的ViewHolder类也很简单，和Fruit类一一对应，只不过Fruit里面是数据，这个里面是需要改变数据的item的控件。\n\n在原来优化的基础上，对于新加载布局的情况：把从view里面寻找对应的控件，然后存到viewHolder里面，最后把viewHolder实例设置为view的tag；\n\n对于不用重新加载布局的view：直接通过getTag方法获取viewHolder，然后取出viewHolder里面的控件进行操作。\n\n### ListView的点击事件\n也很好理解，就和iOS里面的cell监听方法一样的。\n\n对于Android的ListView，就是实现ListView的setOnItemClickListener方法参数中的闭包。\n\n前面的优化都是在自定义适配器里写的，这里就要回到Activity里面了：\n```\nlistView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n\t@Override\n    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n    \tFruit fruit = fruits.get(position);\n        Toast.makeText(MainActivity.this,\"this is \"+fruit.getName(),Toast.LENGTH_SHORT).show();\n    }\n});\n```\n这个方法是在参数中传入了一个闭包，覆写了onItemClick的方法，传入了三个参数：一个适配器类型的变量、一个当前的item的view，一个当前的index，一个id。\n\n然后如果要让点击之后发生点什么，就在这个onItemClick方法里写就好。\n## RecyclerView\n终于过了那个ListView大户，然后又来了一个传说中更强大的控件——RecycleView。\n\nListView其实有着很多不够强大的地方——一是需要用一些技巧去优化它的性能，二是它只能实现竖向的滚动，不能实现横向的滑动。\n\n所以，Android就提供了一个更强大的控件，这个可以看做一个增强版的ListView，可以轻松实现ListView的效果，还优化了ListView里面的各种不足之处。目前就连Android官方都更加推荐RecycleView。\n\n因为这个也是官方SDK里没有默认提供的控件，所以需要在app/build.gradle里面写明依赖库。\n\n然后就是在布局文件里面写这个控件了。","source":"_posts/Android从0开始的菜鸡学习之路.md","raw":"title: Android从0开始的菜鸡学习之路\nauthor: howard\ntags:\n  - 0基础\n  - 客户端\n  - Android\ncategories:\n  - Android\n  - 客户端\ndate: 2018-06-04 16:05:00\n---\n开头先说几句：\n\n* 我很久没有更新这个博客了，好不容易搭建的差不多，还没有来的及修改一些细节部分，不过还好，不影响使用，之后有空了再改吧。后面会把一些学习的历程、学习笔记或者一些乱七八糟的感想什么的等等东西更新上来，应该也没有什么人来看吧~\n* 这个Android的学习历程其实并不是我学客户端开发的开头——虽然博客里之前也并没有写关于其他的学习历程。。。我其实之前学的是iOS开发，OC写了挺久，最近也在接触Swift，本来是做好了做一个正经的iOS开发实习生（虽然我从来没有过iPhone），但是呢，今天实习公司的导师加了微信，我才得知我去了之后是要做Android的。一开始有点懵，我没写过这个东西呀，Java也掌握的很一般很一般，这意味着我有很多东西需要学习。那，如果我实习留不下呢？我写了一个月的Android然后回来匆匆忙忙复习iOS再投秋招的iOS岗位么？有点纠结，也很难抉择。\n* 后来一想，反正实习还是要去的，那我现在开始了解一些开发Android相关的东西，去了以后能调岗位就最好，不能调的话就尽量争取留下来吧。也问了一些学长的看法作为参考。这不过就是一次挑战而已，总不可能事事如意，这个就当是一个学习能力的挑战吧，能不能在固定的一段时间里学到尽量多的东西。反正iOS的学习基本上也到了瓶颈期，不如，换换口味？\n* 再者说，我也算个安卓机的爱好者吧，因为穷我用的从来都是安卓机，也很早开始折腾安卓系统，root、刷系统、玩xposed……算是从安卓2.x一直到8.1的体验者了。\n* 塞翁失马，焉知非福\n* 那就这么开始学习安卓吧\n\n# 开始前的准备\n## 教材\n我用的是学长推荐的《第一行代码Android》\n## 运行环境\n用了很久的黑苹果10.12.6，AS最新版，不想用模拟器，就用了我刷了8.1的一加2\n\n# HelloWorld\n新建了一个只有一个Activity的项目，它自己就写了“hello，world” 所以其实不算是我自己写的。\n但是比起新建一个EmptyActivity什么都没有一脸懵逼来说好很多了\n## 项目文件夹结构\n### .gradle 和 .idea\n自动生成的文件，不用管\n### app\n主要文件都在这里\n#### build \n也是编译生成的文件，更多更杂，不用管\n#### libs\n第三方包的文件夹，会自动加到构建的路径里\n#### src\n这个文件里的东西是编写的时候需要关注的文件夹，需要自己写的内容基本上都在这里面\n##### androidTest\n可以在这里写测试用例，可以自动化测试\n##### main\n基本上java文件就都在这里了\n###### java\njava文件就在这个文件夹下，比如刚才创建的Activity.java\n###### res \n项目里要用到的所有图片（drawable）、布局（layout）、字符串（values）等\n###### AndroidManifest.xml\n这个是整个项目的配置文件，在程序里定义的所有的四大组件都需要在这里注册，另外还可以写权限声明，这个要经常用到\n##### test\n又是一个测试，先不管\n##### .gitignore\ngit忽略的文件\n##### app.imi\n不用管\n##### build.gradle\napp这个模块的构建脚本\n##### proguard-rules.pro\n用于指定混淆规则，厉害了，用于防止代码被破解\n### build\n编译时自动生成的文件，不用管\n### gradle\n包含了gradle wrapper的配置文件，默认不启用这个方式\n### gitignore\ngit的忽略文件\n### build.gradle\n全局gradle构建脚本，gradle是一个自动化构建脚本，一般不用改\n### gradle.properties\n全局gradle配置文件，会影响整个项目的编译\n### gradlew和gradlew.bat\n是用来执行gradle的，不用管\n### XXX.imi\n是这个IDE的存在感的标识，不用管\n### local.properties\n指定本机的Android SDK的路径，是自动生成的一般不用改\n### setting.gradle\n用来指定项目中所有引入的模块，目前为止一共就用了app这么一个模块，所以现在还就只写了\n```\ninclude ':app'\n```\n\n** 好了，关于文件目录就是这些，总结起来就是外层的文件夹什么的基本上先不用管，要注意的就是app这个文件夹里的 **\n\n## 如何运行起来的\n先看Android-Manifest.xml里做了什么\n### Android-Manifest.xml\n里面有一部分代码长这样：\n```\n<activity android:name=\".MainActivity\">\n\t<intent-filter>\n    \t<action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.LAUNCHER\" />\n    </intent-filter>\n</activity>\n```\n指定了点击应用之后首先启动哪个Activity，这里当然是MainActivity这个类\n那MainActivity这个类里面做了什么操作呢？\n### MainActivity.java\n```\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n}\n```\n这个类是一个继承自AppCompatActivity的类，这个类类似于iOS里的ViewController\n这个类的onCreate方法是一个Activity被创建的时候一定会执行的方法（类似于iOS里的ViewDidLoad）\n这里并没有看到“hello world”的字样。\nAndroid编程讲究逻辑和视图分离，所以setContentView这个方法引入了一个布局文件（res/layout）\n\n### activity_main.xml\n这个文件里面有一部分是这样的：\n```\n<TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n```\n表示布局里添加了一个TextView的控件，设置了ndroid:text=\"Hello World!\"所以会显示出Hello World。这个控件类似于iOS里的UILable\n\n** 这样就大致搞清楚了HelloWorld是怎么运行起来的，并且各种文件是怎么组织起来的。其实和iOS类似的地方很多，AndroidManifest.xml有些类似APPDelegate，Activity类似于ViewController，activity_main.xml类似于xib，但是之前都是直接用代码写的布局类，所以这种的还需要适应一下 **\n\n** 大致过程大概就是，先在AndroidManifest.xml配置Activity，然后在布局文件里面写界面相关的代码，然后在Activity.java里面写对布局里面的控件的操控，也是类似MVC的经典的逻辑分离的设计方法。 **\n\n# 从0开始自己构建一个APP\n前面的HelloWorld是人机自动生成的，这一次开始自己从0开始写一个，选择Empty，这时候没有Acitvity，所以不会有显示的。\n## 新建一个Activity\n在app/src/main/java/com.example.ifan.activitytest右键从new里面选择一个EmptyActivity。这里新建的Activity是会自动在AndroidManifest.xml里面自动添加注册的代码的，但是不会自动设置为最先启动后展示的第一个页面，所以还需要在activity的标签里手动添加：\n```\n<intent-filter>\n\t<action android:name=\"android.intent.action.MAIN\"/>\n    <category android:name=\"android.intent.category.LAUNCHER\"/>\n</intent-filter>\n```\n这样，新添加的acticity就是启动页了。\n## 新建页面布局文件\n虽然已经有了一个空的Activity，但是还没有东西可以显示。\n在res文件夹立新建一个layout文件夹，用来存放布局文件，然后新建一个Layout resources file，是一个xml格式的文件，在这里写布局：\n```\n<Button\n        android:id=\"@+id/button_1\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button 1\"\n        />\n```\n添加了一个button，然后在标签里写的id是这个空间的唯一标示，layout_width和layout_height是控件的大小（match_parent是屏幕宽度，wrap_content是刚好能容纳控件内容的高度），text就是button上面显示的文字\n\n## 在Activity里操作布局里面的控件\n刚才已经建好了一个button，我们可以在Activity里面操作这个控件：\n```\nsetContentView(R.layout.first_layout);\nButton button1 = (Button) findViewById(R.id.button_1);\nbutton1.setOnClickListener(new View.OnClickListener() {\n\t@Override\n    public void onClick(View view) {\n    Toast.makeText(FirstActivity.this,\"You Clicked Me!\",Toast.LENGTH_SHORT).show();\n    }\n});\n```\n* 第一行的setContentView是把布局文件添加到当前Activity里面，R.layout.xxx是在引用res里面的layout文件夹里面的资源文件。\n* 第二行从布局文件里面获取一个View，然后显式转换为button类型赋值给一个button类的实例变量。\n* 第三行setOnClickListener是对button实例变量调用的方法（监听器），传入的一个参数为新建的View.onClickListener，然后对这个setOnClickListener方法进行覆写。\n* 后面的onClick是button监听器里的默认会执行的单击方法，所以在这个方法里写Toast\n* Toast.makeText（）是一个静态方法，传入（上下文，文本内容，显示时长），然后调用show（）方法显示出来\n\n### Activity的基本使用\n刚才已经使用了Toast，还有一个常用的控件Menu\n#### Menu\n* 首先在res文件夹下新建文件夹menu文件夹，再在menu文件夹下新建Menu resource file\n* 在这个文件里添加：\n```\n \t<item\n        android:id=\"@+id/add_item\"\n        android:title=\"Add\"\n        />\n    <item\n        android:id=\"@+id/remove_item\"\n        android:title=\"Remove\"\n        />\n```\n在Menu的布局里添加了两个item，分别设置它们的id和title\n\n* 回到Activity.java的文件里，重写onCreateOptionsMenu（）方法，先getMenuInflater（）获取到一个菜单展开器，然后调用inflate把资源文件里的menu展开\n```\n\t@Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main,menu);\n        return true;\n    }\n```\n* 返回值表示是否允许创建的菜单显示出来\n上面的代码能够将menu显示出来，如何响应按钮的item?\n\n* 覆写：\n```\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId())\n    {\n        case R.id.add_item:\n        \tToast.makeText(FirstActivity.this,\"You clicked item named add\",Toast.LENGTH_SHORT).show();\n            break;\n        case R.id.remove_item:\n            Toast.makeText(FirstActivity.this,\"You clicked item named remove\",Toast.LENGTH_SHORT).show();\n            break;\n    }\n    return true;\n}\n```\n通过switch判断不同的item的id去做不同的动作响应\n\n#### Intent\nIntent不仅是各组件中交互的重要方式，可以指明当前组件想要执行的动作，还可以在组件之间传递数据。\n** Intent 一般可以用于启动活动、启动服务、发送广播等场景 **\n##### 显式Intent\n* 在某一个触发事件里可以创建一个Intent的实例：\n```\nIntent intent = new Intent(FirstActivity.this , SecondActivity.class);\n```\n第一个参数提供启动活动的上下文，第二个参数是目标活动\n* Activity类提供了一个方法，专门用于启动活动，接受一个intent参数\n```\nstartActivity(intent);\n```\n至于如何返回（即销毁当前的Activity），可以手动绑定方法去执行finish（），也可以是手机上的返回键\n\n##### 隐式Intent\n隐式的用法是通过AndroidManifest.xml中的Activity的配置相关信息，然后在Activity.java中调用符合配置的Activity，而不是直接指定某个Activity的类。\n下面举例：\n```\n<activity android:name=\".SecondActivity\">\n\t<intent-filter>\n    \t<action android:name=\"com.example.activitytest.ACTION_START\"/>\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n    </intent-filter>\n</activity>\n```\n然后在FirstAcitvity.java里面写的和显式的不同：\n```\nIntent intent1 = new Intent(\"com.example.activitytest.ACTION_START\");\nstartActivity(intent1);\n```\n直接写为Activity支持的action名。\n** 另外，每个intent只可以对应一个action，但是可以对应多个category，只有当category和action同时满足范围的时候才可以正常调用，否则会崩溃并抛出异常 **\n\n其实还有别的隐式intent的用法，比如跨应用唤起某个页面：\n```\nIntent intent1 = new Intent(Intent.ACTION_VIEW);\nintent1.setData(Uri.parse(\"http://google.com\"));\nstartActivity(intent1);\n```\n这样就可以唤起浏览器并打开http://google.com\nACTION_VIEW是安卓系统内置的动作，然后Uri.parse（）是将字符串解析为Uri对象，最后用setDdata（）把Uri对象传入。\n\n除此之外，还可以在<intent-filter>中配置 data 标签，实现更精确地响应：\n```\n<activity android:name=\".SecondActivity\">\n\t<intent-filter>\n        <action android:name=\"android.intent.action.VIEW\"/>\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n        <data android:scheme=\"\"/>\n        <data android:host=\"\"/>\n        <data android:port=\"\"/>\n        ...\n    </intent-filter>\n</activity>\n```\n这里的action的值配置为；鹅Intent.ACTION_VIEW的常量值，同时data字段也配置了可以响应的协议类型等字段，假如我们设置的scheme字段是http，那么用户在打开一个http网页的时候，会提示用户选择我们的这个Activity打开。\n\n安卓系统内部其实有很多中intent.ACTION的类型，有唤起地理位置界面的、拨号的等等。\n\n#### 页面间传值\nIntent不仅可以用来启动Activity，还可以在页面跳转同时传值\n\nIntent提供了一系列对putExtra（）的重载，可以在调度Activity的同时把数据暂存在Intent中，到达了另外一个Activity的时候，再由目的Activity把数据从Intent中取出就可以了。\n```\nintent2.putExtra(\"string_from_firstActivity\", \"hello second\");\n```\n上面的这是设值\n```\nIntent intent = getIntent();\nLog.v(\"SecondActivty\",intent.getStringExtra(\"string_from_firstActivity\"));\n```\n这是取值\n\n这种适合用来做单向正向传值。除了这种之外还有反向传值：\n```\nstartActivityForResult(intent2,1);\n```\n这个方法能够期望SecondActivity销毁时能够返回结果给FirstActivity。\n然后需要在FirstActivity中覆写onActivityResult方法：\n```\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    switch (requestCode){\n        case 1:\n            if (resultCode==RESULT_OK){\n                Log.v(\"FirstActivity\",data.getStringExtra(\"back_to_first\"));\n            }\n    }\n```\n通过对Intent data调用getStringExtra方法得到返回回来的数据。、\nrequestCode是前面写的数字。用来标示从FirstACtivity跳转到的不同Activity\nresultCode是SecondActivity返回数据时传入的参数。用来标示是否处理成功。\ndata就是携带的数据。\n\n对于SecondActivity来说，只要设值，然后调用setResult（）就可以了\n```\nintent.putExtra(\"back_to_first\",\"hello,first\");\nsetResult(RESULT_OK,intent);\n```\n\n除此之外，还可以直接监听到返回键的事件来处理响应的事件：\n```\n@Override\npublic void onBackPressed() {\nToast.makeText(SecondActivity.this,\"onBackPassed\",Toast.LENGTH_SHORT).show();\n}\n```\n### Activity的生命周期\n\n#### 返回栈\nAndroid也是用栈的方式去管理Activity，用Task去管理，返回栈是BackStack\n#### 活动的四个状态\n每个Activity有四种状态：\n##### 运行状态\n最栈顶的Activity就是处于运行状态的，系统最不喜欢回收这种状态的Activity\n##### 暂停状态\n因为并不是所有的Activity都是全屏状态，所以会存在一个Activity是可见的，但是上面有一个小的Activity部分遮挡，这样一来，后面的Activity既不在栈顶（非运行态），又是可见的。这种状态就是暂停状态。一般系统也是不考虑去回收这种状态的Activity，只有在内存极低的时候才有可能被系统回收。\n##### 停止状态\n如果一个活动在栈中，并且完全不可见的时候，就处于停止状态，系统会保存Activity的状态和成员变量。这个时候它并不是完全可靠的，当内存不足的时候就可能被系统回收。\n##### 销毁状态\n如果一个Activity从返回栈中被移除掉的话，它就会成为销毁状态，系统最优先回收这种状态的Activity。\n\n#### 活动在三种生存期的七个回调方法\n\n##### 完整生存期\n从onCreate（）开始到onDestory（）结束\n###### onCreate（）\n每个Activity中都重写这个方法，它会在每个Activity创建的时候调用，所以这个方法中应该完成一些例如加载布局文件、绑定事件等初始化操作。\n###### onDestory（）\n这个方法在Activity被销毁之前调用，调用完成之后Activity就进入销毁状态\n\n##### 可见生存期\nActivity从onStart（）到onStop（）之间的部分就是可见生存期。可见生存期的可见二字就意味着Activity是显示的，就算不能交互，也要算在内。\n开发者就可以通过在onStart（）方法中加载资源，在onStop（）方法中释放资源，来保证停止状态的Activity不会占用过多的资源。\n###### onStart（）\n这个方法在Activity由不可见变成可见的时候调用\n###### onStop（）\n相反的，当Activity变得**完全**不可见的时候调用\n\n##### 前台生存期\n在onResume（）方法和onPause（）方法之间的Activity就是前台生存期。这时候Activity子那个是处于运行状态，可以与用户交互\n###### onResume（）\n这个方法是Activity已经准备好和用户交互的时候调用。这个时候的Activity在栈顶并且一定是运行状态。\n###### onPause（）\n这个方法是系统准备去启动某个Activity或者恢复到某个Activity的时候调用，这个方法中一般用于把一些消耗系统资源的释放掉，或者保存一些关键数据，但是这个方法里执行的不能是一些耗时操作。\n**如果是一个对话框出现在某个Activity上面的时候，如果没有完全遮挡，那么会调用onPause（）而不是onStop（）**\n\n除此之外，还有一个独立在这三种生存期之外的回调方法：\n###### onRestart（）\n这个方法是Activity在由停止状态重新变成运行状态的时候调用的。\n\n下面附一张Activity的生命周期图（书上原图）：\n![Activity的生命周期](https://s1.ax1x.com/2018/06/07/CH124K.jpg)\n\n下面做一个测试用于FirstActivity到SecondActivity然后再跳转回来的一个状态跟踪打印：\n```\n06-07 14:45:16.457 16551-16551/com.example.ifan.activitytest V/life: onCreate is called\n06-07 14:45:16.736 16551-16551/com.example.ifan.activitytest V/life: onStart is called\n06-07 14:45:16.742 16551-16551/com.example.ifan.activitytest V/life: onResume is called\n06-07 14:45:29.731 16551-16551/com.example.ifan.activitytest V/life: onPause is called\n06-07 14:45:30.536 16551-16551/com.example.ifan.activitytest V/life: onStop is called\n06-07 14:46:24.588 16551-16551/com.example.ifan.activitytest V/life: onRestart is called\n06-07 14:46:24.590 16551-16551/com.example.ifan.activitytest V/life: onStart is called\n06-07 14:46:24.591 16551-16551/com.example.ifan.activitytest V/life: onResume is called\n06-07 14:46:41.625 16551-16551/com.example.ifan.activitytest V/life: onPause is called\n06-07 14:46:42.003 16551-16551/com.example.ifan.activitytest V/life: onStop is called\n06-07 14:46:42.004 16551-16551/com.example.ifan.activitytest V/life: onDestory is called\n```\n可以看出来从FirstActivity到SecondActivity的时候，经过了onPause（）和onStop（）的方法的调用；从SecondActivity回到FirstActivity的时候，经过了onRestart（）、onStart（）和onResume（）的调用\n\n\n再做一个部分遮挡的例子：SecondActivity是一个对话框式的Activity时候，从FirstActivity到SecondActivity打印出来的是：\n```\n06-07 14:56:10.743 17244-17244/com.example.ifan.activitytest V/life: onCreate is called\n06-07 14:56:11.011 17244-17244/com.example.ifan.activitytest V/life: onStart is called\n06-07 14:56:11.019 17244-17244/com.example.ifan.activitytest V/life: onResume is called\n06-07 14:56:14.760 17244-17244/com.example.ifan.activitytest V/life: onPause is called\n06-07 14:56:24.734 17244-17244/com.example.ifan.activitytest V/life: onResume is called\n```\n可以看到这种情况少了onStop（）、onRestart（）和onStart（）的调用过程。\n\n另外还可以看到在按返回键的时候的调用过程如下：\n```\n06-07 15:22:38.832 18596-18596/com.example.ifan.activitytest V/life: onPause is called\n06-07 15:22:39.261 18596-18596/com.example.ifan.activitytest V/life: onStop is called\n06-07 15:22:39.262 18596-18596/com.example.ifan.activitytest V/life: onDestory is called\n```\n看到有博客说按home、返回、在后台杀进程的调用过程会有差异。\n另外在onStop（）的覆写中如果不写对父类方法的调用会导致Activity直接被回收，下一次还需要重新create。也很好理解，因为不调用父类方法的话其实就少了状态、变量的保存过程，所以会出现这样的结果。\n\n#### Activity在停止状态被回收的情况\nActivity在活动状态是可能被回收的，也就是可能存在以下场景：\nA跳转到B，然后A进入停止状态，但是A被销毁了，这时候从B回来就不会调用onRestart（）方法，而是调用onCreate（）方法。这时候因为A在onStop（）方法里写入的数据也随着之前停止状态的Activity被销毁了，所以这时候从B回去之后看到的A就是一个新创建的A了。\n怎么解决呢？\nActivity提供了一个onSaveInstanceState（）的回调方法，这个方法能够保证在Activity被Destory之前一定会被执行。所以我们可以在在这里保存A的Stop数据。\n\n这个onSaveInstanceState（）携带一个Bundle类型的参数，Bundle提供了一系列用于保存数据的方法。\n```\n@Override\nprotected void onSaveInstanceState(Bundle outState) {\n\toutState.putString(\"FirstActivityDataOut\",\"help~\");\n    super.onSaveInstanceState(outState);\n}\n```\n然后在onCreate（）方法中携带的Bundle类型的参数里获取这个Bundle中的数据就可以了。\n```\nif(savedInstanceState.getString(\"FirstActivityDataOut\")!=null)\n\tLog.v(\"FirstActivityDataOut\",savedInstanceState.getString(\"FirstActivityDataOut\"));\n```\n除此之外，在Intent的使用中也可以使用Bundle来传值。\n\n### Activity的四种启动模式\n四种启动模式是在AndroidManifest.xml里面的Activity对应的标签里面指定的。\n#### standard\n标准模式，也就是默认模式，在一个Activity建好的初始设置就是这个，每次启动一个新的Activity的时候，它就在返回栈中入栈，处于栈顶位置。这样的话，当此Activity递归地跳转到本类的Activity，栈中也会不停地新建、入栈。\n#### singleTop\n栈顶单例，顾名思义，处于栈顶的Activity在进行上面的操作的时候，会被直接使用本activity，而不是不断新建、入栈。但是前提条件必须是：** 当前的Activity必须处于栈顶。**\n\n**一个有意思的现象是使用startActivityForResult（）去启动这个singleTop的Activity的时候，是无视它的singleTop模式的，google这样设计的原因可能是考虑到回调的内容没有接受者**\n#### singleTask\n上一种的singleTop是只检查栈顶，避免了单个Activity的递归启动。除此之外还可以让某个Activity在整个返回栈中成为唯一的一个Activity。\n例如：\n\nA->B->C->D->E->B\n\n如果B的启动类型为singleTask，那么在从E到B的时候实际上是回到了最前面B，而且最前面的B之后的都会被从栈里弹出。\n\n#### singleInstance\n这个是不同于上面的三种的一种特殊的启动方式——这种启动模式的Activity会启用一个另外的返回栈去管理这个活动。应用场景就是当别的程序要共享访问这个Activity，其他的三种模式就不能完成了。（每个程序都有自己的返回栈，如果访问了这个Activity，那必定是在当前的程序和别的那个程序里面都会分别加入一个新建的这个Activity，那就是不同的实例了，达不到共享的目的。）\n\n而这个singleInstance就是解决这种情况的——**它会连同Activity一块返回一个单独的返回栈，然后任何一个应用来访问这个Activity，都公用同一个返回栈。**\n例如：\n\nA -> B -> C\n\n如果B的启动模式为singleInstance的话，实际的栈是这样的：\nA — C\nB\n第一个栈是本程序自己的栈，因为A、C都是普通的模式，所以都默认入栈到程序自己的默认栈里了。而第二个栈就是随着B一同创建的新栈，这个栈是所有程序调用时公用的。\n\n所以返回键连续按下之后，先是C所在的栈先出栈C，然后是A，因为是同一个栈，最后才是B，因为程序自己所在的栈已经空了，就轮到B所在的栈出栈了。\n\n### 一些实践\n了解了Activity的基础知识后，这里还有一些关于Activity的应用技巧。\n#### 获知当前所处Activity\n当拿到别人的代码时候，可能就不方便知道当前的界面是处于哪一个Activity了，一个个对应也很麻烦，所以有一个办法去获知当前所处的Activity：\n使用间接继承的原理，新建一个中间类BaseActivity继承自AppCompatActivity，在onCreate（）的方法中扩展一个打印当前类的语句：\n```\nLog.v(\"BaseActivity\",getClass().getSimpleName());\n```\n然后让所有的Activity都继承自这个BaseActivity，然后就可以显示出当前类的类名了。\n**但是同时也有一个让人没有办法接受的缺点：难道我拿到别人的代码要把所有的Activity的继承类都修改一遍么？！**\n\n#### 退回到任意Activity\n用一个List去手动维护一个返回栈，从而能够对这个返回栈的Activity手动操控，就可以返回到任意Activity：\n```\npublic static boolean backToIndexOfStack(int index){\n        if (index>=activityList.size()){\n            return false;\n        }\n        for (int i = activityList.size()-1;i > index;i--){\n            activityList.get(i).finish();\n            activityList.remove(activityList.size()-1);\n        }\n\treturn true;\n}\n```\nindex从0开始，这里依次从栈里finsh（）掉Activity，并且从手动维护的栈中remove掉。\n#### 启动Activity的最佳写法\n在多人协作开发的时候，协定传参总是一个要考虑的点。可以在启动Activity的时候封装一个activityStart（）方法，专门用来构建Intent，这样一来参数就在这个activityStart（）方法的参数列表里体现出来了。\n```\n\tpublic void activityStart(Context context,String firstName,String lastName){\n        Intent intent = new Intent(context,SecondActivity.class);\n        intent.putExtra(\"param1\",\"hello\");\n        intent.putExtra(\"param2\",\"there\");\n        startActivity(intent);\n    }\n```\n# Android UI的开发\n前面的一节是从探究Activity的角度去了解Activity的用法和特点。接下来就是学习如何编写UI，结合Activity去编写完整的UI已经交互逻辑。\n\n## 常用控件的使用\n### TextView\n这个控件类似于iOS里面的UILabel，用于展示文字信息。\n```\n    <TextView\n        android:id=\"@+id/text_view\"\n        android:text=\"This is a TextView\"\n        android:gravity=\"center\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\" />\n```\nandroid:layout_width、android:layout_height这两个属性是所有控件里面都有的，就像iOS里面的Frame一样用来设置大小，但是这个只是表示了大小并不明位置。\n后面的值可选三种值：\n* match_parent：表示让当前的控件和父布局的大小一样大。\n* fill_parent：和match_parent的意义一样，现在官方推荐使用match_parent。\n* wrap_content：表示让控件的大小刚好能包含控件中展示的内容，控件大小由控件内容决定。\n\n当然了，也可以手动指定固定值作为width、height的值，但是这样会导致适配出现问题。\n \n**gravity**：指定的是对齐方式，和iOS里TextAlignment类似。可选的有top、bottom、left、right、center。（center是默认指定\"center_vertical|center_horizontal\"的，表示垂直和水平方向都居中）\n\n**textSize**：指定文字大小。在Android里字体大小是使用sp作单位的。其实在打出24这个将要指定大小的数字的时候，自动补全了几个选项：dp、in、mm、pt、px、sp。好奇这几个有什么区别。之后我会另外开一个文去写这个的。\n**textColor**：#+6位16进制数表示颜色。\n\n更多的使用细节去查文档就好。\n\n### Button\n它在布局文件里的写法大同小异，它有一个textAllCaps属性，如果不设置为false的话默认为true就会把所有出现的字母都变为大写的。\n然后就可以在Activity的类里面去获取这个控件了：\n```\n\t\tButton button1 = (Button) findViewById(R.id.button_1);\n        button1.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                //点击之后的代码\n            }\n        });\n```\n这是一种类似闭包的方式，其实还有一种通过实现接口的方式，需要在本类的声明部分写明实现哪一个接口，然后在设置button的监听者为本类，然后覆写onClick（）方法，方法内部通过判断id来分别实现不同button的点击事件。\n\n### EditText\n这个控件实际上就是iOS里的TextView，支持多行输入和排版。\n特别的属性：\n\n**hint**：这一个是iOS里面的TextView里面没有的类似于placeHolder的设置。\n\n**maxLines**：EditText如果高度不是定值，就会随着输入内容的增多而拉长。如果指定了这个属性，则EditText不会被拉长，但是内容视图的长度还是会被拉长。而且，它只是限制了EditText这个控件的最大显示行数，并没有限制内容的行数。\n\n另外，还可以在Activity里面获取到EditText里面的文字信息：\n```\nEditText editText = findViewById(R.id.edit_text);\neditText.getText().toString()\n```\n### ImageView\n这个倒是和iOS里的UIImageView差别不大,不过现在资源大多都同意放在res目录下的drawable目录下，但是这个目录没有制定具体的分辨率，所以书上的建议是新建一个drawable-xhdpi文件夹，然后把图片放进去。\n\n对于图片的设置有两种方法，一种是直接写在布局文件里，一种是在Activity类里去修改。这两种可以同时使用。\n\n**有意思的是，Android的图片文件并不能带大写字母，不然会报错说只支持小写字母、数字和下划线。**\n\n同时对文件名里带“.”的文件也不能支持，会报错。\n\n\n**另外，在一开始设置的height为wrap_content其实也没有起作用。**\n### ProgressBar\n显示一个进度条（默认样式是一个不断循环转动的圈圈）。布局文件里写的是默认可见的（当然也可以手动指定为其他值），就可以在Activity里去判断它当前是否是可见的，如果是可见的，可以设为不可见。\n\n在布局文件里设置:\n```\n        android:visibility=\"invisible\"\n```\n在Activity里设置：\n```\n\t\tif (findViewById(R.id.progress_bar).getVisibility() ==View.VISIBLE){\n            findViewById(R.id.progress_bar).setVisibility(View.INVISIBLE);\n        }\n\n```\n对于ProgressBar来说有三种可见选项：visible、invisible、gone\n\n**visible**：可见的。\n\n**invisible**：不可见，但是还占据着原来的位置和大小，可以理解为透明状态。\n\n**gone**：不仅是不可见的，而且完全从屏幕上消失。\n\n除了上面的那种圈圈的样式，还有一种样式是条状的。可以通过在布局文件里设置style为：\n```\nstyle=\"?android:progressBarStyleHorizontal\"\n```\n对于这种样式，可以设置一个最大值，以便在Activity中动态的改变进度条的状态。\n\n布局文件：\n```\n\nandroid:max=\"100\"\n```\nActivity：\n```\nProgressBar progressBar = findViewById(R.id.progress_bar);\nprogressBar.setProgress(progressBar.getProgress()+10);\n```\n### AlertDialog\n弹出一个对话框，一般用于警告用户，下方有三个按钮可以响应用户的点击事件\n```\nAlertDialog.Builder dialog = new AlertDialog.Builder(FirstActivity.this);\ndialog.setTitle(\"this will change image\");\ndialog.setMessage(\"this is very importent\");\ndialog.setCancelable(true);\n\ndialog.setNeutralButton(\"NeutralButton\", new DialogInterface.OnClickListener() {\n    @Override\n    public void onClick(DialogInterface dialogInterface, int i) {}\n});\ndialog.setNegativeButton(\"Cancle\", new DialogInterface.OnClickListener() {\n    @Override\n    public void onClick(DialogInterface dialogInterface, int i) {}\n});\ndialog.setPositiveButton(\"OK\", new DialogInterface.OnClickListener() {\n\t@Override\n    public void onClick(DialogInterface dialogInterface, int i) {}\n});\n\ndialog.show();\n```\n可以在示例代码中看到，使用一般是三个步骤，先用Builder新建一个AlertDialog实例出来（指定Activity），然后设置标题、信息内容、可否在点击别的空白处取消这个AlertDialog。\n\n然后分别设置三个按钮（从左到右依次为NeutralButton、NegativeButton、PositiveButton）的点击回调事件。\n\n### ProgressDialog\n和上面的那个AlertDialog很类似，也可选两种样式——转圈圈或者一个条状的进度条。\n```\nProgressDialog progressDialog = new ProgressDialog(FirstActivity.this);\nprogressDialog.setTitle(\"progressDialog\");\nprogressDialog.setMessage(\"this is a progressDialog\");\nprogressDialog.setCancelable(true);\nprogressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\nprogressDialog.setMax(256);\nprogressDialog.show();\n```\n这种的是和前面的ProgressBar是一样的，可以设置最大的长度、动态改变进度状态。\n默认是转圈的样式。\n\n**需要注意的是，如果这个也设置为不允许失焦取消，那不知道何时会结束的progressDialog就会导致当前应用卡死，无法继续交互。如果设置为允许失焦消失，那就要处理好消失的逻辑，是否是用户选择取消当前进度？如果误操作怎么处理？如果是取消应该处理当前进度的任务？**\n\n## 四种基本布局\n布局是一种可用于放置很多控件的容器。布局是可以嵌套的。可以通过布局的嵌套来完成一些复杂的布局效果。这一部分将用一个新的项目去学习和练习。\n### 线性布局-LinearLayout\n是一种非常常用的布局，这种布局会将内部包含的控件在线性方向上依次排列。\n还记得最开始接触布局文件么？那个就是默认的线性布局（因为是根元素），有横向和竖向两种。\n\n可以通过orientation来指定线性到底是竖向还是横向。\n```\nandroid:orientation=\"horizontal\"\nandroid:orientation=\"vertical\"\n```\n**需要注意的是，这时候控件的size就要设置合理。比如水平线性布局的时候，控件的宽度就不能match_parent了**\n\nlayout的几个重要属性：\n#### layout_gravity\n和gravity属性有点相似，但是其实完全没有关系。\n\n**gravity**属性是指定某个控件内部的内容（如文字）在控件内是靠向哪一边的。\n\n**gravity_layout**是指定当前控件在父布局中的位置是在如何对齐的。\n同样的，在父布局已经处于某种方式的时候要做合理的设置，例如：父布局是水平布局（horizontal），只有设置控件在竖向位置的对齐（top、center、bottom等）才会生效。\n\n#### layout_weight\n这个属性是用比例的方式去指定控件的大小的，有一些自动布局的感觉。\n需要区别的是控件的width属性，虽然可能长的像，但是二者是完全不同的：\n\n**width**：用数值或者一些定义过的常量或者宏指定宽度。\n\n**weight**：用比例去指定当前控件在水平方向上占用多少比例。\n\n当weight存在的时候，width是不生效的，也就是随便写多少都没用，但是比较规范的写法是写为0dp。（dp是Android里用于指定控件大小、间距的单位）\n\n然后weight里写的是比例，如果控件1里面写的是1，另一个控件里写的2，那么就表示两个控件的宽度比例是1:2。\n\n有的控件里没有写weight，只写了width为wrap，这时候就还是保证控件的宽度刚够包含控件自己的内容。\n\n如果控件1写了weight的值为1，控件2没有写weight但是写了width为wrap，那就是控件1尽量宽，然后控件2的宽度刚够包含自己的内容。\n\n### 相对布局：RelativeLayout\n这种布局也是非常常用的布局，这种布局更随意一些，它可以用相对定位的方式让控件出现在布局的任意位置。\n\n正因如此，相对布局的属性就多了一些，但是好在都是有规律的。\n```\n\t<Button\n        android:text=\"hello3\"\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"wrap_content\"\n        android:layout_alignParentEnd=\"true\"\n        android:layout_alignParentTop=\"true\"\n        />\n```\n可以看到，里面的位置相关的代码里面有Parent字段，也就是说，这些控件是相对于父布局来定位的。当然了也可以不依据父布局进行定位：\n```\n\t<Button\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"wrap_content\"\n        android:layout_above=\"@+id/text_view\"\n        android:layout_toLeftOf=\"@+id/text_view\"\n        android:text=\"hello1\"\n        />\n```\n可以通过id去选定相对的参考控件，去选择相对位置。\n**但是只能去参考前面出现过的控件，不然就找不到id了。**\n\n另外还有layout_alignLeft表示和目标控件左对齐，其他的其他方向都是一样的。\n\n### 帧布局 FrameLayout\n这种布局非常简单，相比前面的两种来说，使用场景也较少。\n\n这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角。多个控件按照默认方式放置会重叠在一起。\n\n当然，也可以用layout_gravity属性去指定控件的对齐方式，但是比起前面的几种来说还是太简单了，导致实际的应用场景也不是那么多。\n### 百分比布局\n安卓引用了一种全新的布局方式来解决线性布局不够强大的比例式布局的缺点，这种布局中，可以不再用wrap_content、match_parent等方式去指定控件的大小，而是直接指定控件在布局中所占的百分比，这样就可以轻松实现任意比例分割布局了。\n\n百分比布局对FrameLayout和RelativeLayout进行了功能扩展，提供了PercentFrameLayout和PercentRelativeLayout的全新布局。\n\n为了让这种布局方式能够兼容就的安卓版本上使用，这种布局定义在support库中，只需要在项目的build.gradle中添加百分比布局的依赖保证兼容性。\n```\n<android.support.percent.PercentFrameLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n\n    <TextView\n        android:id=\"@+id/text_view\"\n        android:layout_gravity=\"start\"\n        app:layout_widthPercent=\"50%\"\n        app:layout_heightPercent=\"50%\"\n        android:text=\"hello~\"\n        />\n    \n\n</android.support.percent.PercentFrameLayout>\n```\n这里的app并没有补全，想来应该是因为这个并不在内置在系统的SDK中的，所以没有自动补全。\n\n**这种布局有一个大坑：写50%的时候总是先写50再写%，写这里的时候我写了50然后手抖后面多跟了个0，成了500，然后就直接卡死，告诉我Out of Memory。其实也很好解释，因为AndroidStudio是可以自动预览布局的，所以这里还来不及修改的时候，已经自动按照500去算百分比了，1是100%，那么500就是50000%，所以就内存不够了。**\n\n对于另一种PercentRelativeLayout，它继承了RelativeLayout的所有属性并且加入了app:layout_widthPercent和app:layout_heightPercent来指定控件的宽高。\n\n### 约束布局——ConstraintLayout\n因为书上的几种布局方式比较老，其实在现在的AndroidStudio里面新建一个project的时候，已经默认设置为这种约束布局了，所以换句话说，这个应该重点学习，它被默认支持一定是有它的优点的。\n\n之前一直是用代码去编写布局，是因为前面的几种布局对于用代码的表达更好一些。但是归根结底来说，布局这种的用可视化去编辑是最直观最合适的，所以这个就是为了解决这种问题的一种新的布局方式。（这个书的作者也说了，当时在写书的时候这个布局方式刚出来，就没有加入到书里。）\n\n这种布局方式是使用控件的相对位置去布局的，有点类似相对布局，但是比相对布局还要强大。\n\n这种布局同时还解决了传统的几种布局的嵌套问题。传统布局要实现复杂的布局往往需要多重嵌套，但是多重嵌套会降低性能，所以这种布局应对复杂布局的时候可能会更好。\n\n这种布局暂时看到的教程都说适合用Design界面去拖拽完成布局操作，所以这里就先不写了。\n\n## 自定义控件\n和iOS一样，Android里的控件也都是直接或者间接的继承自View，所有的布局都是直接或间接继承自ViewGroup。View是Android里的最基本的UI组件。ViewGroup是一种特殊的View，可以包含很多子View和ViewGroup，是用于防止控件和布局的容器。\n\n需要接触几个前面没有接触到的属性：\n\n**background**：为布局或者控件指定一个背景，可以使颜色或者图片。\n\n**margin**：指定控件在四个方向的偏移量，也可以用margin_left等指定单一某个方向上的偏移量。\n\n先写好某一个自定义布局，然后在另一个布局里面引用这个布局就可以了。\n\ntitle.xml：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:layout_margin=\"5dp\"\n        android:text=\"Back\"\n        />\n    <TextView\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:layout_weight=\"1\"\n        android:gravity=\"center\"\n        android:text=\"title\"\n        android:textSize=\"24sp\"\n        />\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:layout_margin=\"5dp\"\n        android:text=\"edit\"\n        />\n\n</LinearLayout>\n```\n\nactivity_miain.xml：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <include layout=\"@layout/title\"/>\n\n</LinearLayout>\n```\n\n这个的实现效果就是自定义了个ActionBar并且加载到主布局中。\n\n## 最常用、最难用的控件——ListView\n这里的ListView就类似于iOS里面的UITableView，重要性不用多说。\n\n先从最简单的用法开始：\n### ListView的简单用法\n先在布局里面写一个ListView进去，这里先写好大小和id就可以。\n\n然后在Activity里面写一个和这个listView相关的实例，把它的适配器指定为某个适配器的实例就好了：\n```\nListView listView = findViewById(R.id.list_view);\nArrayAdapter<String> adapter = new ArrayAdapter<String>(\n\tMainActivity.this,\n    android.R.layout.simple_list_item_1,\n    data\n    );\nlistView.setAdapter(adapter);\n```\n这个适配器只是众多适配器中的一种，这个据说是最好用的，可以通过泛型来指定钥匙胚的数据类型，然后在构造函数里传参进去。\n\nArrayAdapter有很多重载，这里是因为用到的数据都是String类型，所以这里写 了String。然后依次传入当前的上下文、listView的id，以及具体的数据数组。\n\n这里的android.R.layout.simple_list_item_1相当于是iOS里面UITableView的style，可以有很多种style，根据具体的使用场景自行切换。\n\n### 自定义ListView的界面\n自定义的过程和iOS的自定义cell的基本上相似，都是新建一个布局，然后让ListView去加载这个布局作为item，然后把构造好的数据展示到界面上就好了。\n\n* 先新建一个布局：\n```\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n    <ImageView\n        android:id=\"@+id/fruit_image\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"@drawable/ic_launcher_background\"/>\n\n    <TextView\n        android:id=\"@+id/fruit_textview\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center_vertical\"\n        android:layout_margin=\"10dp\"/>\n</LinearLayout>\n```\n这个就是cell（也就是item）的展示布局。\n\n* 新建一个容器类\n这个容器类就是作为ListView的适配器类型：\n```\npublic class Fruit {\n    private String name;\n    private int imageId;\n\n    public Fruit(String name,int imageId){\n        this.name = name;\n        this.imageId = imageId;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getImageId() {\n        return imageId;\n    }\n}\n```\n这个部分就相当于model类的部分，用来存储ListView将来要展示的数据。\n\n* 新建一个适配器类\n```\npublic class FruitAdapter extends ArrayAdapter<Fruit> {\n    private int resourceId;\n    public FruitAdapter(Context context, int textViewResourceId, List<Fruit>object){\n        super(context,textViewResourceId,object);\n        resourceId = textViewResourceId;\n    }\n\n    @NonNull\n    @Override\n    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {\n        Fruit fruit = getItem(position);\n        View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);\n        ImageView fruitImage = (ImageView)view.findViewById(R.id.fruit_image);\n        TextView fruitName=(TextView)view.findViewById(R.id.fruit_textview);\n        fruitImage.setImageResource(fruit.getImageId());\n        fruitName.setText(fruit.getName());\n        return view;\n    }\n}\n```\n可以看到这个适配器类是继承自ArrayAdapter的，声明了一个私有属性resourceId，然后在这个类的构造函数里传入三个参数：上下文、textViewResourceId、和一个model类的List对象。调用父类的方法，对私有属性赋值。\n\n然后需要重写一个父类的方法getView（），这个方法就相当于iOS里面的cellForRowAtIndex，在每次item要出现在屏幕上的时候就会调用。\n\n\n这个getView传入了三个参数：position相当于是index，因为前面在构造函数里面已经设置过了List对象，所以这个方法是把数组中当前要处理的cell的对应元素取出来。\n\n然后要新建一个View对象，这个view是：先获取到Activity的布局渲染器，然后对这个布局渲染器LayoutInflater调用inflate方法。inflate方法需要传三个参数：resourceId（具体的item的那个布局的xml文件）、parent（父布局，和缓存有关）、false（表示这个resourceId所引用的布局是不带父布局的，因为如果带了父布局，就不能添加到目标要添加的父布局了）。\n\n然后从这个view中通过findViewById的方法去找到具体的控件，接着分别从对应顺序的model的元素（第一行的getItem方法已经取出来了的那个）里面取出需要显示在item上面的值，赋值给对应的控件，然后返回这个view作为ListView的item。\n\n* 在Activity中：\n\n```\nprivate List<Fruit> fruits = new ArrayList<>();\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n\tsuper.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    ListView listView = findViewById(R.id.list_view);\n\n    initFruit();\n    FruitAdapter adapter = new FruitAdapter(MainActivity.this,R.layout.fruit_item,fruits);\n\n    listView.setAdapter(adapter);\n}\n\nprivate void initFruit(){\n\tfor (int i =0;i<100;i++){\n    \tFruit fruit = new Fruit(\"apple\"+i,R.drawable.ic_launcher_background);\n        fruits.add(fruit);\n    }\n}\n```\n\n前面的其实都是准备的工作，要生效还是在Activity里面建立数据数组，然后对数据数组进行初始化，然后新建一个自定义的适配器，最后把listview的适配器设置为刚才建立好的自定义适配器实例。\n\n要实现更复杂的item，只要修改model和item的布局文件就可以了。\n\n### 提升ListView的效率\n\nListView之所以难用就是因为它的使用初看比较简单，但是实际上有很多可以优化的点，比如提升效率。\n\n前面写的代码的运行效率就很低，因为在适配器的代码中，每次item出现的时候，都会调用的getView方法中都会加载一遍布局。当ListView快速滑动的时候，就会带来不小的负担。\n\n其实前面没有注意到的是，getView还有一个参数：convertView。\n\n这个参数是将之前加载好的布局缓存起来，以便之后再次使用。\n\n所以其实可以这样用：\n```\nView view;\nif (convertView == null)\n\tLayoutInflater.from(getContext()).inflate(resourceId,parent,false);\nelse\n    view = convertView;\n```\n这样一来，就不会每次都不分青红皂白地去加载布局了，而是先判断缓存的布局是不是为空，如果为空，再去加载布局，如果不为空，就直接变动要显示的数据就好了。\n\n**纵使这样，代码的性能还能继续优化：**\n虽然已经可以不用重复地去加载布局了，但是对于getView方法，还是需要每次从view里面通过findViewById去找到具体的控件。所以这里就可通过新建一个ViewHolder类去缓存每个控件了：\n```\n@NonNull\n@Override\npublic View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {\n\tFruit fruit = getItem(position);\n\n    ViewHolder viewHolder;\n    View view;\n    if (convertView == null){\n    \tview = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);\n    \tviewHolder = new ViewHolder();\n        viewHolder.fruitImage = (ImageView)view.findViewById(R.id.fruit_image);\n        viewHolder.fruitName = (TextView)view.findViewById(R.id.fruit_textview);\n        view.setTag(viewHolder);\n    }\n    else{\n    \tview = convertView;\n        viewHolder = (ViewHolder)view.getTag();\n    }\n\n    assert fruit != null;\n    viewHolder.fruitImage.setImageResource(fruit.getImageId());\n    viewHolder.fruitName.setText(fruit.getName());\n    return view;\n}\n\npublic class ViewHolder{\n\tImageView fruitImage;\n    TextView fruitName;\n}\n```\n可以看到这里的ViewHolder类也很简单，和Fruit类一一对应，只不过Fruit里面是数据，这个里面是需要改变数据的item的控件。\n\n在原来优化的基础上，对于新加载布局的情况：把从view里面寻找对应的控件，然后存到viewHolder里面，最后把viewHolder实例设置为view的tag；\n\n对于不用重新加载布局的view：直接通过getTag方法获取viewHolder，然后取出viewHolder里面的控件进行操作。\n\n### ListView的点击事件\n也很好理解，就和iOS里面的cell监听方法一样的。\n\n对于Android的ListView，就是实现ListView的setOnItemClickListener方法参数中的闭包。\n\n前面的优化都是在自定义适配器里写的，这里就要回到Activity里面了：\n```\nlistView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n\t@Override\n    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n    \tFruit fruit = fruits.get(position);\n        Toast.makeText(MainActivity.this,\"this is \"+fruit.getName(),Toast.LENGTH_SHORT).show();\n    }\n});\n```\n这个方法是在参数中传入了一个闭包，覆写了onItemClick的方法，传入了三个参数：一个适配器类型的变量、一个当前的item的view，一个当前的index，一个id。\n\n然后如果要让点击之后发生点什么，就在这个onItemClick方法里写就好。\n## RecyclerView\n终于过了那个ListView大户，然后又来了一个传说中更强大的控件——RecycleView。\n\nListView其实有着很多不够强大的地方——一是需要用一些技巧去优化它的性能，二是它只能实现竖向的滚动，不能实现横向的滑动。\n\n所以，Android就提供了一个更强大的控件，这个可以看做一个增强版的ListView，可以轻松实现ListView的效果，还优化了ListView里面的各种不足之处。目前就连Android官方都更加推荐RecycleView。\n\n因为这个也是官方SDK里没有默认提供的控件，所以需要在app/build.gradle里面写明依赖库。\n\n然后就是在布局文件里面写这个控件了。","slug":"Android从0开始的菜鸡学习之路","published":1,"updated":"2018-06-13T06:34:33.022Z","_id":"cji2hzkap0000pvi1f3mr39ye","comments":1,"layout":"post","photos":[],"link":"","content":"<p>开头先说几句：</p>\n<ul>\n<li>我很久没有更新这个博客了，好不容易搭建的差不多，还没有来的及修改一些细节部分，不过还好，不影响使用，之后有空了再改吧。后面会把一些学习的历程、学习笔记或者一些乱七八糟的感想什么的等等东西更新上来，应该也没有什么人来看吧~</li>\n<li>这个Android的学习历程其实并不是我学客户端开发的开头——虽然博客里之前也并没有写关于其他的学习历程。。。我其实之前学的是iOS开发，OC写了挺久，最近也在接触Swift，本来是做好了做一个正经的iOS开发实习生（虽然我从来没有过iPhone），但是呢，今天实习公司的导师加了微信，我才得知我去了之后是要做Android的。一开始有点懵，我没写过这个东西呀，Java也掌握的很一般很一般，这意味着我有很多东西需要学习。那，如果我实习留不下呢？我写了一个月的Android然后回来匆匆忙忙复习iOS再投秋招的iOS岗位么？有点纠结，也很难抉择。</li>\n<li>后来一想，反正实习还是要去的，那我现在开始了解一些开发Android相关的东西，去了以后能调岗位就最好，不能调的话就尽量争取留下来吧。也问了一些学长的看法作为参考。这不过就是一次挑战而已，总不可能事事如意，这个就当是一个学习能力的挑战吧，能不能在固定的一段时间里学到尽量多的东西。反正iOS的学习基本上也到了瓶颈期，不如，换换口味？</li>\n<li>再者说，我也算个安卓机的爱好者吧，因为穷我用的从来都是安卓机，也很早开始折腾安卓系统，root、刷系统、玩xposed……算是从安卓2.x一直到8.1的体验者了。</li>\n<li>塞翁失马，焉知非福</li>\n<li>那就这么开始学习安卓吧</li>\n</ul>\n<h1 id=\"开始前的准备\"><a href=\"#开始前的准备\" class=\"headerlink\" title=\"开始前的准备\"></a>开始前的准备</h1><h2 id=\"教材\"><a href=\"#教材\" class=\"headerlink\" title=\"教材\"></a>教材</h2><p>我用的是学长推荐的《第一行代码Android》</p>\n<h2 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h2><p>用了很久的黑苹果10.12.6，AS最新版，不想用模拟器，就用了我刷了8.1的一加2</p>\n<h1 id=\"HelloWorld\"><a href=\"#HelloWorld\" class=\"headerlink\" title=\"HelloWorld\"></a>HelloWorld</h1><p>新建了一个只有一个Activity的项目，它自己就写了“hello，world” 所以其实不算是我自己写的。<br>但是比起新建一个EmptyActivity什么都没有一脸懵逼来说好很多了</p>\n<h2 id=\"项目文件夹结构\"><a href=\"#项目文件夹结构\" class=\"headerlink\" title=\"项目文件夹结构\"></a>项目文件夹结构</h2><h3 id=\"gradle-和-idea\"><a href=\"#gradle-和-idea\" class=\"headerlink\" title=\".gradle 和 .idea\"></a>.gradle 和 .idea</h3><p>自动生成的文件，不用管</p>\n<h3 id=\"app\"><a href=\"#app\" class=\"headerlink\" title=\"app\"></a>app</h3><p>主要文件都在这里</p>\n<h4 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a>build</h4><p>也是编译生成的文件，更多更杂，不用管</p>\n<h4 id=\"libs\"><a href=\"#libs\" class=\"headerlink\" title=\"libs\"></a>libs</h4><p>第三方包的文件夹，会自动加到构建的路径里</p>\n<h4 id=\"src\"><a href=\"#src\" class=\"headerlink\" title=\"src\"></a>src</h4><p>这个文件里的东西是编写的时候需要关注的文件夹，需要自己写的内容基本上都在这里面</p>\n<h5 id=\"androidTest\"><a href=\"#androidTest\" class=\"headerlink\" title=\"androidTest\"></a>androidTest</h5><p>可以在这里写测试用例，可以自动化测试</p>\n<h5 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h5><p>基本上java文件就都在这里了</p>\n<h6 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h6><p>java文件就在这个文件夹下，比如刚才创建的Activity.java</p>\n<h6 id=\"res\"><a href=\"#res\" class=\"headerlink\" title=\"res\"></a>res</h6><p>项目里要用到的所有图片（drawable）、布局（layout）、字符串（values）等</p>\n<h6 id=\"AndroidManifest-xml\"><a href=\"#AndroidManifest-xml\" class=\"headerlink\" title=\"AndroidManifest.xml\"></a>AndroidManifest.xml</h6><p>这个是整个项目的配置文件，在程序里定义的所有的四大组件都需要在这里注册，另外还可以写权限声明，这个要经常用到</p>\n<h5 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h5><p>又是一个测试，先不管</p>\n<h5 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\".gitignore\"></a>.gitignore</h5><p>git忽略的文件</p>\n<h5 id=\"app-imi\"><a href=\"#app-imi\" class=\"headerlink\" title=\"app.imi\"></a>app.imi</h5><p>不用管</p>\n<h5 id=\"build-gradle\"><a href=\"#build-gradle\" class=\"headerlink\" title=\"build.gradle\"></a>build.gradle</h5><p>app这个模块的构建脚本</p>\n<h5 id=\"proguard-rules-pro\"><a href=\"#proguard-rules-pro\" class=\"headerlink\" title=\"proguard-rules.pro\"></a>proguard-rules.pro</h5><p>用于指定混淆规则，厉害了，用于防止代码被破解</p>\n<h3 id=\"build-1\"><a href=\"#build-1\" class=\"headerlink\" title=\"build\"></a>build</h3><p>编译时自动生成的文件，不用管</p>\n<h3 id=\"gradle\"><a href=\"#gradle\" class=\"headerlink\" title=\"gradle\"></a>gradle</h3><p>包含了gradle wrapper的配置文件，默认不启用这个方式</p>\n<h3 id=\"gitignore-1\"><a href=\"#gitignore-1\" class=\"headerlink\" title=\"gitignore\"></a>gitignore</h3><p>git的忽略文件</p>\n<h3 id=\"build-gradle-1\"><a href=\"#build-gradle-1\" class=\"headerlink\" title=\"build.gradle\"></a>build.gradle</h3><p>全局gradle构建脚本，gradle是一个自动化构建脚本，一般不用改</p>\n<h3 id=\"gradle-properties\"><a href=\"#gradle-properties\" class=\"headerlink\" title=\"gradle.properties\"></a>gradle.properties</h3><p>全局gradle配置文件，会影响整个项目的编译</p>\n<h3 id=\"gradlew和gradlew-bat\"><a href=\"#gradlew和gradlew-bat\" class=\"headerlink\" title=\"gradlew和gradlew.bat\"></a>gradlew和gradlew.bat</h3><p>是用来执行gradle的，不用管</p>\n<h3 id=\"XXX-imi\"><a href=\"#XXX-imi\" class=\"headerlink\" title=\"XXX.imi\"></a>XXX.imi</h3><p>是这个IDE的存在感的标识，不用管</p>\n<h3 id=\"local-properties\"><a href=\"#local-properties\" class=\"headerlink\" title=\"local.properties\"></a>local.properties</h3><p>指定本机的Android SDK的路径，是自动生成的一般不用改</p>\n<h3 id=\"setting-gradle\"><a href=\"#setting-gradle\" class=\"headerlink\" title=\"setting.gradle\"></a>setting.gradle</h3><p>用来指定项目中所有引入的模块，目前为止一共就用了app这么一个模块，所以现在还就只写了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &apos;:app&apos;</span><br></pre></td></tr></table></figure></p>\n<p><strong> 好了，关于文件目录就是这些，总结起来就是外层的文件夹什么的基本上先不用管，要注意的就是app这个文件夹里的 </strong></p>\n<h2 id=\"如何运行起来的\"><a href=\"#如何运行起来的\" class=\"headerlink\" title=\"如何运行起来的\"></a>如何运行起来的</h2><p>先看Android-Manifest.xml里做了什么</p>\n<h3 id=\"Android-Manifest-xml\"><a href=\"#Android-Manifest-xml\" class=\"headerlink\" title=\"Android-Manifest.xml\"></a>Android-Manifest.xml</h3><p>里面有一部分代码长这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=&quot;.MainActivity&quot;&gt;</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">    \t&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class=\"line\">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p>\n<p>指定了点击应用之后首先启动哪个Activity，这里当然是MainActivity这个类<br>那MainActivity这个类里面做了什么操作呢？</p>\n<h3 id=\"MainActivity-java\"><a href=\"#MainActivity-java\" class=\"headerlink\" title=\"MainActivity.java\"></a>MainActivity.java</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends AppCompatActivity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个类是一个继承自AppCompatActivity的类，这个类类似于iOS里的ViewController<br>这个类的onCreate方法是一个Activity被创建的时候一定会执行的方法（类似于iOS里的ViewDidLoad）<br>这里并没有看到“hello world”的字样。<br>Android编程讲究逻辑和视图分离，所以setContentView这个方法引入了一个布局文件（res/layout）</p>\n<h3 id=\"activity-main-xml\"><a href=\"#activity-main-xml\" class=\"headerlink\" title=\"activity_main.xml\"></a>activity_main.xml</h3><p>这个文件里面有一部分是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:text=&quot;Hello World!&quot;</span><br><span class=\"line\">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class=\"line\">        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class=\"line\">        app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class=\"line\">        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>表示布局里添加了一个TextView的控件，设置了ndroid:text=”Hello World!”所以会显示出Hello World。这个控件类似于iOS里的UILable</p>\n<p><strong> 这样就大致搞清楚了HelloWorld是怎么运行起来的，并且各种文件是怎么组织起来的。其实和iOS类似的地方很多，AndroidManifest.xml有些类似APPDelegate，Activity类似于ViewController，activity_main.xml类似于xib，但是之前都是直接用代码写的布局类，所以这种的还需要适应一下 </strong></p>\n<p><strong> 大致过程大概就是，先在AndroidManifest.xml配置Activity，然后在布局文件里面写界面相关的代码，然后在Activity.java里面写对布局里面的控件的操控，也是类似MVC的经典的逻辑分离的设计方法。 </strong></p>\n<h1 id=\"从0开始自己构建一个APP\"><a href=\"#从0开始自己构建一个APP\" class=\"headerlink\" title=\"从0开始自己构建一个APP\"></a>从0开始自己构建一个APP</h1><p>前面的HelloWorld是人机自动生成的，这一次开始自己从0开始写一个，选择Empty，这时候没有Acitvity，所以不会有显示的。</p>\n<h2 id=\"新建一个Activity\"><a href=\"#新建一个Activity\" class=\"headerlink\" title=\"新建一个Activity\"></a>新建一个Activity</h2><p>在app/src/main/java/com.example.ifan.activitytest右键从new里面选择一个EmptyActivity。这里新建的Activity是会自动在AndroidManifest.xml里面自动添加注册的代码的，但是不会自动设置为最先启动后展示的第一个页面，所以还需要在activity的标签里手动添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;intent-filter&gt;</span><br><span class=\"line\">\t&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class=\"line\">    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class=\"line\">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这样，新添加的acticity就是启动页了。</p>\n<h2 id=\"新建页面布局文件\"><a href=\"#新建页面布局文件\" class=\"headerlink\" title=\"新建页面布局文件\"></a>新建页面布局文件</h2><p>虽然已经有了一个空的Activity，但是还没有东西可以显示。<br>在res文件夹立新建一个layout文件夹，用来存放布局文件，然后新建一个Layout resources file，是一个xml格式的文件，在这里写布局：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button</span><br><span class=\"line\">        android:id=&quot;@+id/button_1&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:text=&quot;Button 1&quot;</span><br><span class=\"line\">        /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>添加了一个button，然后在标签里写的id是这个空间的唯一标示，layout_width和layout_height是控件的大小（match_parent是屏幕宽度，wrap_content是刚好能容纳控件内容的高度），text就是button上面显示的文字</p>\n<h2 id=\"在Activity里操作布局里面的控件\"><a href=\"#在Activity里操作布局里面的控件\" class=\"headerlink\" title=\"在Activity里操作布局里面的控件\"></a>在Activity里操作布局里面的控件</h2><p>刚才已经建好了一个button，我们可以在Activity里面操作这个控件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContentView(R.layout.first_layout);</span><br><span class=\"line\">Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class=\"line\">button1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">    public void onClick(View view) &#123;</span><br><span class=\"line\">    Toast.makeText(FirstActivity.this,&quot;You Clicked Me!&quot;,Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>第一行的setContentView是把布局文件添加到当前Activity里面，R.layout.xxx是在引用res里面的layout文件夹里面的资源文件。</li>\n<li>第二行从布局文件里面获取一个View，然后显式转换为button类型赋值给一个button类的实例变量。</li>\n<li>第三行setOnClickListener是对button实例变量调用的方法（监听器），传入的一个参数为新建的View.onClickListener，然后对这个setOnClickListener方法进行覆写。</li>\n<li>后面的onClick是button监听器里的默认会执行的单击方法，所以在这个方法里写Toast</li>\n<li>Toast.makeText（）是一个静态方法，传入（上下文，文本内容，显示时长），然后调用show（）方法显示出来</li>\n</ul>\n<h3 id=\"Activity的基本使用\"><a href=\"#Activity的基本使用\" class=\"headerlink\" title=\"Activity的基本使用\"></a>Activity的基本使用</h3><p>刚才已经使用了Toast，还有一个常用的控件Menu</p>\n<h4 id=\"Menu\"><a href=\"#Menu\" class=\"headerlink\" title=\"Menu\"></a>Menu</h4><ul>\n<li>首先在res文件夹下新建文件夹menu文件夹，再在menu文件夹下新建Menu resource file</li>\n<li>在这个文件里添加：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;item</span><br><span class=\"line\">      android:id=&quot;@+id/add_item&quot;</span><br><span class=\"line\">      android:title=&quot;Add&quot;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">  &lt;item</span><br><span class=\"line\">      android:id=&quot;@+id/remove_item&quot;</span><br><span class=\"line\">      android:title=&quot;Remove&quot;</span><br><span class=\"line\">      /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在Menu的布局里添加了两个item，分别设置它们的id和title</p>\n<ul>\n<li><p>回到Activity.java的文件里，重写onCreateOptionsMenu（）方法，先getMenuInflater（）获取到一个菜单展开器，然后调用inflate把资源文件里的menu展开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">   public boolean onCreateOptionsMenu(Menu menu) &#123;</span><br><span class=\"line\">       getMenuInflater().inflate(R.menu.main,menu);</span><br><span class=\"line\">       return true;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回值表示是否允许创建的菜单显示出来<br>上面的代码能够将menu显示出来，如何响应按钮的item?</p>\n</li>\n<li><p>覆写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onOptionsItemSelected(MenuItem item) &#123;</span><br><span class=\"line\">    switch (item.getItemId())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        case R.id.add_item:</span><br><span class=\"line\">        \tToast.makeText(FirstActivity.this,&quot;You clicked item named add&quot;,Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case R.id.remove_item:</span><br><span class=\"line\">            Toast.makeText(FirstActivity.this,&quot;You clicked item named remove&quot;,Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>通过switch判断不同的item的id去做不同的动作响应</p>\n<h4 id=\"Intent\"><a href=\"#Intent\" class=\"headerlink\" title=\"Intent\"></a>Intent</h4><p>Intent不仅是各组件中交互的重要方式，可以指明当前组件想要执行的动作，还可以在组件之间传递数据。<br><strong> Intent 一般可以用于启动活动、启动服务、发送广播等场景 </strong></p>\n<h5 id=\"显式Intent\"><a href=\"#显式Intent\" class=\"headerlink\" title=\"显式Intent\"></a>显式Intent</h5><ul>\n<li>在某一个触发事件里可以创建一个Intent的实例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = new Intent(FirstActivity.this , SecondActivity.class);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>第一个参数提供启动活动的上下文，第二个参数是目标活动</p>\n<ul>\n<li>Activity类提供了一个方法，专门用于启动活动，接受一个intent参数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startActivity(intent);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>至于如何返回（即销毁当前的Activity），可以手动绑定方法去执行finish（），也可以是手机上的返回键</p>\n<h5 id=\"隐式Intent\"><a href=\"#隐式Intent\" class=\"headerlink\" title=\"隐式Intent\"></a>隐式Intent</h5><p>隐式的用法是通过AndroidManifest.xml中的Activity的配置相关信息，然后在Activity.java中调用符合配置的Activity，而不是直接指定某个Activity的类。<br>下面举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=&quot;.SecondActivity&quot;&gt;</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">    \t&lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot;/&gt;</span><br><span class=\"line\">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后在FirstAcitvity.java里面写的和显式的不同：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent1 = new Intent(&quot;com.example.activitytest.ACTION_START&quot;);</span><br><span class=\"line\">startActivity(intent1);</span><br></pre></td></tr></table></figure></p>\n<p>直接写为Activity支持的action名。<br><strong> 另外，每个intent只可以对应一个action，但是可以对应多个category，只有当category和action同时满足范围的时候才可以正常调用，否则会崩溃并抛出异常 </strong></p>\n<p>其实还有别的隐式intent的用法，比如跨应用唤起某个页面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent1 = new Intent(Intent.ACTION_VIEW);</span><br><span class=\"line\">intent1.setData(Uri.parse(&quot;http://google.com&quot;));</span><br><span class=\"line\">startActivity(intent1);</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以唤起浏览器并打开<a href=\"http://google.com\" target=\"_blank\" rel=\"noopener\">http://google.com</a><br>ACTION_VIEW是安卓系统内置的动作，然后Uri.parse（）是将字符串解析为Uri对象，最后用setDdata（）把Uri对象传入。</p>\n<p>除此之外，还可以在<intent-filter>中配置 data 标签，实现更精确地响应：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=&quot;.SecondActivity&quot;&gt;</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class=\"line\">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class=\"line\">        &lt;data android:scheme=&quot;&quot;/&gt;</span><br><span class=\"line\">        &lt;data android:host=&quot;&quot;/&gt;</span><br><span class=\"line\">        &lt;data android:port=&quot;&quot;/&gt;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></intent-filter></p>\n<p>这里的action的值配置为；鹅Intent.ACTION_VIEW的常量值，同时data字段也配置了可以响应的协议类型等字段，假如我们设置的scheme字段是http，那么用户在打开一个http网页的时候，会提示用户选择我们的这个Activity打开。</p>\n<p>安卓系统内部其实有很多中intent.ACTION的类型，有唤起地理位置界面的、拨号的等等。</p>\n<h4 id=\"页面间传值\"><a href=\"#页面间传值\" class=\"headerlink\" title=\"页面间传值\"></a>页面间传值</h4><p>Intent不仅可以用来启动Activity，还可以在页面跳转同时传值</p>\n<p>Intent提供了一系列对putExtra（）的重载，可以在调度Activity的同时把数据暂存在Intent中，到达了另外一个Activity的时候，再由目的Activity把数据从Intent中取出就可以了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intent2.putExtra(&quot;string_from_firstActivity&quot;, &quot;hello second&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>上面的这是设值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = getIntent();</span><br><span class=\"line\">Log.v(&quot;SecondActivty&quot;,intent.getStringExtra(&quot;string_from_firstActivity&quot;));</span><br></pre></td></tr></table></figure></p>\n<p>这是取值</p>\n<p>这种适合用来做单向正向传值。除了这种之外还有反向传值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startActivityForResult(intent2,1);</span><br></pre></td></tr></table></figure></p>\n<p>这个方法能够期望SecondActivity销毁时能够返回结果给FirstActivity。<br>然后需要在FirstActivity中覆写onActivityResult方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class=\"line\">    switch (requestCode)&#123;</span><br><span class=\"line\">        case 1:</span><br><span class=\"line\">            if (resultCode==RESULT_OK)&#123;</span><br><span class=\"line\">                Log.v(&quot;FirstActivity&quot;,data.getStringExtra(&quot;back_to_first&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过对Intent data调用getStringExtra方法得到返回回来的数据。、<br>requestCode是前面写的数字。用来标示从FirstACtivity跳转到的不同Activity<br>resultCode是SecondActivity返回数据时传入的参数。用来标示是否处理成功。<br>data就是携带的数据。</p>\n<p>对于SecondActivity来说，只要设值，然后调用setResult（）就可以了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intent.putExtra(&quot;back_to_first&quot;,&quot;hello,first&quot;);</span><br><span class=\"line\">setResult(RESULT_OK,intent);</span><br></pre></td></tr></table></figure></p>\n<p>除此之外，还可以直接监听到返回键的事件来处理响应的事件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onBackPressed() &#123;</span><br><span class=\"line\">Toast.makeText(SecondActivity.this,&quot;onBackPassed&quot;,Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Activity的生命周期\"><a href=\"#Activity的生命周期\" class=\"headerlink\" title=\"Activity的生命周期\"></a>Activity的生命周期</h3><h4 id=\"返回栈\"><a href=\"#返回栈\" class=\"headerlink\" title=\"返回栈\"></a>返回栈</h4><p>Android也是用栈的方式去管理Activity，用Task去管理，返回栈是BackStack</p>\n<h4 id=\"活动的四个状态\"><a href=\"#活动的四个状态\" class=\"headerlink\" title=\"活动的四个状态\"></a>活动的四个状态</h4><p>每个Activity有四种状态：</p>\n<h5 id=\"运行状态\"><a href=\"#运行状态\" class=\"headerlink\" title=\"运行状态\"></a>运行状态</h5><p>最栈顶的Activity就是处于运行状态的，系统最不喜欢回收这种状态的Activity</p>\n<h5 id=\"暂停状态\"><a href=\"#暂停状态\" class=\"headerlink\" title=\"暂停状态\"></a>暂停状态</h5><p>因为并不是所有的Activity都是全屏状态，所以会存在一个Activity是可见的，但是上面有一个小的Activity部分遮挡，这样一来，后面的Activity既不在栈顶（非运行态），又是可见的。这种状态就是暂停状态。一般系统也是不考虑去回收这种状态的Activity，只有在内存极低的时候才有可能被系统回收。</p>\n<h5 id=\"停止状态\"><a href=\"#停止状态\" class=\"headerlink\" title=\"停止状态\"></a>停止状态</h5><p>如果一个活动在栈中，并且完全不可见的时候，就处于停止状态，系统会保存Activity的状态和成员变量。这个时候它并不是完全可靠的，当内存不足的时候就可能被系统回收。</p>\n<h5 id=\"销毁状态\"><a href=\"#销毁状态\" class=\"headerlink\" title=\"销毁状态\"></a>销毁状态</h5><p>如果一个Activity从返回栈中被移除掉的话，它就会成为销毁状态，系统最优先回收这种状态的Activity。</p>\n<h4 id=\"活动在三种生存期的七个回调方法\"><a href=\"#活动在三种生存期的七个回调方法\" class=\"headerlink\" title=\"活动在三种生存期的七个回调方法\"></a>活动在三种生存期的七个回调方法</h4><h5 id=\"完整生存期\"><a href=\"#完整生存期\" class=\"headerlink\" title=\"完整生存期\"></a>完整生存期</h5><p>从onCreate（）开始到onDestory（）结束</p>\n<h6 id=\"onCreate（）\"><a href=\"#onCreate（）\" class=\"headerlink\" title=\"onCreate（）\"></a>onCreate（）</h6><p>每个Activity中都重写这个方法，它会在每个Activity创建的时候调用，所以这个方法中应该完成一些例如加载布局文件、绑定事件等初始化操作。</p>\n<h6 id=\"onDestory（）\"><a href=\"#onDestory（）\" class=\"headerlink\" title=\"onDestory（）\"></a>onDestory（）</h6><p>这个方法在Activity被销毁之前调用，调用完成之后Activity就进入销毁状态</p>\n<h5 id=\"可见生存期\"><a href=\"#可见生存期\" class=\"headerlink\" title=\"可见生存期\"></a>可见生存期</h5><p>Activity从onStart（）到onStop（）之间的部分就是可见生存期。可见生存期的可见二字就意味着Activity是显示的，就算不能交互，也要算在内。<br>开发者就可以通过在onStart（）方法中加载资源，在onStop（）方法中释放资源，来保证停止状态的Activity不会占用过多的资源。</p>\n<h6 id=\"onStart（）\"><a href=\"#onStart（）\" class=\"headerlink\" title=\"onStart（）\"></a>onStart（）</h6><p>这个方法在Activity由不可见变成可见的时候调用</p>\n<h6 id=\"onStop（）\"><a href=\"#onStop（）\" class=\"headerlink\" title=\"onStop（）\"></a>onStop（）</h6><p>相反的，当Activity变得<strong>完全</strong>不可见的时候调用</p>\n<h5 id=\"前台生存期\"><a href=\"#前台生存期\" class=\"headerlink\" title=\"前台生存期\"></a>前台生存期</h5><p>在onResume（）方法和onPause（）方法之间的Activity就是前台生存期。这时候Activity子那个是处于运行状态，可以与用户交互</p>\n<h6 id=\"onResume（）\"><a href=\"#onResume（）\" class=\"headerlink\" title=\"onResume（）\"></a>onResume（）</h6><p>这个方法是Activity已经准备好和用户交互的时候调用。这个时候的Activity在栈顶并且一定是运行状态。</p>\n<h6 id=\"onPause（）\"><a href=\"#onPause（）\" class=\"headerlink\" title=\"onPause（）\"></a>onPause（）</h6><p>这个方法是系统准备去启动某个Activity或者恢复到某个Activity的时候调用，这个方法中一般用于把一些消耗系统资源的释放掉，或者保存一些关键数据，但是这个方法里执行的不能是一些耗时操作。<br><strong>如果是一个对话框出现在某个Activity上面的时候，如果没有完全遮挡，那么会调用onPause（）而不是onStop（）</strong></p>\n<p>除此之外，还有一个独立在这三种生存期之外的回调方法：</p>\n<h6 id=\"onRestart（）\"><a href=\"#onRestart（）\" class=\"headerlink\" title=\"onRestart（）\"></a>onRestart（）</h6><p>这个方法是Activity在由停止状态重新变成运行状态的时候调用的。</p>\n<p>下面附一张Activity的生命周期图（书上原图）：<br><img src=\"https://s1.ax1x.com/2018/06/07/CH124K.jpg\" alt=\"Activity的生命周期\"></p>\n<p>下面做一个测试用于FirstActivity到SecondActivity然后再跳转回来的一个状态跟踪打印：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">06-07 14:45:16.457 16551-16551/com.example.ifan.activitytest V/life: onCreate is called</span><br><span class=\"line\">06-07 14:45:16.736 16551-16551/com.example.ifan.activitytest V/life: onStart is called</span><br><span class=\"line\">06-07 14:45:16.742 16551-16551/com.example.ifan.activitytest V/life: onResume is called</span><br><span class=\"line\">06-07 14:45:29.731 16551-16551/com.example.ifan.activitytest V/life: onPause is called</span><br><span class=\"line\">06-07 14:45:30.536 16551-16551/com.example.ifan.activitytest V/life: onStop is called</span><br><span class=\"line\">06-07 14:46:24.588 16551-16551/com.example.ifan.activitytest V/life: onRestart is called</span><br><span class=\"line\">06-07 14:46:24.590 16551-16551/com.example.ifan.activitytest V/life: onStart is called</span><br><span class=\"line\">06-07 14:46:24.591 16551-16551/com.example.ifan.activitytest V/life: onResume is called</span><br><span class=\"line\">06-07 14:46:41.625 16551-16551/com.example.ifan.activitytest V/life: onPause is called</span><br><span class=\"line\">06-07 14:46:42.003 16551-16551/com.example.ifan.activitytest V/life: onStop is called</span><br><span class=\"line\">06-07 14:46:42.004 16551-16551/com.example.ifan.activitytest V/life: onDestory is called</span><br></pre></td></tr></table></figure></p>\n<p>可以看出来从FirstActivity到SecondActivity的时候，经过了onPause（）和onStop（）的方法的调用；从SecondActivity回到FirstActivity的时候，经过了onRestart（）、onStart（）和onResume（）的调用</p>\n<p>再做一个部分遮挡的例子：SecondActivity是一个对话框式的Activity时候，从FirstActivity到SecondActivity打印出来的是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">06-07 14:56:10.743 17244-17244/com.example.ifan.activitytest V/life: onCreate is called</span><br><span class=\"line\">06-07 14:56:11.011 17244-17244/com.example.ifan.activitytest V/life: onStart is called</span><br><span class=\"line\">06-07 14:56:11.019 17244-17244/com.example.ifan.activitytest V/life: onResume is called</span><br><span class=\"line\">06-07 14:56:14.760 17244-17244/com.example.ifan.activitytest V/life: onPause is called</span><br><span class=\"line\">06-07 14:56:24.734 17244-17244/com.example.ifan.activitytest V/life: onResume is called</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这种情况少了onStop（）、onRestart（）和onStart（）的调用过程。</p>\n<p>另外还可以看到在按返回键的时候的调用过程如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">06-07 15:22:38.832 18596-18596/com.example.ifan.activitytest V/life: onPause is called</span><br><span class=\"line\">06-07 15:22:39.261 18596-18596/com.example.ifan.activitytest V/life: onStop is called</span><br><span class=\"line\">06-07 15:22:39.262 18596-18596/com.example.ifan.activitytest V/life: onDestory is called</span><br></pre></td></tr></table></figure></p>\n<p>看到有博客说按home、返回、在后台杀进程的调用过程会有差异。<br>另外在onStop（）的覆写中如果不写对父类方法的调用会导致Activity直接被回收，下一次还需要重新create。也很好理解，因为不调用父类方法的话其实就少了状态、变量的保存过程，所以会出现这样的结果。</p>\n<h4 id=\"Activity在停止状态被回收的情况\"><a href=\"#Activity在停止状态被回收的情况\" class=\"headerlink\" title=\"Activity在停止状态被回收的情况\"></a>Activity在停止状态被回收的情况</h4><p>Activity在活动状态是可能被回收的，也就是可能存在以下场景：<br>A跳转到B，然后A进入停止状态，但是A被销毁了，这时候从B回来就不会调用onRestart（）方法，而是调用onCreate（）方法。这时候因为A在onStop（）方法里写入的数据也随着之前停止状态的Activity被销毁了，所以这时候从B回去之后看到的A就是一个新创建的A了。<br>怎么解决呢？<br>Activity提供了一个onSaveInstanceState（）的回调方法，这个方法能够保证在Activity被Destory之前一定会被执行。所以我们可以在在这里保存A的Stop数据。</p>\n<p>这个onSaveInstanceState（）携带一个Bundle类型的参数，Bundle提供了一系列用于保存数据的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class=\"line\">\toutState.putString(&quot;FirstActivityDataOut&quot;,&quot;help~&quot;);</span><br><span class=\"line\">    super.onSaveInstanceState(outState);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后在onCreate（）方法中携带的Bundle类型的参数里获取这个Bundle中的数据就可以了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(savedInstanceState.getString(&quot;FirstActivityDataOut&quot;)!=null)</span><br><span class=\"line\">\tLog.v(&quot;FirstActivityDataOut&quot;,savedInstanceState.getString(&quot;FirstActivityDataOut&quot;));</span><br></pre></td></tr></table></figure></p>\n<p>除此之外，在Intent的使用中也可以使用Bundle来传值。</p>\n<h3 id=\"Activity的四种启动模式\"><a href=\"#Activity的四种启动模式\" class=\"headerlink\" title=\"Activity的四种启动模式\"></a>Activity的四种启动模式</h3><p>四种启动模式是在AndroidManifest.xml里面的Activity对应的标签里面指定的。</p>\n<h4 id=\"standard\"><a href=\"#standard\" class=\"headerlink\" title=\"standard\"></a>standard</h4><p>标准模式，也就是默认模式，在一个Activity建好的初始设置就是这个，每次启动一个新的Activity的时候，它就在返回栈中入栈，处于栈顶位置。这样的话，当此Activity递归地跳转到本类的Activity，栈中也会不停地新建、入栈。</p>\n<h4 id=\"singleTop\"><a href=\"#singleTop\" class=\"headerlink\" title=\"singleTop\"></a>singleTop</h4><p>栈顶单例，顾名思义，处于栈顶的Activity在进行上面的操作的时候，会被直接使用本activity，而不是不断新建、入栈。但是前提条件必须是：<strong> 当前的Activity必须处于栈顶。</strong></p>\n<p><strong>一个有意思的现象是使用startActivityForResult（）去启动这个singleTop的Activity的时候，是无视它的singleTop模式的，google这样设计的原因可能是考虑到回调的内容没有接受者</strong></p>\n<h4 id=\"singleTask\"><a href=\"#singleTask\" class=\"headerlink\" title=\"singleTask\"></a>singleTask</h4><p>上一种的singleTop是只检查栈顶，避免了单个Activity的递归启动。除此之外还可以让某个Activity在整个返回栈中成为唯一的一个Activity。<br>例如：</p>\n<p>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;B</p>\n<p>如果B的启动类型为singleTask，那么在从E到B的时候实际上是回到了最前面B，而且最前面的B之后的都会被从栈里弹出。</p>\n<h4 id=\"singleInstance\"><a href=\"#singleInstance\" class=\"headerlink\" title=\"singleInstance\"></a>singleInstance</h4><p>这个是不同于上面的三种的一种特殊的启动方式——这种启动模式的Activity会启用一个另外的返回栈去管理这个活动。应用场景就是当别的程序要共享访问这个Activity，其他的三种模式就不能完成了。（每个程序都有自己的返回栈，如果访问了这个Activity，那必定是在当前的程序和别的那个程序里面都会分别加入一个新建的这个Activity，那就是不同的实例了，达不到共享的目的。）</p>\n<p>而这个singleInstance就是解决这种情况的——<strong>它会连同Activity一块返回一个单独的返回栈，然后任何一个应用来访问这个Activity，都公用同一个返回栈。</strong><br>例如：</p>\n<p>A -&gt; B -&gt; C</p>\n<p>如果B的启动模式为singleInstance的话，实际的栈是这样的：<br>A — C<br>B<br>第一个栈是本程序自己的栈，因为A、C都是普通的模式，所以都默认入栈到程序自己的默认栈里了。而第二个栈就是随着B一同创建的新栈，这个栈是所有程序调用时公用的。</p>\n<p>所以返回键连续按下之后，先是C所在的栈先出栈C，然后是A，因为是同一个栈，最后才是B，因为程序自己所在的栈已经空了，就轮到B所在的栈出栈了。</p>\n<h3 id=\"一些实践\"><a href=\"#一些实践\" class=\"headerlink\" title=\"一些实践\"></a>一些实践</h3><p>了解了Activity的基础知识后，这里还有一些关于Activity的应用技巧。</p>\n<h4 id=\"获知当前所处Activity\"><a href=\"#获知当前所处Activity\" class=\"headerlink\" title=\"获知当前所处Activity\"></a>获知当前所处Activity</h4><p>当拿到别人的代码时候，可能就不方便知道当前的界面是处于哪一个Activity了，一个个对应也很麻烦，所以有一个办法去获知当前所处的Activity：<br>使用间接继承的原理，新建一个中间类BaseActivity继承自AppCompatActivity，在onCreate（）的方法中扩展一个打印当前类的语句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Log.v(&quot;BaseActivity&quot;,getClass().getSimpleName());</span><br></pre></td></tr></table></figure></p>\n<p>然后让所有的Activity都继承自这个BaseActivity，然后就可以显示出当前类的类名了。<br><strong>但是同时也有一个让人没有办法接受的缺点：难道我拿到别人的代码要把所有的Activity的继承类都修改一遍么？！</strong></p>\n<h4 id=\"退回到任意Activity\"><a href=\"#退回到任意Activity\" class=\"headerlink\" title=\"退回到任意Activity\"></a>退回到任意Activity</h4><p>用一个List去手动维护一个返回栈，从而能够对这个返回栈的Activity手动操控，就可以返回到任意Activity：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static boolean backToIndexOfStack(int index)&#123;</span><br><span class=\"line\">        if (index&gt;=activityList.size())&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = activityList.size()-1;i &gt; index;i--)&#123;</span><br><span class=\"line\">            activityList.get(i).finish();</span><br><span class=\"line\">            activityList.remove(activityList.size()-1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>index从0开始，这里依次从栈里finsh（）掉Activity，并且从手动维护的栈中remove掉。</p>\n<h4 id=\"启动Activity的最佳写法\"><a href=\"#启动Activity的最佳写法\" class=\"headerlink\" title=\"启动Activity的最佳写法\"></a>启动Activity的最佳写法</h4><p>在多人协作开发的时候，协定传参总是一个要考虑的点。可以在启动Activity的时候封装一个activityStart（）方法，专门用来构建Intent，这样一来参数就在这个activityStart（）方法的参数列表里体现出来了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void activityStart(Context context,String firstName,String lastName)&#123;</span><br><span class=\"line\">       Intent intent = new Intent(context,SecondActivity.class);</span><br><span class=\"line\">       intent.putExtra(&quot;param1&quot;,&quot;hello&quot;);</span><br><span class=\"line\">       intent.putExtra(&quot;param2&quot;,&quot;there&quot;);</span><br><span class=\"line\">       startActivity(intent);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Android-UI的开发\"><a href=\"#Android-UI的开发\" class=\"headerlink\" title=\"Android UI的开发\"></a>Android UI的开发</h1><p>前面的一节是从探究Activity的角度去了解Activity的用法和特点。接下来就是学习如何编写UI，结合Activity去编写完整的UI已经交互逻辑。</p>\n<h2 id=\"常用控件的使用\"><a href=\"#常用控件的使用\" class=\"headerlink\" title=\"常用控件的使用\"></a>常用控件的使用</h2><h3 id=\"TextView\"><a href=\"#TextView\" class=\"headerlink\" title=\"TextView\"></a>TextView</h3><p>这个控件类似于iOS里面的UILabel，用于展示文字信息。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:id=&quot;@+id/text_view&quot;</span><br><span class=\"line\">    android:text=&quot;This is a TextView&quot;</span><br><span class=\"line\">    android:gravity=&quot;center&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>android:layout_width、android:layout_height这两个属性是所有控件里面都有的，就像iOS里面的Frame一样用来设置大小，但是这个只是表示了大小并不明位置。<br>后面的值可选三种值：</p>\n<ul>\n<li>match_parent：表示让当前的控件和父布局的大小一样大。</li>\n<li>fill_parent：和match_parent的意义一样，现在官方推荐使用match_parent。</li>\n<li>wrap_content：表示让控件的大小刚好能包含控件中展示的内容，控件大小由控件内容决定。</li>\n</ul>\n<p>当然了，也可以手动指定固定值作为width、height的值，但是这样会导致适配出现问题。</p>\n<p><strong>gravity</strong>：指定的是对齐方式，和iOS里TextAlignment类似。可选的有top、bottom、left、right、center。（center是默认指定”center_vertical|center_horizontal”的，表示垂直和水平方向都居中）</p>\n<p><strong>textSize</strong>：指定文字大小。在Android里字体大小是使用sp作单位的。其实在打出24这个将要指定大小的数字的时候，自动补全了几个选项：dp、in、mm、pt、px、sp。好奇这几个有什么区别。之后我会另外开一个文去写这个的。<br><strong>textColor</strong>：#+6位16进制数表示颜色。</p>\n<p>更多的使用细节去查文档就好。</p>\n<h3 id=\"Button\"><a href=\"#Button\" class=\"headerlink\" title=\"Button\"></a>Button</h3><p>它在布局文件里的写法大同小异，它有一个textAllCaps属性，如果不设置为false的话默认为true就会把所有出现的字母都变为大写的。<br>然后就可以在Activity的类里面去获取这个控件了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class=\"line\">      button1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">          @Override</span><br><span class=\"line\">          public void onClick(View view) &#123;</span><br><span class=\"line\">              //点击之后的代码</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这是一种类似闭包的方式，其实还有一种通过实现接口的方式，需要在本类的声明部分写明实现哪一个接口，然后在设置button的监听者为本类，然后覆写onClick（）方法，方法内部通过判断id来分别实现不同button的点击事件。</p>\n<h3 id=\"EditText\"><a href=\"#EditText\" class=\"headerlink\" title=\"EditText\"></a>EditText</h3><p>这个控件实际上就是iOS里的TextView，支持多行输入和排版。<br>特别的属性：</p>\n<p><strong>hint</strong>：这一个是iOS里面的TextView里面没有的类似于placeHolder的设置。</p>\n<p><strong>maxLines</strong>：EditText如果高度不是定值，就会随着输入内容的增多而拉长。如果指定了这个属性，则EditText不会被拉长，但是内容视图的长度还是会被拉长。而且，它只是限制了EditText这个控件的最大显示行数，并没有限制内容的行数。</p>\n<p>另外，还可以在Activity里面获取到EditText里面的文字信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EditText editText = findViewById(R.id.edit_text);</span><br><span class=\"line\">editText.getText().toString()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ImageView\"><a href=\"#ImageView\" class=\"headerlink\" title=\"ImageView\"></a>ImageView</h3><p>这个倒是和iOS里的UIImageView差别不大,不过现在资源大多都同意放在res目录下的drawable目录下，但是这个目录没有制定具体的分辨率，所以书上的建议是新建一个drawable-xhdpi文件夹，然后把图片放进去。</p>\n<p>对于图片的设置有两种方法，一种是直接写在布局文件里，一种是在Activity类里去修改。这两种可以同时使用。</p>\n<p><strong>有意思的是，Android的图片文件并不能带大写字母，不然会报错说只支持小写字母、数字和下划线。</strong></p>\n<p>同时对文件名里带“.”的文件也不能支持，会报错。</p>\n<p><strong>另外，在一开始设置的height为wrap_content其实也没有起作用。</strong></p>\n<h3 id=\"ProgressBar\"><a href=\"#ProgressBar\" class=\"headerlink\" title=\"ProgressBar\"></a>ProgressBar</h3><p>显示一个进度条（默认样式是一个不断循环转动的圈圈）。布局文件里写的是默认可见的（当然也可以手动指定为其他值），就可以在Activity里去判断它当前是否是可见的，如果是可见的，可以设为不可见。</p>\n<p>在布局文件里设置:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:visibility=&quot;invisible&quot;</span><br></pre></td></tr></table></figure></p>\n<p>在Activity里设置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (findViewById(R.id.progress_bar).getVisibility() ==View.VISIBLE)&#123;</span><br><span class=\"line\">          findViewById(R.id.progress_bar).setVisibility(View.INVISIBLE);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于ProgressBar来说有三种可见选项：visible、invisible、gone</p>\n<p><strong>visible</strong>：可见的。</p>\n<p><strong>invisible</strong>：不可见，但是还占据着原来的位置和大小，可以理解为透明状态。</p>\n<p><strong>gone</strong>：不仅是不可见的，而且完全从屏幕上消失。</p>\n<p>除了上面的那种圈圈的样式，还有一种样式是条状的。可以通过在布局文件里设置style为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">style=&quot;?android:progressBarStyleHorizontal&quot;</span><br></pre></td></tr></table></figure></p>\n<p>对于这种样式，可以设置一个最大值，以便在Activity中动态的改变进度条的状态。</p>\n<p>布局文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android:max=&quot;100&quot;</span><br></pre></td></tr></table></figure></p>\n<p>Activity：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProgressBar progressBar = findViewById(R.id.progress_bar);</span><br><span class=\"line\">progressBar.setProgress(progressBar.getProgress()+10);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AlertDialog\"><a href=\"#AlertDialog\" class=\"headerlink\" title=\"AlertDialog\"></a>AlertDialog</h3><p>弹出一个对话框，一般用于警告用户，下方有三个按钮可以响应用户的点击事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AlertDialog.Builder dialog = new AlertDialog.Builder(FirstActivity.this);</span><br><span class=\"line\">dialog.setTitle(&quot;this will change image&quot;);</span><br><span class=\"line\">dialog.setMessage(&quot;this is very importent&quot;);</span><br><span class=\"line\">dialog.setCancelable(true);</span><br><span class=\"line\"></span><br><span class=\"line\">dialog.setNeutralButton(&quot;NeutralButton&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onClick(DialogInterface dialogInterface, int i) &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dialog.setNegativeButton(&quot;Cancle&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onClick(DialogInterface dialogInterface, int i) &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">    public void onClick(DialogInterface dialogInterface, int i) &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dialog.show();</span><br></pre></td></tr></table></figure></p>\n<p>可以在示例代码中看到，使用一般是三个步骤，先用Builder新建一个AlertDialog实例出来（指定Activity），然后设置标题、信息内容、可否在点击别的空白处取消这个AlertDialog。</p>\n<p>然后分别设置三个按钮（从左到右依次为NeutralButton、NegativeButton、PositiveButton）的点击回调事件。</p>\n<h3 id=\"ProgressDialog\"><a href=\"#ProgressDialog\" class=\"headerlink\" title=\"ProgressDialog\"></a>ProgressDialog</h3><p>和上面的那个AlertDialog很类似，也可选两种样式——转圈圈或者一个条状的进度条。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProgressDialog progressDialog = new ProgressDialog(FirstActivity.this);</span><br><span class=\"line\">progressDialog.setTitle(&quot;progressDialog&quot;);</span><br><span class=\"line\">progressDialog.setMessage(&quot;this is a progressDialog&quot;);</span><br><span class=\"line\">progressDialog.setCancelable(true);</span><br><span class=\"line\">progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span><br><span class=\"line\">progressDialog.setMax(256);</span><br><span class=\"line\">progressDialog.show();</span><br></pre></td></tr></table></figure></p>\n<p>这种的是和前面的ProgressBar是一样的，可以设置最大的长度、动态改变进度状态。<br>默认是转圈的样式。</p>\n<p><strong>需要注意的是，如果这个也设置为不允许失焦取消，那不知道何时会结束的progressDialog就会导致当前应用卡死，无法继续交互。如果设置为允许失焦消失，那就要处理好消失的逻辑，是否是用户选择取消当前进度？如果误操作怎么处理？如果是取消应该处理当前进度的任务？</strong></p>\n<h2 id=\"四种基本布局\"><a href=\"#四种基本布局\" class=\"headerlink\" title=\"四种基本布局\"></a>四种基本布局</h2><p>布局是一种可用于放置很多控件的容器。布局是可以嵌套的。可以通过布局的嵌套来完成一些复杂的布局效果。这一部分将用一个新的项目去学习和练习。</p>\n<h3 id=\"线性布局-LinearLayout\"><a href=\"#线性布局-LinearLayout\" class=\"headerlink\" title=\"线性布局-LinearLayout\"></a>线性布局-LinearLayout</h3><p>是一种非常常用的布局，这种布局会将内部包含的控件在线性方向上依次排列。<br>还记得最开始接触布局文件么？那个就是默认的线性布局（因为是根元素），有横向和竖向两种。</p>\n<p>可以通过orientation来指定线性到底是竖向还是横向。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:orientation=&quot;horizontal&quot;</span><br><span class=\"line\">android:orientation=&quot;vertical&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>需要注意的是，这时候控件的size就要设置合理。比如水平线性布局的时候，控件的宽度就不能match_parent了</strong></p>\n<p>layout的几个重要属性：</p>\n<h4 id=\"layout-gravity\"><a href=\"#layout-gravity\" class=\"headerlink\" title=\"layout_gravity\"></a>layout_gravity</h4><p>和gravity属性有点相似，但是其实完全没有关系。</p>\n<p><strong>gravity</strong>属性是指定某个控件内部的内容（如文字）在控件内是靠向哪一边的。</p>\n<p><strong>gravity_layout</strong>是指定当前控件在父布局中的位置是在如何对齐的。<br>同样的，在父布局已经处于某种方式的时候要做合理的设置，例如：父布局是水平布局（horizontal），只有设置控件在竖向位置的对齐（top、center、bottom等）才会生效。</p>\n<h4 id=\"layout-weight\"><a href=\"#layout-weight\" class=\"headerlink\" title=\"layout_weight\"></a>layout_weight</h4><p>这个属性是用比例的方式去指定控件的大小的，有一些自动布局的感觉。<br>需要区别的是控件的width属性，虽然可能长的像，但是二者是完全不同的：</p>\n<p><strong>width</strong>：用数值或者一些定义过的常量或者宏指定宽度。</p>\n<p><strong>weight</strong>：用比例去指定当前控件在水平方向上占用多少比例。</p>\n<p>当weight存在的时候，width是不生效的，也就是随便写多少都没用，但是比较规范的写法是写为0dp。（dp是Android里用于指定控件大小、间距的单位）</p>\n<p>然后weight里写的是比例，如果控件1里面写的是1，另一个控件里写的2，那么就表示两个控件的宽度比例是1:2。</p>\n<p>有的控件里没有写weight，只写了width为wrap，这时候就还是保证控件的宽度刚够包含控件自己的内容。</p>\n<p>如果控件1写了weight的值为1，控件2没有写weight但是写了width为wrap，那就是控件1尽量宽，然后控件2的宽度刚够包含自己的内容。</p>\n<h3 id=\"相对布局：RelativeLayout\"><a href=\"#相对布局：RelativeLayout\" class=\"headerlink\" title=\"相对布局：RelativeLayout\"></a>相对布局：RelativeLayout</h3><p>这种布局也是非常常用的布局，这种布局更随意一些，它可以用相对定位的方式让控件出现在布局的任意位置。</p>\n<p>正因如此，相对布局的属性就多了一些，但是好在都是有规律的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button</span><br><span class=\"line\">       android:text=&quot;hello3&quot;</span><br><span class=\"line\">       android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">       android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">       android:layout_alignParentEnd=&quot;true&quot;</span><br><span class=\"line\">       android:layout_alignParentTop=&quot;true&quot;</span><br><span class=\"line\">       /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，里面的位置相关的代码里面有Parent字段，也就是说，这些控件是相对于父布局来定位的。当然了也可以不依据父布局进行定位：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button</span><br><span class=\"line\">       android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">       android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">       android:layout_above=&quot;@+id/text_view&quot;</span><br><span class=\"line\">       android:layout_toLeftOf=&quot;@+id/text_view&quot;</span><br><span class=\"line\">       android:text=&quot;hello1&quot;</span><br><span class=\"line\">       /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>可以通过id去选定相对的参考控件，去选择相对位置。<br><strong>但是只能去参考前面出现过的控件，不然就找不到id了。</strong></p>\n<p>另外还有layout_alignLeft表示和目标控件左对齐，其他的其他方向都是一样的。</p>\n<h3 id=\"帧布局-FrameLayout\"><a href=\"#帧布局-FrameLayout\" class=\"headerlink\" title=\"帧布局 FrameLayout\"></a>帧布局 FrameLayout</h3><p>这种布局非常简单，相比前面的两种来说，使用场景也较少。</p>\n<p>这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角。多个控件按照默认方式放置会重叠在一起。</p>\n<p>当然，也可以用layout_gravity属性去指定控件的对齐方式，但是比起前面的几种来说还是太简单了，导致实际的应用场景也不是那么多。</p>\n<h3 id=\"百分比布局\"><a href=\"#百分比布局\" class=\"headerlink\" title=\"百分比布局\"></a>百分比布局</h3><p>安卓引用了一种全新的布局方式来解决线性布局不够强大的比例式布局的缺点，这种布局中，可以不再用wrap_content、match_parent等方式去指定控件的大小，而是直接指定控件在布局中所占的百分比，这样就可以轻松实现任意比例分割布局了。</p>\n<p>百分比布局对FrameLayout和RelativeLayout进行了功能扩展，提供了PercentFrameLayout和PercentRelativeLayout的全新布局。</p>\n<p>为了让这种布局方式能够兼容就的安卓版本上使用，这种布局定义在support库中，只需要在项目的build.gradle中添加百分比布局的依赖保证兼容性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.percent.PercentFrameLayout</span><br><span class=\"line\">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/text_view&quot;</span><br><span class=\"line\">        android:layout_gravity=&quot;start&quot;</span><br><span class=\"line\">        app:layout_widthPercent=&quot;50%&quot;</span><br><span class=\"line\">        app:layout_heightPercent=&quot;50%&quot;</span><br><span class=\"line\">        android:text=&quot;hello~&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/android.support.percent.PercentFrameLayout&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这里的app并没有补全，想来应该是因为这个并不在内置在系统的SDK中的，所以没有自动补全。</p>\n<p><strong>这种布局有一个大坑：写50%的时候总是先写50再写%，写这里的时候我写了50然后手抖后面多跟了个0，成了500，然后就直接卡死，告诉我Out of Memory。其实也很好解释，因为AndroidStudio是可以自动预览布局的，所以这里还来不及修改的时候，已经自动按照500去算百分比了，1是100%，那么500就是50000%，所以就内存不够了。</strong></p>\n<p>对于另一种PercentRelativeLayout，它继承了RelativeLayout的所有属性并且加入了app:layout_widthPercent和app:layout_heightPercent来指定控件的宽高。</p>\n<h3 id=\"约束布局——ConstraintLayout\"><a href=\"#约束布局——ConstraintLayout\" class=\"headerlink\" title=\"约束布局——ConstraintLayout\"></a>约束布局——ConstraintLayout</h3><p>因为书上的几种布局方式比较老，其实在现在的AndroidStudio里面新建一个project的时候，已经默认设置为这种约束布局了，所以换句话说，这个应该重点学习，它被默认支持一定是有它的优点的。</p>\n<p>之前一直是用代码去编写布局，是因为前面的几种布局对于用代码的表达更好一些。但是归根结底来说，布局这种的用可视化去编辑是最直观最合适的，所以这个就是为了解决这种问题的一种新的布局方式。（这个书的作者也说了，当时在写书的时候这个布局方式刚出来，就没有加入到书里。）</p>\n<p>这种布局方式是使用控件的相对位置去布局的，有点类似相对布局，但是比相对布局还要强大。</p>\n<p>这种布局同时还解决了传统的几种布局的嵌套问题。传统布局要实现复杂的布局往往需要多重嵌套，但是多重嵌套会降低性能，所以这种布局应对复杂布局的时候可能会更好。</p>\n<p>这种布局暂时看到的教程都说适合用Design界面去拖拽完成布局操作，所以这里就先不写了。</p>\n<h2 id=\"自定义控件\"><a href=\"#自定义控件\" class=\"headerlink\" title=\"自定义控件\"></a>自定义控件</h2><p>和iOS一样，Android里的控件也都是直接或者间接的继承自View，所有的布局都是直接或间接继承自ViewGroup。View是Android里的最基本的UI组件。ViewGroup是一种特殊的View，可以包含很多子View和ViewGroup，是用于防止控件和布局的容器。</p>\n<p>需要接触几个前面没有接触到的属性：</p>\n<p><strong>background</strong>：为布局或者控件指定一个背景，可以使颜色或者图片。</p>\n<p><strong>margin</strong>：指定控件在四个方向的偏移量，也可以用margin_left等指定单一某个方向上的偏移量。</p>\n<p>先写好某一个自定义布局，然后在另一个布局里面引用这个布局就可以了。</p>\n<p>title.xml：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout</span><br><span class=\"line\">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;Button</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_gravity=&quot;center&quot;</span><br><span class=\"line\">        android:layout_margin=&quot;5dp&quot;</span><br><span class=\"line\">        android:text=&quot;Back&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:layout_width=&quot;0dp&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_gravity=&quot;center&quot;</span><br><span class=\"line\">        android:layout_weight=&quot;1&quot;</span><br><span class=\"line\">        android:gravity=&quot;center&quot;</span><br><span class=\"line\">        android:text=&quot;title&quot;</span><br><span class=\"line\">        android:textSize=&quot;24sp&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">    &lt;Button</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_gravity=&quot;center&quot;</span><br><span class=\"line\">        android:layout_margin=&quot;5dp&quot;</span><br><span class=\"line\">        android:text=&quot;edit&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>\n<p>activity_miain.xml：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout</span><br><span class=\"line\">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;include layout=&quot;@layout/title&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这个的实现效果就是自定义了个ActionBar并且加载到主布局中。</p>\n<h2 id=\"最常用、最难用的控件——ListView\"><a href=\"#最常用、最难用的控件——ListView\" class=\"headerlink\" title=\"最常用、最难用的控件——ListView\"></a>最常用、最难用的控件——ListView</h2><p>这里的ListView就类似于iOS里面的UITableView，重要性不用多说。</p>\n<p>先从最简单的用法开始：</p>\n<h3 id=\"ListView的简单用法\"><a href=\"#ListView的简单用法\" class=\"headerlink\" title=\"ListView的简单用法\"></a>ListView的简单用法</h3><p>先在布局里面写一个ListView进去，这里先写好大小和id就可以。</p>\n<p>然后在Activity里面写一个和这个listView相关的实例，把它的适配器指定为某个适配器的实例就好了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListView listView = findViewById(R.id.list_view);</span><br><span class=\"line\">ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(</span><br><span class=\"line\">\tMainActivity.this,</span><br><span class=\"line\">    android.R.layout.simple_list_item_1,</span><br><span class=\"line\">    data</span><br><span class=\"line\">    );</span><br><span class=\"line\">listView.setAdapter(adapter);</span><br></pre></td></tr></table></figure></p>\n<p>这个适配器只是众多适配器中的一种，这个据说是最好用的，可以通过泛型来指定钥匙胚的数据类型，然后在构造函数里传参进去。</p>\n<p>ArrayAdapter有很多重载，这里是因为用到的数据都是String类型，所以这里写 了String。然后依次传入当前的上下文、listView的id，以及具体的数据数组。</p>\n<p>这里的android.R.layout.simple_list_item_1相当于是iOS里面UITableView的style，可以有很多种style，根据具体的使用场景自行切换。</p>\n<h3 id=\"自定义ListView的界面\"><a href=\"#自定义ListView的界面\" class=\"headerlink\" title=\"自定义ListView的界面\"></a>自定义ListView的界面</h3><p>自定义的过程和iOS的自定义cell的基本上相似，都是新建一个布局，然后让ListView去加载这个布局作为item，然后把构造好的数据展示到界面上就好了。</p>\n<ul>\n<li>先新建一个布局：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;ImageView</span><br><span class=\"line\">        android:id=&quot;@+id/fruit_image&quot;</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:background=&quot;@drawable/ic_launcher_background&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/fruit_textview&quot;</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_gravity=&quot;center_vertical&quot;</span><br><span class=\"line\">        android:layout_margin=&quot;10dp&quot;/&gt;</span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个就是cell（也就是item）的展示布局。</p>\n<ul>\n<li>新建一个容器类<br>这个容器类就是作为ListView的适配器类型：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Fruit &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private int imageId;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Fruit(String name,int imageId)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.imageId = imageId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getImageId() &#123;</span><br><span class=\"line\">        return imageId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个部分就相当于model类的部分，用来存储ListView将来要展示的数据。</p>\n<ul>\n<li>新建一个适配器类<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123;</span><br><span class=\"line\">    private int resourceId;</span><br><span class=\"line\">    public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt;object)&#123;</span><br><span class=\"line\">        super(context,textViewResourceId,object);</span><br><span class=\"line\">        resourceId = textViewResourceId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123;</span><br><span class=\"line\">        Fruit fruit = getItem(position);</span><br><span class=\"line\">        View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);</span><br><span class=\"line\">        ImageView fruitImage = (ImageView)view.findViewById(R.id.fruit_image);</span><br><span class=\"line\">        TextView fruitName=(TextView)view.findViewById(R.id.fruit_textview);</span><br><span class=\"line\">        fruitImage.setImageResource(fruit.getImageId());</span><br><span class=\"line\">        fruitName.setText(fruit.getName());</span><br><span class=\"line\">        return view;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看到这个适配器类是继承自ArrayAdapter的，声明了一个私有属性resourceId，然后在这个类的构造函数里传入三个参数：上下文、textViewResourceId、和一个model类的List对象。调用父类的方法，对私有属性赋值。</p>\n<p>然后需要重写一个父类的方法getView（），这个方法就相当于iOS里面的cellForRowAtIndex，在每次item要出现在屏幕上的时候就会调用。</p>\n<p>这个getView传入了三个参数：position相当于是index，因为前面在构造函数里面已经设置过了List对象，所以这个方法是把数组中当前要处理的cell的对应元素取出来。</p>\n<p>然后要新建一个View对象，这个view是：先获取到Activity的布局渲染器，然后对这个布局渲染器LayoutInflater调用inflate方法。inflate方法需要传三个参数：resourceId（具体的item的那个布局的xml文件）、parent（父布局，和缓存有关）、false（表示这个resourceId所引用的布局是不带父布局的，因为如果带了父布局，就不能添加到目标要添加的父布局了）。</p>\n<p>然后从这个view中通过findViewById的方法去找到具体的控件，接着分别从对应顺序的model的元素（第一行的getItem方法已经取出来了的那个）里面取出需要显示在item上面的值，赋值给对应的控件，然后返回这个view作为ListView的item。</p>\n<ul>\n<li>在Activity中：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;Fruit&gt; fruits = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    ListView listView = findViewById(R.id.list_view);</span><br><span class=\"line\"></span><br><span class=\"line\">    initFruit();</span><br><span class=\"line\">    FruitAdapter adapter = new FruitAdapter(MainActivity.this,R.layout.fruit_item,fruits);</span><br><span class=\"line\"></span><br><span class=\"line\">    listView.setAdapter(adapter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void initFruit()&#123;</span><br><span class=\"line\">\tfor (int i =0;i&lt;100;i++)&#123;</span><br><span class=\"line\">    \tFruit fruit = new Fruit(&quot;apple&quot;+i,R.drawable.ic_launcher_background);</span><br><span class=\"line\">        fruits.add(fruit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前面的其实都是准备的工作，要生效还是在Activity里面建立数据数组，然后对数据数组进行初始化，然后新建一个自定义的适配器，最后把listview的适配器设置为刚才建立好的自定义适配器实例。</p>\n<p>要实现更复杂的item，只要修改model和item的布局文件就可以了。</p>\n<h3 id=\"提升ListView的效率\"><a href=\"#提升ListView的效率\" class=\"headerlink\" title=\"提升ListView的效率\"></a>提升ListView的效率</h3><p>ListView之所以难用就是因为它的使用初看比较简单，但是实际上有很多可以优化的点，比如提升效率。</p>\n<p>前面写的代码的运行效率就很低，因为在适配器的代码中，每次item出现的时候，都会调用的getView方法中都会加载一遍布局。当ListView快速滑动的时候，就会带来不小的负担。</p>\n<p>其实前面没有注意到的是，getView还有一个参数：convertView。</p>\n<p>这个参数是将之前加载好的布局缓存起来，以便之后再次使用。</p>\n<p>所以其实可以这样用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View view;</span><br><span class=\"line\">if (convertView == null)</span><br><span class=\"line\">\tLayoutInflater.from(getContext()).inflate(resourceId,parent,false);</span><br><span class=\"line\">else</span><br><span class=\"line\">    view = convertView;</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，就不会每次都不分青红皂白地去加载布局了，而是先判断缓存的布局是不是为空，如果为空，再去加载布局，如果不为空，就直接变动要显示的数据就好了。</p>\n<p><strong>纵使这样，代码的性能还能继续优化：</strong><br>虽然已经可以不用重复地去加载布局了，但是对于getView方法，还是需要每次从view里面通过findViewById去找到具体的控件。所以这里就可通过新建一个ViewHolder类去缓存每个控件了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@NonNull</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123;</span><br><span class=\"line\">\tFruit fruit = getItem(position);</span><br><span class=\"line\"></span><br><span class=\"line\">    ViewHolder viewHolder;</span><br><span class=\"line\">    View view;</span><br><span class=\"line\">    if (convertView == null)&#123;</span><br><span class=\"line\">    \tview = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);</span><br><span class=\"line\">    \tviewHolder = new ViewHolder();</span><br><span class=\"line\">        viewHolder.fruitImage = (ImageView)view.findViewById(R.id.fruit_image);</span><br><span class=\"line\">        viewHolder.fruitName = (TextView)view.findViewById(R.id.fruit_textview);</span><br><span class=\"line\">        view.setTag(viewHolder);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">    \tview = convertView;</span><br><span class=\"line\">        viewHolder = (ViewHolder)view.getTag();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert fruit != null;</span><br><span class=\"line\">    viewHolder.fruitImage.setImageResource(fruit.getImageId());</span><br><span class=\"line\">    viewHolder.fruitName.setText(fruit.getName());</span><br><span class=\"line\">    return view;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class ViewHolder&#123;</span><br><span class=\"line\">\tImageView fruitImage;</span><br><span class=\"line\">    TextView fruitName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这里的ViewHolder类也很简单，和Fruit类一一对应，只不过Fruit里面是数据，这个里面是需要改变数据的item的控件。</p>\n<p>在原来优化的基础上，对于新加载布局的情况：把从view里面寻找对应的控件，然后存到viewHolder里面，最后把viewHolder实例设置为view的tag；</p>\n<p>对于不用重新加载布局的view：直接通过getTag方法获取viewHolder，然后取出viewHolder里面的控件进行操作。</p>\n<h3 id=\"ListView的点击事件\"><a href=\"#ListView的点击事件\" class=\"headerlink\" title=\"ListView的点击事件\"></a>ListView的点击事件</h3><p>也很好理解，就和iOS里面的cell监听方法一样的。</p>\n<p>对于Android的ListView，就是实现ListView的setOnItemClickListener方法参数中的闭包。</p>\n<p>前面的优化都是在自定义适配器里写的，这里就要回到Activity里面了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;</span><br><span class=\"line\">    \tFruit fruit = fruits.get(position);</span><br><span class=\"line\">        Toast.makeText(MainActivity.this,&quot;this is &quot;+fruit.getName(),Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这个方法是在参数中传入了一个闭包，覆写了onItemClick的方法，传入了三个参数：一个适配器类型的变量、一个当前的item的view，一个当前的index，一个id。</p>\n<p>然后如果要让点击之后发生点什么，就在这个onItemClick方法里写就好。</p>\n<h2 id=\"RecyclerView\"><a href=\"#RecyclerView\" class=\"headerlink\" title=\"RecyclerView\"></a>RecyclerView</h2><p>终于过了那个ListView大户，然后又来了一个传说中更强大的控件——RecycleView。</p>\n<p>ListView其实有着很多不够强大的地方——一是需要用一些技巧去优化它的性能，二是它只能实现竖向的滚动，不能实现横向的滑动。</p>\n<p>所以，Android就提供了一个更强大的控件，这个可以看做一个增强版的ListView，可以轻松实现ListView的效果，还优化了ListView里面的各种不足之处。目前就连Android官方都更加推荐RecycleView。</p>\n<p>因为这个也是官方SDK里没有默认提供的控件，所以需要在app/build.gradle里面写明依赖库。</p>\n<p>然后就是在布局文件里面写这个控件了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>开头先说几句：</p>\n<ul>\n<li>我很久没有更新这个博客了，好不容易搭建的差不多，还没有来的及修改一些细节部分，不过还好，不影响使用，之后有空了再改吧。后面会把一些学习的历程、学习笔记或者一些乱七八糟的感想什么的等等东西更新上来，应该也没有什么人来看吧~</li>\n<li>这个Android的学习历程其实并不是我学客户端开发的开头——虽然博客里之前也并没有写关于其他的学习历程。。。我其实之前学的是iOS开发，OC写了挺久，最近也在接触Swift，本来是做好了做一个正经的iOS开发实习生（虽然我从来没有过iPhone），但是呢，今天实习公司的导师加了微信，我才得知我去了之后是要做Android的。一开始有点懵，我没写过这个东西呀，Java也掌握的很一般很一般，这意味着我有很多东西需要学习。那，如果我实习留不下呢？我写了一个月的Android然后回来匆匆忙忙复习iOS再投秋招的iOS岗位么？有点纠结，也很难抉择。</li>\n<li>后来一想，反正实习还是要去的，那我现在开始了解一些开发Android相关的东西，去了以后能调岗位就最好，不能调的话就尽量争取留下来吧。也问了一些学长的看法作为参考。这不过就是一次挑战而已，总不可能事事如意，这个就当是一个学习能力的挑战吧，能不能在固定的一段时间里学到尽量多的东西。反正iOS的学习基本上也到了瓶颈期，不如，换换口味？</li>\n<li>再者说，我也算个安卓机的爱好者吧，因为穷我用的从来都是安卓机，也很早开始折腾安卓系统，root、刷系统、玩xposed……算是从安卓2.x一直到8.1的体验者了。</li>\n<li>塞翁失马，焉知非福</li>\n<li>那就这么开始学习安卓吧</li>\n</ul>\n<h1 id=\"开始前的准备\"><a href=\"#开始前的准备\" class=\"headerlink\" title=\"开始前的准备\"></a>开始前的准备</h1><h2 id=\"教材\"><a href=\"#教材\" class=\"headerlink\" title=\"教材\"></a>教材</h2><p>我用的是学长推荐的《第一行代码Android》</p>\n<h2 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h2><p>用了很久的黑苹果10.12.6，AS最新版，不想用模拟器，就用了我刷了8.1的一加2</p>\n<h1 id=\"HelloWorld\"><a href=\"#HelloWorld\" class=\"headerlink\" title=\"HelloWorld\"></a>HelloWorld</h1><p>新建了一个只有一个Activity的项目，它自己就写了“hello，world” 所以其实不算是我自己写的。<br>但是比起新建一个EmptyActivity什么都没有一脸懵逼来说好很多了</p>\n<h2 id=\"项目文件夹结构\"><a href=\"#项目文件夹结构\" class=\"headerlink\" title=\"项目文件夹结构\"></a>项目文件夹结构</h2><h3 id=\"gradle-和-idea\"><a href=\"#gradle-和-idea\" class=\"headerlink\" title=\".gradle 和 .idea\"></a>.gradle 和 .idea</h3><p>自动生成的文件，不用管</p>\n<h3 id=\"app\"><a href=\"#app\" class=\"headerlink\" title=\"app\"></a>app</h3><p>主要文件都在这里</p>\n<h4 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a>build</h4><p>也是编译生成的文件，更多更杂，不用管</p>\n<h4 id=\"libs\"><a href=\"#libs\" class=\"headerlink\" title=\"libs\"></a>libs</h4><p>第三方包的文件夹，会自动加到构建的路径里</p>\n<h4 id=\"src\"><a href=\"#src\" class=\"headerlink\" title=\"src\"></a>src</h4><p>这个文件里的东西是编写的时候需要关注的文件夹，需要自己写的内容基本上都在这里面</p>\n<h5 id=\"androidTest\"><a href=\"#androidTest\" class=\"headerlink\" title=\"androidTest\"></a>androidTest</h5><p>可以在这里写测试用例，可以自动化测试</p>\n<h5 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h5><p>基本上java文件就都在这里了</p>\n<h6 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h6><p>java文件就在这个文件夹下，比如刚才创建的Activity.java</p>\n<h6 id=\"res\"><a href=\"#res\" class=\"headerlink\" title=\"res\"></a>res</h6><p>项目里要用到的所有图片（drawable）、布局（layout）、字符串（values）等</p>\n<h6 id=\"AndroidManifest-xml\"><a href=\"#AndroidManifest-xml\" class=\"headerlink\" title=\"AndroidManifest.xml\"></a>AndroidManifest.xml</h6><p>这个是整个项目的配置文件，在程序里定义的所有的四大组件都需要在这里注册，另外还可以写权限声明，这个要经常用到</p>\n<h5 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h5><p>又是一个测试，先不管</p>\n<h5 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\".gitignore\"></a>.gitignore</h5><p>git忽略的文件</p>\n<h5 id=\"app-imi\"><a href=\"#app-imi\" class=\"headerlink\" title=\"app.imi\"></a>app.imi</h5><p>不用管</p>\n<h5 id=\"build-gradle\"><a href=\"#build-gradle\" class=\"headerlink\" title=\"build.gradle\"></a>build.gradle</h5><p>app这个模块的构建脚本</p>\n<h5 id=\"proguard-rules-pro\"><a href=\"#proguard-rules-pro\" class=\"headerlink\" title=\"proguard-rules.pro\"></a>proguard-rules.pro</h5><p>用于指定混淆规则，厉害了，用于防止代码被破解</p>\n<h3 id=\"build-1\"><a href=\"#build-1\" class=\"headerlink\" title=\"build\"></a>build</h3><p>编译时自动生成的文件，不用管</p>\n<h3 id=\"gradle\"><a href=\"#gradle\" class=\"headerlink\" title=\"gradle\"></a>gradle</h3><p>包含了gradle wrapper的配置文件，默认不启用这个方式</p>\n<h3 id=\"gitignore-1\"><a href=\"#gitignore-1\" class=\"headerlink\" title=\"gitignore\"></a>gitignore</h3><p>git的忽略文件</p>\n<h3 id=\"build-gradle-1\"><a href=\"#build-gradle-1\" class=\"headerlink\" title=\"build.gradle\"></a>build.gradle</h3><p>全局gradle构建脚本，gradle是一个自动化构建脚本，一般不用改</p>\n<h3 id=\"gradle-properties\"><a href=\"#gradle-properties\" class=\"headerlink\" title=\"gradle.properties\"></a>gradle.properties</h3><p>全局gradle配置文件，会影响整个项目的编译</p>\n<h3 id=\"gradlew和gradlew-bat\"><a href=\"#gradlew和gradlew-bat\" class=\"headerlink\" title=\"gradlew和gradlew.bat\"></a>gradlew和gradlew.bat</h3><p>是用来执行gradle的，不用管</p>\n<h3 id=\"XXX-imi\"><a href=\"#XXX-imi\" class=\"headerlink\" title=\"XXX.imi\"></a>XXX.imi</h3><p>是这个IDE的存在感的标识，不用管</p>\n<h3 id=\"local-properties\"><a href=\"#local-properties\" class=\"headerlink\" title=\"local.properties\"></a>local.properties</h3><p>指定本机的Android SDK的路径，是自动生成的一般不用改</p>\n<h3 id=\"setting-gradle\"><a href=\"#setting-gradle\" class=\"headerlink\" title=\"setting.gradle\"></a>setting.gradle</h3><p>用来指定项目中所有引入的模块，目前为止一共就用了app这么一个模块，所以现在还就只写了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &apos;:app&apos;</span><br></pre></td></tr></table></figure></p>\n<p><strong> 好了，关于文件目录就是这些，总结起来就是外层的文件夹什么的基本上先不用管，要注意的就是app这个文件夹里的 </strong></p>\n<h2 id=\"如何运行起来的\"><a href=\"#如何运行起来的\" class=\"headerlink\" title=\"如何运行起来的\"></a>如何运行起来的</h2><p>先看Android-Manifest.xml里做了什么</p>\n<h3 id=\"Android-Manifest-xml\"><a href=\"#Android-Manifest-xml\" class=\"headerlink\" title=\"Android-Manifest.xml\"></a>Android-Manifest.xml</h3><p>里面有一部分代码长这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=&quot;.MainActivity&quot;&gt;</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">    \t&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class=\"line\">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p>\n<p>指定了点击应用之后首先启动哪个Activity，这里当然是MainActivity这个类<br>那MainActivity这个类里面做了什么操作呢？</p>\n<h3 id=\"MainActivity-java\"><a href=\"#MainActivity-java\" class=\"headerlink\" title=\"MainActivity.java\"></a>MainActivity.java</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends AppCompatActivity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个类是一个继承自AppCompatActivity的类，这个类类似于iOS里的ViewController<br>这个类的onCreate方法是一个Activity被创建的时候一定会执行的方法（类似于iOS里的ViewDidLoad）<br>这里并没有看到“hello world”的字样。<br>Android编程讲究逻辑和视图分离，所以setContentView这个方法引入了一个布局文件（res/layout）</p>\n<h3 id=\"activity-main-xml\"><a href=\"#activity-main-xml\" class=\"headerlink\" title=\"activity_main.xml\"></a>activity_main.xml</h3><p>这个文件里面有一部分是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:text=&quot;Hello World!&quot;</span><br><span class=\"line\">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class=\"line\">        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class=\"line\">        app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class=\"line\">        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>表示布局里添加了一个TextView的控件，设置了ndroid:text=”Hello World!”所以会显示出Hello World。这个控件类似于iOS里的UILable</p>\n<p><strong> 这样就大致搞清楚了HelloWorld是怎么运行起来的，并且各种文件是怎么组织起来的。其实和iOS类似的地方很多，AndroidManifest.xml有些类似APPDelegate，Activity类似于ViewController，activity_main.xml类似于xib，但是之前都是直接用代码写的布局类，所以这种的还需要适应一下 </strong></p>\n<p><strong> 大致过程大概就是，先在AndroidManifest.xml配置Activity，然后在布局文件里面写界面相关的代码，然后在Activity.java里面写对布局里面的控件的操控，也是类似MVC的经典的逻辑分离的设计方法。 </strong></p>\n<h1 id=\"从0开始自己构建一个APP\"><a href=\"#从0开始自己构建一个APP\" class=\"headerlink\" title=\"从0开始自己构建一个APP\"></a>从0开始自己构建一个APP</h1><p>前面的HelloWorld是人机自动生成的，这一次开始自己从0开始写一个，选择Empty，这时候没有Acitvity，所以不会有显示的。</p>\n<h2 id=\"新建一个Activity\"><a href=\"#新建一个Activity\" class=\"headerlink\" title=\"新建一个Activity\"></a>新建一个Activity</h2><p>在app/src/main/java/com.example.ifan.activitytest右键从new里面选择一个EmptyActivity。这里新建的Activity是会自动在AndroidManifest.xml里面自动添加注册的代码的，但是不会自动设置为最先启动后展示的第一个页面，所以还需要在activity的标签里手动添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;intent-filter&gt;</span><br><span class=\"line\">\t&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class=\"line\">    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class=\"line\">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这样，新添加的acticity就是启动页了。</p>\n<h2 id=\"新建页面布局文件\"><a href=\"#新建页面布局文件\" class=\"headerlink\" title=\"新建页面布局文件\"></a>新建页面布局文件</h2><p>虽然已经有了一个空的Activity，但是还没有东西可以显示。<br>在res文件夹立新建一个layout文件夹，用来存放布局文件，然后新建一个Layout resources file，是一个xml格式的文件，在这里写布局：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button</span><br><span class=\"line\">        android:id=&quot;@+id/button_1&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:text=&quot;Button 1&quot;</span><br><span class=\"line\">        /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>添加了一个button，然后在标签里写的id是这个空间的唯一标示，layout_width和layout_height是控件的大小（match_parent是屏幕宽度，wrap_content是刚好能容纳控件内容的高度），text就是button上面显示的文字</p>\n<h2 id=\"在Activity里操作布局里面的控件\"><a href=\"#在Activity里操作布局里面的控件\" class=\"headerlink\" title=\"在Activity里操作布局里面的控件\"></a>在Activity里操作布局里面的控件</h2><p>刚才已经建好了一个button，我们可以在Activity里面操作这个控件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContentView(R.layout.first_layout);</span><br><span class=\"line\">Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class=\"line\">button1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">    public void onClick(View view) &#123;</span><br><span class=\"line\">    Toast.makeText(FirstActivity.this,&quot;You Clicked Me!&quot;,Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>第一行的setContentView是把布局文件添加到当前Activity里面，R.layout.xxx是在引用res里面的layout文件夹里面的资源文件。</li>\n<li>第二行从布局文件里面获取一个View，然后显式转换为button类型赋值给一个button类的实例变量。</li>\n<li>第三行setOnClickListener是对button实例变量调用的方法（监听器），传入的一个参数为新建的View.onClickListener，然后对这个setOnClickListener方法进行覆写。</li>\n<li>后面的onClick是button监听器里的默认会执行的单击方法，所以在这个方法里写Toast</li>\n<li>Toast.makeText（）是一个静态方法，传入（上下文，文本内容，显示时长），然后调用show（）方法显示出来</li>\n</ul>\n<h3 id=\"Activity的基本使用\"><a href=\"#Activity的基本使用\" class=\"headerlink\" title=\"Activity的基本使用\"></a>Activity的基本使用</h3><p>刚才已经使用了Toast，还有一个常用的控件Menu</p>\n<h4 id=\"Menu\"><a href=\"#Menu\" class=\"headerlink\" title=\"Menu\"></a>Menu</h4><ul>\n<li>首先在res文件夹下新建文件夹menu文件夹，再在menu文件夹下新建Menu resource file</li>\n<li>在这个文件里添加：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;item</span><br><span class=\"line\">      android:id=&quot;@+id/add_item&quot;</span><br><span class=\"line\">      android:title=&quot;Add&quot;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">  &lt;item</span><br><span class=\"line\">      android:id=&quot;@+id/remove_item&quot;</span><br><span class=\"line\">      android:title=&quot;Remove&quot;</span><br><span class=\"line\">      /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在Menu的布局里添加了两个item，分别设置它们的id和title</p>\n<ul>\n<li><p>回到Activity.java的文件里，重写onCreateOptionsMenu（）方法，先getMenuInflater（）获取到一个菜单展开器，然后调用inflate把资源文件里的menu展开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">   public boolean onCreateOptionsMenu(Menu menu) &#123;</span><br><span class=\"line\">       getMenuInflater().inflate(R.menu.main,menu);</span><br><span class=\"line\">       return true;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回值表示是否允许创建的菜单显示出来<br>上面的代码能够将menu显示出来，如何响应按钮的item?</p>\n</li>\n<li><p>覆写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onOptionsItemSelected(MenuItem item) &#123;</span><br><span class=\"line\">    switch (item.getItemId())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        case R.id.add_item:</span><br><span class=\"line\">        \tToast.makeText(FirstActivity.this,&quot;You clicked item named add&quot;,Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case R.id.remove_item:</span><br><span class=\"line\">            Toast.makeText(FirstActivity.this,&quot;You clicked item named remove&quot;,Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>通过switch判断不同的item的id去做不同的动作响应</p>\n<h4 id=\"Intent\"><a href=\"#Intent\" class=\"headerlink\" title=\"Intent\"></a>Intent</h4><p>Intent不仅是各组件中交互的重要方式，可以指明当前组件想要执行的动作，还可以在组件之间传递数据。<br><strong> Intent 一般可以用于启动活动、启动服务、发送广播等场景 </strong></p>\n<h5 id=\"显式Intent\"><a href=\"#显式Intent\" class=\"headerlink\" title=\"显式Intent\"></a>显式Intent</h5><ul>\n<li>在某一个触发事件里可以创建一个Intent的实例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = new Intent(FirstActivity.this , SecondActivity.class);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>第一个参数提供启动活动的上下文，第二个参数是目标活动</p>\n<ul>\n<li>Activity类提供了一个方法，专门用于启动活动，接受一个intent参数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startActivity(intent);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>至于如何返回（即销毁当前的Activity），可以手动绑定方法去执行finish（），也可以是手机上的返回键</p>\n<h5 id=\"隐式Intent\"><a href=\"#隐式Intent\" class=\"headerlink\" title=\"隐式Intent\"></a>隐式Intent</h5><p>隐式的用法是通过AndroidManifest.xml中的Activity的配置相关信息，然后在Activity.java中调用符合配置的Activity，而不是直接指定某个Activity的类。<br>下面举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=&quot;.SecondActivity&quot;&gt;</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">    \t&lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot;/&gt;</span><br><span class=\"line\">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后在FirstAcitvity.java里面写的和显式的不同：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent1 = new Intent(&quot;com.example.activitytest.ACTION_START&quot;);</span><br><span class=\"line\">startActivity(intent1);</span><br></pre></td></tr></table></figure></p>\n<p>直接写为Activity支持的action名。<br><strong> 另外，每个intent只可以对应一个action，但是可以对应多个category，只有当category和action同时满足范围的时候才可以正常调用，否则会崩溃并抛出异常 </strong></p>\n<p>其实还有别的隐式intent的用法，比如跨应用唤起某个页面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent1 = new Intent(Intent.ACTION_VIEW);</span><br><span class=\"line\">intent1.setData(Uri.parse(&quot;http://google.com&quot;));</span><br><span class=\"line\">startActivity(intent1);</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以唤起浏览器并打开<a href=\"http://google.com\" target=\"_blank\" rel=\"noopener\">http://google.com</a><br>ACTION_VIEW是安卓系统内置的动作，然后Uri.parse（）是将字符串解析为Uri对象，最后用setDdata（）把Uri对象传入。</p>\n<p>除此之外，还可以在<intent-filter>中配置 data 标签，实现更精确地响应：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=&quot;.SecondActivity&quot;&gt;</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class=\"line\">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class=\"line\">        &lt;data android:scheme=&quot;&quot;/&gt;</span><br><span class=\"line\">        &lt;data android:host=&quot;&quot;/&gt;</span><br><span class=\"line\">        &lt;data android:port=&quot;&quot;/&gt;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></intent-filter></p>\n<p>这里的action的值配置为；鹅Intent.ACTION_VIEW的常量值，同时data字段也配置了可以响应的协议类型等字段，假如我们设置的scheme字段是http，那么用户在打开一个http网页的时候，会提示用户选择我们的这个Activity打开。</p>\n<p>安卓系统内部其实有很多中intent.ACTION的类型，有唤起地理位置界面的、拨号的等等。</p>\n<h4 id=\"页面间传值\"><a href=\"#页面间传值\" class=\"headerlink\" title=\"页面间传值\"></a>页面间传值</h4><p>Intent不仅可以用来启动Activity，还可以在页面跳转同时传值</p>\n<p>Intent提供了一系列对putExtra（）的重载，可以在调度Activity的同时把数据暂存在Intent中，到达了另外一个Activity的时候，再由目的Activity把数据从Intent中取出就可以了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intent2.putExtra(&quot;string_from_firstActivity&quot;, &quot;hello second&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>上面的这是设值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = getIntent();</span><br><span class=\"line\">Log.v(&quot;SecondActivty&quot;,intent.getStringExtra(&quot;string_from_firstActivity&quot;));</span><br></pre></td></tr></table></figure></p>\n<p>这是取值</p>\n<p>这种适合用来做单向正向传值。除了这种之外还有反向传值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startActivityForResult(intent2,1);</span><br></pre></td></tr></table></figure></p>\n<p>这个方法能够期望SecondActivity销毁时能够返回结果给FirstActivity。<br>然后需要在FirstActivity中覆写onActivityResult方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class=\"line\">    switch (requestCode)&#123;</span><br><span class=\"line\">        case 1:</span><br><span class=\"line\">            if (resultCode==RESULT_OK)&#123;</span><br><span class=\"line\">                Log.v(&quot;FirstActivity&quot;,data.getStringExtra(&quot;back_to_first&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过对Intent data调用getStringExtra方法得到返回回来的数据。、<br>requestCode是前面写的数字。用来标示从FirstACtivity跳转到的不同Activity<br>resultCode是SecondActivity返回数据时传入的参数。用来标示是否处理成功。<br>data就是携带的数据。</p>\n<p>对于SecondActivity来说，只要设值，然后调用setResult（）就可以了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intent.putExtra(&quot;back_to_first&quot;,&quot;hello,first&quot;);</span><br><span class=\"line\">setResult(RESULT_OK,intent);</span><br></pre></td></tr></table></figure></p>\n<p>除此之外，还可以直接监听到返回键的事件来处理响应的事件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onBackPressed() &#123;</span><br><span class=\"line\">Toast.makeText(SecondActivity.this,&quot;onBackPassed&quot;,Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Activity的生命周期\"><a href=\"#Activity的生命周期\" class=\"headerlink\" title=\"Activity的生命周期\"></a>Activity的生命周期</h3><h4 id=\"返回栈\"><a href=\"#返回栈\" class=\"headerlink\" title=\"返回栈\"></a>返回栈</h4><p>Android也是用栈的方式去管理Activity，用Task去管理，返回栈是BackStack</p>\n<h4 id=\"活动的四个状态\"><a href=\"#活动的四个状态\" class=\"headerlink\" title=\"活动的四个状态\"></a>活动的四个状态</h4><p>每个Activity有四种状态：</p>\n<h5 id=\"运行状态\"><a href=\"#运行状态\" class=\"headerlink\" title=\"运行状态\"></a>运行状态</h5><p>最栈顶的Activity就是处于运行状态的，系统最不喜欢回收这种状态的Activity</p>\n<h5 id=\"暂停状态\"><a href=\"#暂停状态\" class=\"headerlink\" title=\"暂停状态\"></a>暂停状态</h5><p>因为并不是所有的Activity都是全屏状态，所以会存在一个Activity是可见的，但是上面有一个小的Activity部分遮挡，这样一来，后面的Activity既不在栈顶（非运行态），又是可见的。这种状态就是暂停状态。一般系统也是不考虑去回收这种状态的Activity，只有在内存极低的时候才有可能被系统回收。</p>\n<h5 id=\"停止状态\"><a href=\"#停止状态\" class=\"headerlink\" title=\"停止状态\"></a>停止状态</h5><p>如果一个活动在栈中，并且完全不可见的时候，就处于停止状态，系统会保存Activity的状态和成员变量。这个时候它并不是完全可靠的，当内存不足的时候就可能被系统回收。</p>\n<h5 id=\"销毁状态\"><a href=\"#销毁状态\" class=\"headerlink\" title=\"销毁状态\"></a>销毁状态</h5><p>如果一个Activity从返回栈中被移除掉的话，它就会成为销毁状态，系统最优先回收这种状态的Activity。</p>\n<h4 id=\"活动在三种生存期的七个回调方法\"><a href=\"#活动在三种生存期的七个回调方法\" class=\"headerlink\" title=\"活动在三种生存期的七个回调方法\"></a>活动在三种生存期的七个回调方法</h4><h5 id=\"完整生存期\"><a href=\"#完整生存期\" class=\"headerlink\" title=\"完整生存期\"></a>完整生存期</h5><p>从onCreate（）开始到onDestory（）结束</p>\n<h6 id=\"onCreate（）\"><a href=\"#onCreate（）\" class=\"headerlink\" title=\"onCreate（）\"></a>onCreate（）</h6><p>每个Activity中都重写这个方法，它会在每个Activity创建的时候调用，所以这个方法中应该完成一些例如加载布局文件、绑定事件等初始化操作。</p>\n<h6 id=\"onDestory（）\"><a href=\"#onDestory（）\" class=\"headerlink\" title=\"onDestory（）\"></a>onDestory（）</h6><p>这个方法在Activity被销毁之前调用，调用完成之后Activity就进入销毁状态</p>\n<h5 id=\"可见生存期\"><a href=\"#可见生存期\" class=\"headerlink\" title=\"可见生存期\"></a>可见生存期</h5><p>Activity从onStart（）到onStop（）之间的部分就是可见生存期。可见生存期的可见二字就意味着Activity是显示的，就算不能交互，也要算在内。<br>开发者就可以通过在onStart（）方法中加载资源，在onStop（）方法中释放资源，来保证停止状态的Activity不会占用过多的资源。</p>\n<h6 id=\"onStart（）\"><a href=\"#onStart（）\" class=\"headerlink\" title=\"onStart（）\"></a>onStart（）</h6><p>这个方法在Activity由不可见变成可见的时候调用</p>\n<h6 id=\"onStop（）\"><a href=\"#onStop（）\" class=\"headerlink\" title=\"onStop（）\"></a>onStop（）</h6><p>相反的，当Activity变得<strong>完全</strong>不可见的时候调用</p>\n<h5 id=\"前台生存期\"><a href=\"#前台生存期\" class=\"headerlink\" title=\"前台生存期\"></a>前台生存期</h5><p>在onResume（）方法和onPause（）方法之间的Activity就是前台生存期。这时候Activity子那个是处于运行状态，可以与用户交互</p>\n<h6 id=\"onResume（）\"><a href=\"#onResume（）\" class=\"headerlink\" title=\"onResume（）\"></a>onResume（）</h6><p>这个方法是Activity已经准备好和用户交互的时候调用。这个时候的Activity在栈顶并且一定是运行状态。</p>\n<h6 id=\"onPause（）\"><a href=\"#onPause（）\" class=\"headerlink\" title=\"onPause（）\"></a>onPause（）</h6><p>这个方法是系统准备去启动某个Activity或者恢复到某个Activity的时候调用，这个方法中一般用于把一些消耗系统资源的释放掉，或者保存一些关键数据，但是这个方法里执行的不能是一些耗时操作。<br><strong>如果是一个对话框出现在某个Activity上面的时候，如果没有完全遮挡，那么会调用onPause（）而不是onStop（）</strong></p>\n<p>除此之外，还有一个独立在这三种生存期之外的回调方法：</p>\n<h6 id=\"onRestart（）\"><a href=\"#onRestart（）\" class=\"headerlink\" title=\"onRestart（）\"></a>onRestart（）</h6><p>这个方法是Activity在由停止状态重新变成运行状态的时候调用的。</p>\n<p>下面附一张Activity的生命周期图（书上原图）：<br><img src=\"https://s1.ax1x.com/2018/06/07/CH124K.jpg\" alt=\"Activity的生命周期\"></p>\n<p>下面做一个测试用于FirstActivity到SecondActivity然后再跳转回来的一个状态跟踪打印：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">06-07 14:45:16.457 16551-16551/com.example.ifan.activitytest V/life: onCreate is called</span><br><span class=\"line\">06-07 14:45:16.736 16551-16551/com.example.ifan.activitytest V/life: onStart is called</span><br><span class=\"line\">06-07 14:45:16.742 16551-16551/com.example.ifan.activitytest V/life: onResume is called</span><br><span class=\"line\">06-07 14:45:29.731 16551-16551/com.example.ifan.activitytest V/life: onPause is called</span><br><span class=\"line\">06-07 14:45:30.536 16551-16551/com.example.ifan.activitytest V/life: onStop is called</span><br><span class=\"line\">06-07 14:46:24.588 16551-16551/com.example.ifan.activitytest V/life: onRestart is called</span><br><span class=\"line\">06-07 14:46:24.590 16551-16551/com.example.ifan.activitytest V/life: onStart is called</span><br><span class=\"line\">06-07 14:46:24.591 16551-16551/com.example.ifan.activitytest V/life: onResume is called</span><br><span class=\"line\">06-07 14:46:41.625 16551-16551/com.example.ifan.activitytest V/life: onPause is called</span><br><span class=\"line\">06-07 14:46:42.003 16551-16551/com.example.ifan.activitytest V/life: onStop is called</span><br><span class=\"line\">06-07 14:46:42.004 16551-16551/com.example.ifan.activitytest V/life: onDestory is called</span><br></pre></td></tr></table></figure></p>\n<p>可以看出来从FirstActivity到SecondActivity的时候，经过了onPause（）和onStop（）的方法的调用；从SecondActivity回到FirstActivity的时候，经过了onRestart（）、onStart（）和onResume（）的调用</p>\n<p>再做一个部分遮挡的例子：SecondActivity是一个对话框式的Activity时候，从FirstActivity到SecondActivity打印出来的是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">06-07 14:56:10.743 17244-17244/com.example.ifan.activitytest V/life: onCreate is called</span><br><span class=\"line\">06-07 14:56:11.011 17244-17244/com.example.ifan.activitytest V/life: onStart is called</span><br><span class=\"line\">06-07 14:56:11.019 17244-17244/com.example.ifan.activitytest V/life: onResume is called</span><br><span class=\"line\">06-07 14:56:14.760 17244-17244/com.example.ifan.activitytest V/life: onPause is called</span><br><span class=\"line\">06-07 14:56:24.734 17244-17244/com.example.ifan.activitytest V/life: onResume is called</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这种情况少了onStop（）、onRestart（）和onStart（）的调用过程。</p>\n<p>另外还可以看到在按返回键的时候的调用过程如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">06-07 15:22:38.832 18596-18596/com.example.ifan.activitytest V/life: onPause is called</span><br><span class=\"line\">06-07 15:22:39.261 18596-18596/com.example.ifan.activitytest V/life: onStop is called</span><br><span class=\"line\">06-07 15:22:39.262 18596-18596/com.example.ifan.activitytest V/life: onDestory is called</span><br></pre></td></tr></table></figure></p>\n<p>看到有博客说按home、返回、在后台杀进程的调用过程会有差异。<br>另外在onStop（）的覆写中如果不写对父类方法的调用会导致Activity直接被回收，下一次还需要重新create。也很好理解，因为不调用父类方法的话其实就少了状态、变量的保存过程，所以会出现这样的结果。</p>\n<h4 id=\"Activity在停止状态被回收的情况\"><a href=\"#Activity在停止状态被回收的情况\" class=\"headerlink\" title=\"Activity在停止状态被回收的情况\"></a>Activity在停止状态被回收的情况</h4><p>Activity在活动状态是可能被回收的，也就是可能存在以下场景：<br>A跳转到B，然后A进入停止状态，但是A被销毁了，这时候从B回来就不会调用onRestart（）方法，而是调用onCreate（）方法。这时候因为A在onStop（）方法里写入的数据也随着之前停止状态的Activity被销毁了，所以这时候从B回去之后看到的A就是一个新创建的A了。<br>怎么解决呢？<br>Activity提供了一个onSaveInstanceState（）的回调方法，这个方法能够保证在Activity被Destory之前一定会被执行。所以我们可以在在这里保存A的Stop数据。</p>\n<p>这个onSaveInstanceState（）携带一个Bundle类型的参数，Bundle提供了一系列用于保存数据的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class=\"line\">\toutState.putString(&quot;FirstActivityDataOut&quot;,&quot;help~&quot;);</span><br><span class=\"line\">    super.onSaveInstanceState(outState);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后在onCreate（）方法中携带的Bundle类型的参数里获取这个Bundle中的数据就可以了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(savedInstanceState.getString(&quot;FirstActivityDataOut&quot;)!=null)</span><br><span class=\"line\">\tLog.v(&quot;FirstActivityDataOut&quot;,savedInstanceState.getString(&quot;FirstActivityDataOut&quot;));</span><br></pre></td></tr></table></figure></p>\n<p>除此之外，在Intent的使用中也可以使用Bundle来传值。</p>\n<h3 id=\"Activity的四种启动模式\"><a href=\"#Activity的四种启动模式\" class=\"headerlink\" title=\"Activity的四种启动模式\"></a>Activity的四种启动模式</h3><p>四种启动模式是在AndroidManifest.xml里面的Activity对应的标签里面指定的。</p>\n<h4 id=\"standard\"><a href=\"#standard\" class=\"headerlink\" title=\"standard\"></a>standard</h4><p>标准模式，也就是默认模式，在一个Activity建好的初始设置就是这个，每次启动一个新的Activity的时候，它就在返回栈中入栈，处于栈顶位置。这样的话，当此Activity递归地跳转到本类的Activity，栈中也会不停地新建、入栈。</p>\n<h4 id=\"singleTop\"><a href=\"#singleTop\" class=\"headerlink\" title=\"singleTop\"></a>singleTop</h4><p>栈顶单例，顾名思义，处于栈顶的Activity在进行上面的操作的时候，会被直接使用本activity，而不是不断新建、入栈。但是前提条件必须是：<strong> 当前的Activity必须处于栈顶。</strong></p>\n<p><strong>一个有意思的现象是使用startActivityForResult（）去启动这个singleTop的Activity的时候，是无视它的singleTop模式的，google这样设计的原因可能是考虑到回调的内容没有接受者</strong></p>\n<h4 id=\"singleTask\"><a href=\"#singleTask\" class=\"headerlink\" title=\"singleTask\"></a>singleTask</h4><p>上一种的singleTop是只检查栈顶，避免了单个Activity的递归启动。除此之外还可以让某个Activity在整个返回栈中成为唯一的一个Activity。<br>例如：</p>\n<p>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;B</p>\n<p>如果B的启动类型为singleTask，那么在从E到B的时候实际上是回到了最前面B，而且最前面的B之后的都会被从栈里弹出。</p>\n<h4 id=\"singleInstance\"><a href=\"#singleInstance\" class=\"headerlink\" title=\"singleInstance\"></a>singleInstance</h4><p>这个是不同于上面的三种的一种特殊的启动方式——这种启动模式的Activity会启用一个另外的返回栈去管理这个活动。应用场景就是当别的程序要共享访问这个Activity，其他的三种模式就不能完成了。（每个程序都有自己的返回栈，如果访问了这个Activity，那必定是在当前的程序和别的那个程序里面都会分别加入一个新建的这个Activity，那就是不同的实例了，达不到共享的目的。）</p>\n<p>而这个singleInstance就是解决这种情况的——<strong>它会连同Activity一块返回一个单独的返回栈，然后任何一个应用来访问这个Activity，都公用同一个返回栈。</strong><br>例如：</p>\n<p>A -&gt; B -&gt; C</p>\n<p>如果B的启动模式为singleInstance的话，实际的栈是这样的：<br>A — C<br>B<br>第一个栈是本程序自己的栈，因为A、C都是普通的模式，所以都默认入栈到程序自己的默认栈里了。而第二个栈就是随着B一同创建的新栈，这个栈是所有程序调用时公用的。</p>\n<p>所以返回键连续按下之后，先是C所在的栈先出栈C，然后是A，因为是同一个栈，最后才是B，因为程序自己所在的栈已经空了，就轮到B所在的栈出栈了。</p>\n<h3 id=\"一些实践\"><a href=\"#一些实践\" class=\"headerlink\" title=\"一些实践\"></a>一些实践</h3><p>了解了Activity的基础知识后，这里还有一些关于Activity的应用技巧。</p>\n<h4 id=\"获知当前所处Activity\"><a href=\"#获知当前所处Activity\" class=\"headerlink\" title=\"获知当前所处Activity\"></a>获知当前所处Activity</h4><p>当拿到别人的代码时候，可能就不方便知道当前的界面是处于哪一个Activity了，一个个对应也很麻烦，所以有一个办法去获知当前所处的Activity：<br>使用间接继承的原理，新建一个中间类BaseActivity继承自AppCompatActivity，在onCreate（）的方法中扩展一个打印当前类的语句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Log.v(&quot;BaseActivity&quot;,getClass().getSimpleName());</span><br></pre></td></tr></table></figure></p>\n<p>然后让所有的Activity都继承自这个BaseActivity，然后就可以显示出当前类的类名了。<br><strong>但是同时也有一个让人没有办法接受的缺点：难道我拿到别人的代码要把所有的Activity的继承类都修改一遍么？！</strong></p>\n<h4 id=\"退回到任意Activity\"><a href=\"#退回到任意Activity\" class=\"headerlink\" title=\"退回到任意Activity\"></a>退回到任意Activity</h4><p>用一个List去手动维护一个返回栈，从而能够对这个返回栈的Activity手动操控，就可以返回到任意Activity：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static boolean backToIndexOfStack(int index)&#123;</span><br><span class=\"line\">        if (index&gt;=activityList.size())&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = activityList.size()-1;i &gt; index;i--)&#123;</span><br><span class=\"line\">            activityList.get(i).finish();</span><br><span class=\"line\">            activityList.remove(activityList.size()-1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>index从0开始，这里依次从栈里finsh（）掉Activity，并且从手动维护的栈中remove掉。</p>\n<h4 id=\"启动Activity的最佳写法\"><a href=\"#启动Activity的最佳写法\" class=\"headerlink\" title=\"启动Activity的最佳写法\"></a>启动Activity的最佳写法</h4><p>在多人协作开发的时候，协定传参总是一个要考虑的点。可以在启动Activity的时候封装一个activityStart（）方法，专门用来构建Intent，这样一来参数就在这个activityStart（）方法的参数列表里体现出来了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void activityStart(Context context,String firstName,String lastName)&#123;</span><br><span class=\"line\">       Intent intent = new Intent(context,SecondActivity.class);</span><br><span class=\"line\">       intent.putExtra(&quot;param1&quot;,&quot;hello&quot;);</span><br><span class=\"line\">       intent.putExtra(&quot;param2&quot;,&quot;there&quot;);</span><br><span class=\"line\">       startActivity(intent);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Android-UI的开发\"><a href=\"#Android-UI的开发\" class=\"headerlink\" title=\"Android UI的开发\"></a>Android UI的开发</h1><p>前面的一节是从探究Activity的角度去了解Activity的用法和特点。接下来就是学习如何编写UI，结合Activity去编写完整的UI已经交互逻辑。</p>\n<h2 id=\"常用控件的使用\"><a href=\"#常用控件的使用\" class=\"headerlink\" title=\"常用控件的使用\"></a>常用控件的使用</h2><h3 id=\"TextView\"><a href=\"#TextView\" class=\"headerlink\" title=\"TextView\"></a>TextView</h3><p>这个控件类似于iOS里面的UILabel，用于展示文字信息。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:id=&quot;@+id/text_view&quot;</span><br><span class=\"line\">    android:text=&quot;This is a TextView&quot;</span><br><span class=\"line\">    android:gravity=&quot;center&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>android:layout_width、android:layout_height这两个属性是所有控件里面都有的，就像iOS里面的Frame一样用来设置大小，但是这个只是表示了大小并不明位置。<br>后面的值可选三种值：</p>\n<ul>\n<li>match_parent：表示让当前的控件和父布局的大小一样大。</li>\n<li>fill_parent：和match_parent的意义一样，现在官方推荐使用match_parent。</li>\n<li>wrap_content：表示让控件的大小刚好能包含控件中展示的内容，控件大小由控件内容决定。</li>\n</ul>\n<p>当然了，也可以手动指定固定值作为width、height的值，但是这样会导致适配出现问题。</p>\n<p><strong>gravity</strong>：指定的是对齐方式，和iOS里TextAlignment类似。可选的有top、bottom、left、right、center。（center是默认指定”center_vertical|center_horizontal”的，表示垂直和水平方向都居中）</p>\n<p><strong>textSize</strong>：指定文字大小。在Android里字体大小是使用sp作单位的。其实在打出24这个将要指定大小的数字的时候，自动补全了几个选项：dp、in、mm、pt、px、sp。好奇这几个有什么区别。之后我会另外开一个文去写这个的。<br><strong>textColor</strong>：#+6位16进制数表示颜色。</p>\n<p>更多的使用细节去查文档就好。</p>\n<h3 id=\"Button\"><a href=\"#Button\" class=\"headerlink\" title=\"Button\"></a>Button</h3><p>它在布局文件里的写法大同小异，它有一个textAllCaps属性，如果不设置为false的话默认为true就会把所有出现的字母都变为大写的。<br>然后就可以在Activity的类里面去获取这个控件了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class=\"line\">      button1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">          @Override</span><br><span class=\"line\">          public void onClick(View view) &#123;</span><br><span class=\"line\">              //点击之后的代码</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这是一种类似闭包的方式，其实还有一种通过实现接口的方式，需要在本类的声明部分写明实现哪一个接口，然后在设置button的监听者为本类，然后覆写onClick（）方法，方法内部通过判断id来分别实现不同button的点击事件。</p>\n<h3 id=\"EditText\"><a href=\"#EditText\" class=\"headerlink\" title=\"EditText\"></a>EditText</h3><p>这个控件实际上就是iOS里的TextView，支持多行输入和排版。<br>特别的属性：</p>\n<p><strong>hint</strong>：这一个是iOS里面的TextView里面没有的类似于placeHolder的设置。</p>\n<p><strong>maxLines</strong>：EditText如果高度不是定值，就会随着输入内容的增多而拉长。如果指定了这个属性，则EditText不会被拉长，但是内容视图的长度还是会被拉长。而且，它只是限制了EditText这个控件的最大显示行数，并没有限制内容的行数。</p>\n<p>另外，还可以在Activity里面获取到EditText里面的文字信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EditText editText = findViewById(R.id.edit_text);</span><br><span class=\"line\">editText.getText().toString()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ImageView\"><a href=\"#ImageView\" class=\"headerlink\" title=\"ImageView\"></a>ImageView</h3><p>这个倒是和iOS里的UIImageView差别不大,不过现在资源大多都同意放在res目录下的drawable目录下，但是这个目录没有制定具体的分辨率，所以书上的建议是新建一个drawable-xhdpi文件夹，然后把图片放进去。</p>\n<p>对于图片的设置有两种方法，一种是直接写在布局文件里，一种是在Activity类里去修改。这两种可以同时使用。</p>\n<p><strong>有意思的是，Android的图片文件并不能带大写字母，不然会报错说只支持小写字母、数字和下划线。</strong></p>\n<p>同时对文件名里带“.”的文件也不能支持，会报错。</p>\n<p><strong>另外，在一开始设置的height为wrap_content其实也没有起作用。</strong></p>\n<h3 id=\"ProgressBar\"><a href=\"#ProgressBar\" class=\"headerlink\" title=\"ProgressBar\"></a>ProgressBar</h3><p>显示一个进度条（默认样式是一个不断循环转动的圈圈）。布局文件里写的是默认可见的（当然也可以手动指定为其他值），就可以在Activity里去判断它当前是否是可见的，如果是可见的，可以设为不可见。</p>\n<p>在布局文件里设置:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:visibility=&quot;invisible&quot;</span><br></pre></td></tr></table></figure></p>\n<p>在Activity里设置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (findViewById(R.id.progress_bar).getVisibility() ==View.VISIBLE)&#123;</span><br><span class=\"line\">          findViewById(R.id.progress_bar).setVisibility(View.INVISIBLE);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于ProgressBar来说有三种可见选项：visible、invisible、gone</p>\n<p><strong>visible</strong>：可见的。</p>\n<p><strong>invisible</strong>：不可见，但是还占据着原来的位置和大小，可以理解为透明状态。</p>\n<p><strong>gone</strong>：不仅是不可见的，而且完全从屏幕上消失。</p>\n<p>除了上面的那种圈圈的样式，还有一种样式是条状的。可以通过在布局文件里设置style为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">style=&quot;?android:progressBarStyleHorizontal&quot;</span><br></pre></td></tr></table></figure></p>\n<p>对于这种样式，可以设置一个最大值，以便在Activity中动态的改变进度条的状态。</p>\n<p>布局文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android:max=&quot;100&quot;</span><br></pre></td></tr></table></figure></p>\n<p>Activity：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProgressBar progressBar = findViewById(R.id.progress_bar);</span><br><span class=\"line\">progressBar.setProgress(progressBar.getProgress()+10);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AlertDialog\"><a href=\"#AlertDialog\" class=\"headerlink\" title=\"AlertDialog\"></a>AlertDialog</h3><p>弹出一个对话框，一般用于警告用户，下方有三个按钮可以响应用户的点击事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AlertDialog.Builder dialog = new AlertDialog.Builder(FirstActivity.this);</span><br><span class=\"line\">dialog.setTitle(&quot;this will change image&quot;);</span><br><span class=\"line\">dialog.setMessage(&quot;this is very importent&quot;);</span><br><span class=\"line\">dialog.setCancelable(true);</span><br><span class=\"line\"></span><br><span class=\"line\">dialog.setNeutralButton(&quot;NeutralButton&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onClick(DialogInterface dialogInterface, int i) &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dialog.setNegativeButton(&quot;Cancle&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onClick(DialogInterface dialogInterface, int i) &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">    public void onClick(DialogInterface dialogInterface, int i) &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dialog.show();</span><br></pre></td></tr></table></figure></p>\n<p>可以在示例代码中看到，使用一般是三个步骤，先用Builder新建一个AlertDialog实例出来（指定Activity），然后设置标题、信息内容、可否在点击别的空白处取消这个AlertDialog。</p>\n<p>然后分别设置三个按钮（从左到右依次为NeutralButton、NegativeButton、PositiveButton）的点击回调事件。</p>\n<h3 id=\"ProgressDialog\"><a href=\"#ProgressDialog\" class=\"headerlink\" title=\"ProgressDialog\"></a>ProgressDialog</h3><p>和上面的那个AlertDialog很类似，也可选两种样式——转圈圈或者一个条状的进度条。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProgressDialog progressDialog = new ProgressDialog(FirstActivity.this);</span><br><span class=\"line\">progressDialog.setTitle(&quot;progressDialog&quot;);</span><br><span class=\"line\">progressDialog.setMessage(&quot;this is a progressDialog&quot;);</span><br><span class=\"line\">progressDialog.setCancelable(true);</span><br><span class=\"line\">progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span><br><span class=\"line\">progressDialog.setMax(256);</span><br><span class=\"line\">progressDialog.show();</span><br></pre></td></tr></table></figure></p>\n<p>这种的是和前面的ProgressBar是一样的，可以设置最大的长度、动态改变进度状态。<br>默认是转圈的样式。</p>\n<p><strong>需要注意的是，如果这个也设置为不允许失焦取消，那不知道何时会结束的progressDialog就会导致当前应用卡死，无法继续交互。如果设置为允许失焦消失，那就要处理好消失的逻辑，是否是用户选择取消当前进度？如果误操作怎么处理？如果是取消应该处理当前进度的任务？</strong></p>\n<h2 id=\"四种基本布局\"><a href=\"#四种基本布局\" class=\"headerlink\" title=\"四种基本布局\"></a>四种基本布局</h2><p>布局是一种可用于放置很多控件的容器。布局是可以嵌套的。可以通过布局的嵌套来完成一些复杂的布局效果。这一部分将用一个新的项目去学习和练习。</p>\n<h3 id=\"线性布局-LinearLayout\"><a href=\"#线性布局-LinearLayout\" class=\"headerlink\" title=\"线性布局-LinearLayout\"></a>线性布局-LinearLayout</h3><p>是一种非常常用的布局，这种布局会将内部包含的控件在线性方向上依次排列。<br>还记得最开始接触布局文件么？那个就是默认的线性布局（因为是根元素），有横向和竖向两种。</p>\n<p>可以通过orientation来指定线性到底是竖向还是横向。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:orientation=&quot;horizontal&quot;</span><br><span class=\"line\">android:orientation=&quot;vertical&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>需要注意的是，这时候控件的size就要设置合理。比如水平线性布局的时候，控件的宽度就不能match_parent了</strong></p>\n<p>layout的几个重要属性：</p>\n<h4 id=\"layout-gravity\"><a href=\"#layout-gravity\" class=\"headerlink\" title=\"layout_gravity\"></a>layout_gravity</h4><p>和gravity属性有点相似，但是其实完全没有关系。</p>\n<p><strong>gravity</strong>属性是指定某个控件内部的内容（如文字）在控件内是靠向哪一边的。</p>\n<p><strong>gravity_layout</strong>是指定当前控件在父布局中的位置是在如何对齐的。<br>同样的，在父布局已经处于某种方式的时候要做合理的设置，例如：父布局是水平布局（horizontal），只有设置控件在竖向位置的对齐（top、center、bottom等）才会生效。</p>\n<h4 id=\"layout-weight\"><a href=\"#layout-weight\" class=\"headerlink\" title=\"layout_weight\"></a>layout_weight</h4><p>这个属性是用比例的方式去指定控件的大小的，有一些自动布局的感觉。<br>需要区别的是控件的width属性，虽然可能长的像，但是二者是完全不同的：</p>\n<p><strong>width</strong>：用数值或者一些定义过的常量或者宏指定宽度。</p>\n<p><strong>weight</strong>：用比例去指定当前控件在水平方向上占用多少比例。</p>\n<p>当weight存在的时候，width是不生效的，也就是随便写多少都没用，但是比较规范的写法是写为0dp。（dp是Android里用于指定控件大小、间距的单位）</p>\n<p>然后weight里写的是比例，如果控件1里面写的是1，另一个控件里写的2，那么就表示两个控件的宽度比例是1:2。</p>\n<p>有的控件里没有写weight，只写了width为wrap，这时候就还是保证控件的宽度刚够包含控件自己的内容。</p>\n<p>如果控件1写了weight的值为1，控件2没有写weight但是写了width为wrap，那就是控件1尽量宽，然后控件2的宽度刚够包含自己的内容。</p>\n<h3 id=\"相对布局：RelativeLayout\"><a href=\"#相对布局：RelativeLayout\" class=\"headerlink\" title=\"相对布局：RelativeLayout\"></a>相对布局：RelativeLayout</h3><p>这种布局也是非常常用的布局，这种布局更随意一些，它可以用相对定位的方式让控件出现在布局的任意位置。</p>\n<p>正因如此，相对布局的属性就多了一些，但是好在都是有规律的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button</span><br><span class=\"line\">       android:text=&quot;hello3&quot;</span><br><span class=\"line\">       android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">       android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">       android:layout_alignParentEnd=&quot;true&quot;</span><br><span class=\"line\">       android:layout_alignParentTop=&quot;true&quot;</span><br><span class=\"line\">       /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，里面的位置相关的代码里面有Parent字段，也就是说，这些控件是相对于父布局来定位的。当然了也可以不依据父布局进行定位：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button</span><br><span class=\"line\">       android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">       android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">       android:layout_above=&quot;@+id/text_view&quot;</span><br><span class=\"line\">       android:layout_toLeftOf=&quot;@+id/text_view&quot;</span><br><span class=\"line\">       android:text=&quot;hello1&quot;</span><br><span class=\"line\">       /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>可以通过id去选定相对的参考控件，去选择相对位置。<br><strong>但是只能去参考前面出现过的控件，不然就找不到id了。</strong></p>\n<p>另外还有layout_alignLeft表示和目标控件左对齐，其他的其他方向都是一样的。</p>\n<h3 id=\"帧布局-FrameLayout\"><a href=\"#帧布局-FrameLayout\" class=\"headerlink\" title=\"帧布局 FrameLayout\"></a>帧布局 FrameLayout</h3><p>这种布局非常简单，相比前面的两种来说，使用场景也较少。</p>\n<p>这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角。多个控件按照默认方式放置会重叠在一起。</p>\n<p>当然，也可以用layout_gravity属性去指定控件的对齐方式，但是比起前面的几种来说还是太简单了，导致实际的应用场景也不是那么多。</p>\n<h3 id=\"百分比布局\"><a href=\"#百分比布局\" class=\"headerlink\" title=\"百分比布局\"></a>百分比布局</h3><p>安卓引用了一种全新的布局方式来解决线性布局不够强大的比例式布局的缺点，这种布局中，可以不再用wrap_content、match_parent等方式去指定控件的大小，而是直接指定控件在布局中所占的百分比，这样就可以轻松实现任意比例分割布局了。</p>\n<p>百分比布局对FrameLayout和RelativeLayout进行了功能扩展，提供了PercentFrameLayout和PercentRelativeLayout的全新布局。</p>\n<p>为了让这种布局方式能够兼容就的安卓版本上使用，这种布局定义在support库中，只需要在项目的build.gradle中添加百分比布局的依赖保证兼容性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.percent.PercentFrameLayout</span><br><span class=\"line\">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/text_view&quot;</span><br><span class=\"line\">        android:layout_gravity=&quot;start&quot;</span><br><span class=\"line\">        app:layout_widthPercent=&quot;50%&quot;</span><br><span class=\"line\">        app:layout_heightPercent=&quot;50%&quot;</span><br><span class=\"line\">        android:text=&quot;hello~&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/android.support.percent.PercentFrameLayout&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这里的app并没有补全，想来应该是因为这个并不在内置在系统的SDK中的，所以没有自动补全。</p>\n<p><strong>这种布局有一个大坑：写50%的时候总是先写50再写%，写这里的时候我写了50然后手抖后面多跟了个0，成了500，然后就直接卡死，告诉我Out of Memory。其实也很好解释，因为AndroidStudio是可以自动预览布局的，所以这里还来不及修改的时候，已经自动按照500去算百分比了，1是100%，那么500就是50000%，所以就内存不够了。</strong></p>\n<p>对于另一种PercentRelativeLayout，它继承了RelativeLayout的所有属性并且加入了app:layout_widthPercent和app:layout_heightPercent来指定控件的宽高。</p>\n<h3 id=\"约束布局——ConstraintLayout\"><a href=\"#约束布局——ConstraintLayout\" class=\"headerlink\" title=\"约束布局——ConstraintLayout\"></a>约束布局——ConstraintLayout</h3><p>因为书上的几种布局方式比较老，其实在现在的AndroidStudio里面新建一个project的时候，已经默认设置为这种约束布局了，所以换句话说，这个应该重点学习，它被默认支持一定是有它的优点的。</p>\n<p>之前一直是用代码去编写布局，是因为前面的几种布局对于用代码的表达更好一些。但是归根结底来说，布局这种的用可视化去编辑是最直观最合适的，所以这个就是为了解决这种问题的一种新的布局方式。（这个书的作者也说了，当时在写书的时候这个布局方式刚出来，就没有加入到书里。）</p>\n<p>这种布局方式是使用控件的相对位置去布局的，有点类似相对布局，但是比相对布局还要强大。</p>\n<p>这种布局同时还解决了传统的几种布局的嵌套问题。传统布局要实现复杂的布局往往需要多重嵌套，但是多重嵌套会降低性能，所以这种布局应对复杂布局的时候可能会更好。</p>\n<p>这种布局暂时看到的教程都说适合用Design界面去拖拽完成布局操作，所以这里就先不写了。</p>\n<h2 id=\"自定义控件\"><a href=\"#自定义控件\" class=\"headerlink\" title=\"自定义控件\"></a>自定义控件</h2><p>和iOS一样，Android里的控件也都是直接或者间接的继承自View，所有的布局都是直接或间接继承自ViewGroup。View是Android里的最基本的UI组件。ViewGroup是一种特殊的View，可以包含很多子View和ViewGroup，是用于防止控件和布局的容器。</p>\n<p>需要接触几个前面没有接触到的属性：</p>\n<p><strong>background</strong>：为布局或者控件指定一个背景，可以使颜色或者图片。</p>\n<p><strong>margin</strong>：指定控件在四个方向的偏移量，也可以用margin_left等指定单一某个方向上的偏移量。</p>\n<p>先写好某一个自定义布局，然后在另一个布局里面引用这个布局就可以了。</p>\n<p>title.xml：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout</span><br><span class=\"line\">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;Button</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_gravity=&quot;center&quot;</span><br><span class=\"line\">        android:layout_margin=&quot;5dp&quot;</span><br><span class=\"line\">        android:text=&quot;Back&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:layout_width=&quot;0dp&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_gravity=&quot;center&quot;</span><br><span class=\"line\">        android:layout_weight=&quot;1&quot;</span><br><span class=\"line\">        android:gravity=&quot;center&quot;</span><br><span class=\"line\">        android:text=&quot;title&quot;</span><br><span class=\"line\">        android:textSize=&quot;24sp&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">    &lt;Button</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_gravity=&quot;center&quot;</span><br><span class=\"line\">        android:layout_margin=&quot;5dp&quot;</span><br><span class=\"line\">        android:text=&quot;edit&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>\n<p>activity_miain.xml：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout</span><br><span class=\"line\">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;include layout=&quot;@layout/title&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这个的实现效果就是自定义了个ActionBar并且加载到主布局中。</p>\n<h2 id=\"最常用、最难用的控件——ListView\"><a href=\"#最常用、最难用的控件——ListView\" class=\"headerlink\" title=\"最常用、最难用的控件——ListView\"></a>最常用、最难用的控件——ListView</h2><p>这里的ListView就类似于iOS里面的UITableView，重要性不用多说。</p>\n<p>先从最简单的用法开始：</p>\n<h3 id=\"ListView的简单用法\"><a href=\"#ListView的简单用法\" class=\"headerlink\" title=\"ListView的简单用法\"></a>ListView的简单用法</h3><p>先在布局里面写一个ListView进去，这里先写好大小和id就可以。</p>\n<p>然后在Activity里面写一个和这个listView相关的实例，把它的适配器指定为某个适配器的实例就好了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListView listView = findViewById(R.id.list_view);</span><br><span class=\"line\">ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(</span><br><span class=\"line\">\tMainActivity.this,</span><br><span class=\"line\">    android.R.layout.simple_list_item_1,</span><br><span class=\"line\">    data</span><br><span class=\"line\">    );</span><br><span class=\"line\">listView.setAdapter(adapter);</span><br></pre></td></tr></table></figure></p>\n<p>这个适配器只是众多适配器中的一种，这个据说是最好用的，可以通过泛型来指定钥匙胚的数据类型，然后在构造函数里传参进去。</p>\n<p>ArrayAdapter有很多重载，这里是因为用到的数据都是String类型，所以这里写 了String。然后依次传入当前的上下文、listView的id，以及具体的数据数组。</p>\n<p>这里的android.R.layout.simple_list_item_1相当于是iOS里面UITableView的style，可以有很多种style，根据具体的使用场景自行切换。</p>\n<h3 id=\"自定义ListView的界面\"><a href=\"#自定义ListView的界面\" class=\"headerlink\" title=\"自定义ListView的界面\"></a>自定义ListView的界面</h3><p>自定义的过程和iOS的自定义cell的基本上相似，都是新建一个布局，然后让ListView去加载这个布局作为item，然后把构造好的数据展示到界面上就好了。</p>\n<ul>\n<li>先新建一个布局：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;ImageView</span><br><span class=\"line\">        android:id=&quot;@+id/fruit_image&quot;</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:background=&quot;@drawable/ic_launcher_background&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/fruit_textview&quot;</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_gravity=&quot;center_vertical&quot;</span><br><span class=\"line\">        android:layout_margin=&quot;10dp&quot;/&gt;</span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个就是cell（也就是item）的展示布局。</p>\n<ul>\n<li>新建一个容器类<br>这个容器类就是作为ListView的适配器类型：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Fruit &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private int imageId;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Fruit(String name,int imageId)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.imageId = imageId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getImageId() &#123;</span><br><span class=\"line\">        return imageId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个部分就相当于model类的部分，用来存储ListView将来要展示的数据。</p>\n<ul>\n<li>新建一个适配器类<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123;</span><br><span class=\"line\">    private int resourceId;</span><br><span class=\"line\">    public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt;object)&#123;</span><br><span class=\"line\">        super(context,textViewResourceId,object);</span><br><span class=\"line\">        resourceId = textViewResourceId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123;</span><br><span class=\"line\">        Fruit fruit = getItem(position);</span><br><span class=\"line\">        View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);</span><br><span class=\"line\">        ImageView fruitImage = (ImageView)view.findViewById(R.id.fruit_image);</span><br><span class=\"line\">        TextView fruitName=(TextView)view.findViewById(R.id.fruit_textview);</span><br><span class=\"line\">        fruitImage.setImageResource(fruit.getImageId());</span><br><span class=\"line\">        fruitName.setText(fruit.getName());</span><br><span class=\"line\">        return view;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看到这个适配器类是继承自ArrayAdapter的，声明了一个私有属性resourceId，然后在这个类的构造函数里传入三个参数：上下文、textViewResourceId、和一个model类的List对象。调用父类的方法，对私有属性赋值。</p>\n<p>然后需要重写一个父类的方法getView（），这个方法就相当于iOS里面的cellForRowAtIndex，在每次item要出现在屏幕上的时候就会调用。</p>\n<p>这个getView传入了三个参数：position相当于是index，因为前面在构造函数里面已经设置过了List对象，所以这个方法是把数组中当前要处理的cell的对应元素取出来。</p>\n<p>然后要新建一个View对象，这个view是：先获取到Activity的布局渲染器，然后对这个布局渲染器LayoutInflater调用inflate方法。inflate方法需要传三个参数：resourceId（具体的item的那个布局的xml文件）、parent（父布局，和缓存有关）、false（表示这个resourceId所引用的布局是不带父布局的，因为如果带了父布局，就不能添加到目标要添加的父布局了）。</p>\n<p>然后从这个view中通过findViewById的方法去找到具体的控件，接着分别从对应顺序的model的元素（第一行的getItem方法已经取出来了的那个）里面取出需要显示在item上面的值，赋值给对应的控件，然后返回这个view作为ListView的item。</p>\n<ul>\n<li>在Activity中：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;Fruit&gt; fruits = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    ListView listView = findViewById(R.id.list_view);</span><br><span class=\"line\"></span><br><span class=\"line\">    initFruit();</span><br><span class=\"line\">    FruitAdapter adapter = new FruitAdapter(MainActivity.this,R.layout.fruit_item,fruits);</span><br><span class=\"line\"></span><br><span class=\"line\">    listView.setAdapter(adapter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void initFruit()&#123;</span><br><span class=\"line\">\tfor (int i =0;i&lt;100;i++)&#123;</span><br><span class=\"line\">    \tFruit fruit = new Fruit(&quot;apple&quot;+i,R.drawable.ic_launcher_background);</span><br><span class=\"line\">        fruits.add(fruit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前面的其实都是准备的工作，要生效还是在Activity里面建立数据数组，然后对数据数组进行初始化，然后新建一个自定义的适配器，最后把listview的适配器设置为刚才建立好的自定义适配器实例。</p>\n<p>要实现更复杂的item，只要修改model和item的布局文件就可以了。</p>\n<h3 id=\"提升ListView的效率\"><a href=\"#提升ListView的效率\" class=\"headerlink\" title=\"提升ListView的效率\"></a>提升ListView的效率</h3><p>ListView之所以难用就是因为它的使用初看比较简单，但是实际上有很多可以优化的点，比如提升效率。</p>\n<p>前面写的代码的运行效率就很低，因为在适配器的代码中，每次item出现的时候，都会调用的getView方法中都会加载一遍布局。当ListView快速滑动的时候，就会带来不小的负担。</p>\n<p>其实前面没有注意到的是，getView还有一个参数：convertView。</p>\n<p>这个参数是将之前加载好的布局缓存起来，以便之后再次使用。</p>\n<p>所以其实可以这样用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View view;</span><br><span class=\"line\">if (convertView == null)</span><br><span class=\"line\">\tLayoutInflater.from(getContext()).inflate(resourceId,parent,false);</span><br><span class=\"line\">else</span><br><span class=\"line\">    view = convertView;</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，就不会每次都不分青红皂白地去加载布局了，而是先判断缓存的布局是不是为空，如果为空，再去加载布局，如果不为空，就直接变动要显示的数据就好了。</p>\n<p><strong>纵使这样，代码的性能还能继续优化：</strong><br>虽然已经可以不用重复地去加载布局了，但是对于getView方法，还是需要每次从view里面通过findViewById去找到具体的控件。所以这里就可通过新建一个ViewHolder类去缓存每个控件了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@NonNull</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123;</span><br><span class=\"line\">\tFruit fruit = getItem(position);</span><br><span class=\"line\"></span><br><span class=\"line\">    ViewHolder viewHolder;</span><br><span class=\"line\">    View view;</span><br><span class=\"line\">    if (convertView == null)&#123;</span><br><span class=\"line\">    \tview = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);</span><br><span class=\"line\">    \tviewHolder = new ViewHolder();</span><br><span class=\"line\">        viewHolder.fruitImage = (ImageView)view.findViewById(R.id.fruit_image);</span><br><span class=\"line\">        viewHolder.fruitName = (TextView)view.findViewById(R.id.fruit_textview);</span><br><span class=\"line\">        view.setTag(viewHolder);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">    \tview = convertView;</span><br><span class=\"line\">        viewHolder = (ViewHolder)view.getTag();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert fruit != null;</span><br><span class=\"line\">    viewHolder.fruitImage.setImageResource(fruit.getImageId());</span><br><span class=\"line\">    viewHolder.fruitName.setText(fruit.getName());</span><br><span class=\"line\">    return view;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class ViewHolder&#123;</span><br><span class=\"line\">\tImageView fruitImage;</span><br><span class=\"line\">    TextView fruitName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这里的ViewHolder类也很简单，和Fruit类一一对应，只不过Fruit里面是数据，这个里面是需要改变数据的item的控件。</p>\n<p>在原来优化的基础上，对于新加载布局的情况：把从view里面寻找对应的控件，然后存到viewHolder里面，最后把viewHolder实例设置为view的tag；</p>\n<p>对于不用重新加载布局的view：直接通过getTag方法获取viewHolder，然后取出viewHolder里面的控件进行操作。</p>\n<h3 id=\"ListView的点击事件\"><a href=\"#ListView的点击事件\" class=\"headerlink\" title=\"ListView的点击事件\"></a>ListView的点击事件</h3><p>也很好理解，就和iOS里面的cell监听方法一样的。</p>\n<p>对于Android的ListView，就是实现ListView的setOnItemClickListener方法参数中的闭包。</p>\n<p>前面的优化都是在自定义适配器里写的，这里就要回到Activity里面了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;</span><br><span class=\"line\">    \tFruit fruit = fruits.get(position);</span><br><span class=\"line\">        Toast.makeText(MainActivity.this,&quot;this is &quot;+fruit.getName(),Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这个方法是在参数中传入了一个闭包，覆写了onItemClick的方法，传入了三个参数：一个适配器类型的变量、一个当前的item的view，一个当前的index，一个id。</p>\n<p>然后如果要让点击之后发生点什么，就在这个onItemClick方法里写就好。</p>\n<h2 id=\"RecyclerView\"><a href=\"#RecyclerView\" class=\"headerlink\" title=\"RecyclerView\"></a>RecyclerView</h2><p>终于过了那个ListView大户，然后又来了一个传说中更强大的控件——RecycleView。</p>\n<p>ListView其实有着很多不够强大的地方——一是需要用一些技巧去优化它的性能，二是它只能实现竖向的滚动，不能实现横向的滑动。</p>\n<p>所以，Android就提供了一个更强大的控件，这个可以看做一个增强版的ListView，可以轻松实现ListView的效果，还优化了ListView里面的各种不足之处。目前就连Android官方都更加推荐RecycleView。</p>\n<p>因为这个也是官方SDK里没有默认提供的控件，所以需要在app/build.gradle里面写明依赖库。</p>\n<p>然后就是在布局文件里面写这个控件了。</p>\n"},{"title":"数据结构是什么","category":123,"author":"常昊","date":"2018-04-11T17:38:00.000Z","_content":"大二的第一学期有数据结构的课但是上课时候没有听得很清晰明了，可能是老师讲的快或者我有点呆……\n开始自己整理一些东西，理一理思路，把课本上的模块过一遍。此系列的文作为我自己的学习笔记，同时作为交流和分享， 希望大家多多指教，不胜感激。\n \n## 引论\n \n### 数据结构是什么？\n\n书上说了很多很书面的概念，一看感觉好高大上啊~但是对于我这样一个小白来说，真的没有看懂这个到底是个啥。\n下面是我个人对几个专业术语的理解（上例子）：\n \n#### 数据：\n万物皆是数据。对就是这么“片面”。我们把一件事物用一些描述性的数字、符号等尽可能完整的表达出来，那这件 事物就转化成了一堆数据。比如我们班同学的个人信息的集合表格就可以看做是一堆数据。\n#### 数据元素：\n数据就是由数据元素组成的，数据元素是数据的基本组成单位。接着上面的例子，这里的数据元素就是**每一 个人**的各项信息的集合。\n#### 数据项：\n就是**每一种**数据，上例中的全部人的“姓名”一栏的信息就构成了“姓名”这一数据项。\n#### 数据对象：\n是具有相同性质的**数据元素**的集合。继续上面的例子，数据对象就可以是班级里所有已成年同学的信息的 集合。（注意：这个集合里的每一个元素都必须要是一个数据元素）\n#### 数据结构：\n首先它是集合。（准确来说是由数据和关系构成的二元组）然后这个集合中的元素都是数据元素。而且这些数 据元素之间存在着某种或多种特定关系。比如我们上面的例子：一个班里有班委会，班长管着班里的大事小事，然后下属有 团支书、学习委员、文体委员等等。这样的一个班委会的几个人的集合连同这几个人之间的上下级关系构成了一个数据结构 。\n#### 数据类型：\n总的来说就是两类：原子类型和结构类型。这里不用上面的例子了。我们平时定义的int、double类就是原子类型，已经不能再向下细分了。另一种就是我们常用的链表的节点（结构体种，一个数据元素中往往包含着数据域，指针域的 数据类型。可以继续细分的，称为结构类型。\n\n下面还有一个我觉得可能需要单独拿出来看的东西（虽然课本上是把它和以上的6个术语放一起说的），就是**抽象**。\n抽象二字一开始给我的感觉是晦涩难懂。比如我们说，啊什么什么东西很抽象，那意思可能就是这个东西很难懂，比如抽象 画（原谅我可能真的没有什么艺术细胞，至今仍然没有真正看懂过任意一幅抽象画）\n……\n\n但我个人觉得，抽象的意思是把某一个东西给简化描述，去掉不必要的、冗余的修饰——甚至可以是去掉任何修饰，一步步更 靠近事物的本质。\n\n举个例子：女朋友新买了防水浓密型摩天翘睫毛膏，程序员男友对这款睫毛膏的逐步抽象看法是酱紫的：\nXXXX牌防水浓密型的摩天翘睫毛膏->抽象一下->睫毛膏->再抽象一下->黑色混油胶质涂料->再抽象一下->黑色涂料->再抽象 一下->涂料\n\n抽象结束。鉴定这款花了好几百大洋的传说中的爆款睫毛膏，本质上就是6ml涂料。\n\n但是，千万不要眉飞色舞的把你的抽象思维的结果说出来，不然不管你抽象抽的多好都会被抽的。\n\n除非女朋友也是程序员。\n\n说回正题。程序设计的规模在不断增大，所以我们不可能总是从最底层开始做开发，这样的开发是毫无意义的而且是极其耗 费时间、人力的。所以为了应对日益增长的软件的复杂度问题，程序的设计语言也在不断的“进化”：机器语言->汇编语言-> 高级语言->非过程化语言（即面向对象语言）。“进化”的过程其实就是不断抽象的过程。\n\n\n我手里的课本在这节后面还有一点关于ADT（抽象数据类型）的介绍，但是对于目前的知识这一块来说，个人感觉并没有很大的帮助，等到总结到后面有需要的时候再说明。\n\n\n\n才疏学浅，如有错漏，恳请指教，不甚感激。\n>部分引用《数据结构与算法》——人民邮电出版社","source":"_posts/my-test-aritical.md","raw":"title: 数据结构是什么\ntags:\n  - 学习笔记\ncategory: 123\ncategories:\n  - 数据结构\nauthor: 常昊\ndate: 2018-04-12 01:38:00\n---\n大二的第一学期有数据结构的课但是上课时候没有听得很清晰明了，可能是老师讲的快或者我有点呆……\n开始自己整理一些东西，理一理思路，把课本上的模块过一遍。此系列的文作为我自己的学习笔记，同时作为交流和分享， 希望大家多多指教，不胜感激。\n \n## 引论\n \n### 数据结构是什么？\n\n书上说了很多很书面的概念，一看感觉好高大上啊~但是对于我这样一个小白来说，真的没有看懂这个到底是个啥。\n下面是我个人对几个专业术语的理解（上例子）：\n \n#### 数据：\n万物皆是数据。对就是这么“片面”。我们把一件事物用一些描述性的数字、符号等尽可能完整的表达出来，那这件 事物就转化成了一堆数据。比如我们班同学的个人信息的集合表格就可以看做是一堆数据。\n#### 数据元素：\n数据就是由数据元素组成的，数据元素是数据的基本组成单位。接着上面的例子，这里的数据元素就是**每一 个人**的各项信息的集合。\n#### 数据项：\n就是**每一种**数据，上例中的全部人的“姓名”一栏的信息就构成了“姓名”这一数据项。\n#### 数据对象：\n是具有相同性质的**数据元素**的集合。继续上面的例子，数据对象就可以是班级里所有已成年同学的信息的 集合。（注意：这个集合里的每一个元素都必须要是一个数据元素）\n#### 数据结构：\n首先它是集合。（准确来说是由数据和关系构成的二元组）然后这个集合中的元素都是数据元素。而且这些数 据元素之间存在着某种或多种特定关系。比如我们上面的例子：一个班里有班委会，班长管着班里的大事小事，然后下属有 团支书、学习委员、文体委员等等。这样的一个班委会的几个人的集合连同这几个人之间的上下级关系构成了一个数据结构 。\n#### 数据类型：\n总的来说就是两类：原子类型和结构类型。这里不用上面的例子了。我们平时定义的int、double类就是原子类型，已经不能再向下细分了。另一种就是我们常用的链表的节点（结构体种，一个数据元素中往往包含着数据域，指针域的 数据类型。可以继续细分的，称为结构类型。\n\n下面还有一个我觉得可能需要单独拿出来看的东西（虽然课本上是把它和以上的6个术语放一起说的），就是**抽象**。\n抽象二字一开始给我的感觉是晦涩难懂。比如我们说，啊什么什么东西很抽象，那意思可能就是这个东西很难懂，比如抽象 画（原谅我可能真的没有什么艺术细胞，至今仍然没有真正看懂过任意一幅抽象画）\n……\n\n但我个人觉得，抽象的意思是把某一个东西给简化描述，去掉不必要的、冗余的修饰——甚至可以是去掉任何修饰，一步步更 靠近事物的本质。\n\n举个例子：女朋友新买了防水浓密型摩天翘睫毛膏，程序员男友对这款睫毛膏的逐步抽象看法是酱紫的：\nXXXX牌防水浓密型的摩天翘睫毛膏->抽象一下->睫毛膏->再抽象一下->黑色混油胶质涂料->再抽象一下->黑色涂料->再抽象 一下->涂料\n\n抽象结束。鉴定这款花了好几百大洋的传说中的爆款睫毛膏，本质上就是6ml涂料。\n\n但是，千万不要眉飞色舞的把你的抽象思维的结果说出来，不然不管你抽象抽的多好都会被抽的。\n\n除非女朋友也是程序员。\n\n说回正题。程序设计的规模在不断增大，所以我们不可能总是从最底层开始做开发，这样的开发是毫无意义的而且是极其耗 费时间、人力的。所以为了应对日益增长的软件的复杂度问题，程序的设计语言也在不断的“进化”：机器语言->汇编语言-> 高级语言->非过程化语言（即面向对象语言）。“进化”的过程其实就是不断抽象的过程。\n\n\n我手里的课本在这节后面还有一点关于ADT（抽象数据类型）的介绍，但是对于目前的知识这一块来说，个人感觉并没有很大的帮助，等到总结到后面有需要的时候再说明。\n\n\n\n才疏学浅，如有错漏，恳请指教，不甚感激。\n>部分引用《数据结构与算法》——人民邮电出版社","slug":"my-test-aritical","published":1,"updated":"2018-06-05T13:26:09.106Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji2hzkaw0001pvi1umcwu9x6","content":"<p>大二的第一学期有数据结构的课但是上课时候没有听得很清晰明了，可能是老师讲的快或者我有点呆……<br>开始自己整理一些东西，理一理思路，把课本上的模块过一遍。此系列的文作为我自己的学习笔记，同时作为交流和分享， 希望大家多多指教，不胜感激。</p>\n<h2 id=\"引论\"><a href=\"#引论\" class=\"headerlink\" title=\"引论\"></a>引论</h2><h3 id=\"数据结构是什么？\"><a href=\"#数据结构是什么？\" class=\"headerlink\" title=\"数据结构是什么？\"></a>数据结构是什么？</h3><p>书上说了很多很书面的概念，一看感觉好高大上啊~但是对于我这样一个小白来说，真的没有看懂这个到底是个啥。<br>下面是我个人对几个专业术语的理解（上例子）：</p>\n<h4 id=\"数据：\"><a href=\"#数据：\" class=\"headerlink\" title=\"数据：\"></a>数据：</h4><p>万物皆是数据。对就是这么“片面”。我们把一件事物用一些描述性的数字、符号等尽可能完整的表达出来，那这件 事物就转化成了一堆数据。比如我们班同学的个人信息的集合表格就可以看做是一堆数据。</p>\n<h4 id=\"数据元素：\"><a href=\"#数据元素：\" class=\"headerlink\" title=\"数据元素：\"></a>数据元素：</h4><p>数据就是由数据元素组成的，数据元素是数据的基本组成单位。接着上面的例子，这里的数据元素就是<strong>每一 个人</strong>的各项信息的集合。</p>\n<h4 id=\"数据项：\"><a href=\"#数据项：\" class=\"headerlink\" title=\"数据项：\"></a>数据项：</h4><p>就是<strong>每一种</strong>数据，上例中的全部人的“姓名”一栏的信息就构成了“姓名”这一数据项。</p>\n<h4 id=\"数据对象：\"><a href=\"#数据对象：\" class=\"headerlink\" title=\"数据对象：\"></a>数据对象：</h4><p>是具有相同性质的<strong>数据元素</strong>的集合。继续上面的例子，数据对象就可以是班级里所有已成年同学的信息的 集合。（注意：这个集合里的每一个元素都必须要是一个数据元素）</p>\n<h4 id=\"数据结构：\"><a href=\"#数据结构：\" class=\"headerlink\" title=\"数据结构：\"></a>数据结构：</h4><p>首先它是集合。（准确来说是由数据和关系构成的二元组）然后这个集合中的元素都是数据元素。而且这些数 据元素之间存在着某种或多种特定关系。比如我们上面的例子：一个班里有班委会，班长管着班里的大事小事，然后下属有 团支书、学习委员、文体委员等等。这样的一个班委会的几个人的集合连同这几个人之间的上下级关系构成了一个数据结构 。</p>\n<h4 id=\"数据类型：\"><a href=\"#数据类型：\" class=\"headerlink\" title=\"数据类型：\"></a>数据类型：</h4><p>总的来说就是两类：原子类型和结构类型。这里不用上面的例子了。我们平时定义的int、double类就是原子类型，已经不能再向下细分了。另一种就是我们常用的链表的节点（结构体种，一个数据元素中往往包含着数据域，指针域的 数据类型。可以继续细分的，称为结构类型。</p>\n<p>下面还有一个我觉得可能需要单独拿出来看的东西（虽然课本上是把它和以上的6个术语放一起说的），就是<strong>抽象</strong>。<br>抽象二字一开始给我的感觉是晦涩难懂。比如我们说，啊什么什么东西很抽象，那意思可能就是这个东西很难懂，比如抽象 画（原谅我可能真的没有什么艺术细胞，至今仍然没有真正看懂过任意一幅抽象画）<br>……</p>\n<p>但我个人觉得，抽象的意思是把某一个东西给简化描述，去掉不必要的、冗余的修饰——甚至可以是去掉任何修饰，一步步更 靠近事物的本质。</p>\n<p>举个例子：女朋友新买了防水浓密型摩天翘睫毛膏，程序员男友对这款睫毛膏的逐步抽象看法是酱紫的：<br>XXXX牌防水浓密型的摩天翘睫毛膏-&gt;抽象一下-&gt;睫毛膏-&gt;再抽象一下-&gt;黑色混油胶质涂料-&gt;再抽象一下-&gt;黑色涂料-&gt;再抽象 一下-&gt;涂料</p>\n<p>抽象结束。鉴定这款花了好几百大洋的传说中的爆款睫毛膏，本质上就是6ml涂料。</p>\n<p>但是，千万不要眉飞色舞的把你的抽象思维的结果说出来，不然不管你抽象抽的多好都会被抽的。</p>\n<p>除非女朋友也是程序员。</p>\n<p>说回正题。程序设计的规模在不断增大，所以我们不可能总是从最底层开始做开发，这样的开发是毫无意义的而且是极其耗 费时间、人力的。所以为了应对日益增长的软件的复杂度问题，程序的设计语言也在不断的“进化”：机器语言-&gt;汇编语言-&gt; 高级语言-&gt;非过程化语言（即面向对象语言）。“进化”的过程其实就是不断抽象的过程。</p>\n<p>我手里的课本在这节后面还有一点关于ADT（抽象数据类型）的介绍，但是对于目前的知识这一块来说，个人感觉并没有很大的帮助，等到总结到后面有需要的时候再说明。</p>\n<p>才疏学浅，如有错漏，恳请指教，不甚感激。</p>\n<blockquote>\n<p>部分引用《数据结构与算法》——人民邮电出版社</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>大二的第一学期有数据结构的课但是上课时候没有听得很清晰明了，可能是老师讲的快或者我有点呆……<br>开始自己整理一些东西，理一理思路，把课本上的模块过一遍。此系列的文作为我自己的学习笔记，同时作为交流和分享， 希望大家多多指教，不胜感激。</p>\n<h2 id=\"引论\"><a href=\"#引论\" class=\"headerlink\" title=\"引论\"></a>引论</h2><h3 id=\"数据结构是什么？\"><a href=\"#数据结构是什么？\" class=\"headerlink\" title=\"数据结构是什么？\"></a>数据结构是什么？</h3><p>书上说了很多很书面的概念，一看感觉好高大上啊~但是对于我这样一个小白来说，真的没有看懂这个到底是个啥。<br>下面是我个人对几个专业术语的理解（上例子）：</p>\n<h4 id=\"数据：\"><a href=\"#数据：\" class=\"headerlink\" title=\"数据：\"></a>数据：</h4><p>万物皆是数据。对就是这么“片面”。我们把一件事物用一些描述性的数字、符号等尽可能完整的表达出来，那这件 事物就转化成了一堆数据。比如我们班同学的个人信息的集合表格就可以看做是一堆数据。</p>\n<h4 id=\"数据元素：\"><a href=\"#数据元素：\" class=\"headerlink\" title=\"数据元素：\"></a>数据元素：</h4><p>数据就是由数据元素组成的，数据元素是数据的基本组成单位。接着上面的例子，这里的数据元素就是<strong>每一 个人</strong>的各项信息的集合。</p>\n<h4 id=\"数据项：\"><a href=\"#数据项：\" class=\"headerlink\" title=\"数据项：\"></a>数据项：</h4><p>就是<strong>每一种</strong>数据，上例中的全部人的“姓名”一栏的信息就构成了“姓名”这一数据项。</p>\n<h4 id=\"数据对象：\"><a href=\"#数据对象：\" class=\"headerlink\" title=\"数据对象：\"></a>数据对象：</h4><p>是具有相同性质的<strong>数据元素</strong>的集合。继续上面的例子，数据对象就可以是班级里所有已成年同学的信息的 集合。（注意：这个集合里的每一个元素都必须要是一个数据元素）</p>\n<h4 id=\"数据结构：\"><a href=\"#数据结构：\" class=\"headerlink\" title=\"数据结构：\"></a>数据结构：</h4><p>首先它是集合。（准确来说是由数据和关系构成的二元组）然后这个集合中的元素都是数据元素。而且这些数 据元素之间存在着某种或多种特定关系。比如我们上面的例子：一个班里有班委会，班长管着班里的大事小事，然后下属有 团支书、学习委员、文体委员等等。这样的一个班委会的几个人的集合连同这几个人之间的上下级关系构成了一个数据结构 。</p>\n<h4 id=\"数据类型：\"><a href=\"#数据类型：\" class=\"headerlink\" title=\"数据类型：\"></a>数据类型：</h4><p>总的来说就是两类：原子类型和结构类型。这里不用上面的例子了。我们平时定义的int、double类就是原子类型，已经不能再向下细分了。另一种就是我们常用的链表的节点（结构体种，一个数据元素中往往包含着数据域，指针域的 数据类型。可以继续细分的，称为结构类型。</p>\n<p>下面还有一个我觉得可能需要单独拿出来看的东西（虽然课本上是把它和以上的6个术语放一起说的），就是<strong>抽象</strong>。<br>抽象二字一开始给我的感觉是晦涩难懂。比如我们说，啊什么什么东西很抽象，那意思可能就是这个东西很难懂，比如抽象 画（原谅我可能真的没有什么艺术细胞，至今仍然没有真正看懂过任意一幅抽象画）<br>……</p>\n<p>但我个人觉得，抽象的意思是把某一个东西给简化描述，去掉不必要的、冗余的修饰——甚至可以是去掉任何修饰，一步步更 靠近事物的本质。</p>\n<p>举个例子：女朋友新买了防水浓密型摩天翘睫毛膏，程序员男友对这款睫毛膏的逐步抽象看法是酱紫的：<br>XXXX牌防水浓密型的摩天翘睫毛膏-&gt;抽象一下-&gt;睫毛膏-&gt;再抽象一下-&gt;黑色混油胶质涂料-&gt;再抽象一下-&gt;黑色涂料-&gt;再抽象 一下-&gt;涂料</p>\n<p>抽象结束。鉴定这款花了好几百大洋的传说中的爆款睫毛膏，本质上就是6ml涂料。</p>\n<p>但是，千万不要眉飞色舞的把你的抽象思维的结果说出来，不然不管你抽象抽的多好都会被抽的。</p>\n<p>除非女朋友也是程序员。</p>\n<p>说回正题。程序设计的规模在不断增大，所以我们不可能总是从最底层开始做开发，这样的开发是毫无意义的而且是极其耗 费时间、人力的。所以为了应对日益增长的软件的复杂度问题，程序的设计语言也在不断的“进化”：机器语言-&gt;汇编语言-&gt; 高级语言-&gt;非过程化语言（即面向对象语言）。“进化”的过程其实就是不断抽象的过程。</p>\n<p>我手里的课本在这节后面还有一点关于ADT（抽象数据类型）的介绍，但是对于目前的知识这一块来说，个人感觉并没有很大的帮助，等到总结到后面有需要的时候再说明。</p>\n<p>才疏学浅，如有错漏，恳请指教，不甚感激。</p>\n<blockquote>\n<p>部分引用《数据结构与算法》——人民邮电出版社</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cji2hzkaw0001pvi1umcwu9x6","category_id":"cji2hzkb50004pvi11zl7024a","_id":"cji2hzkb70008pvi1n4zafsk4"},{"post_id":"cji2hzkap0000pvi1f3mr39ye","category_id":"cji2hzkb10002pvi1pnhd75o6","_id":"cji2hzkb8000cpvi128k8kbwo"},{"post_id":"cji2hzkap0000pvi1f3mr39ye","category_id":"cji2hzkb60006pvi1wn3kitn8","_id":"cji2hzkb8000epvi1r24htddb"}],"PostTag":[{"post_id":"cji2hzkap0000pvi1f3mr39ye","tag_id":"cji2hzkb40003pvi1ho7x8s7x","_id":"cji2hzkb8000apvi1by25cj76"},{"post_id":"cji2hzkap0000pvi1f3mr39ye","tag_id":"cji2hzkb50005pvi1go59v379","_id":"cji2hzkb8000bpvi1b55zpmiq"},{"post_id":"cji2hzkap0000pvi1f3mr39ye","tag_id":"cji2hzkb60007pvi128nge7qh","_id":"cji2hzkb8000dpvi1dqdl01e5"},{"post_id":"cji2hzkaw0001pvi1umcwu9x6","tag_id":"cji2hzkb70009pvi1t2qxvrvr","_id":"cji2hzkb8000fpvi14j9qmm5v"}],"Tag":[{"name":"0基础","_id":"cji2hzkb40003pvi1ho7x8s7x"},{"name":"客户端","_id":"cji2hzkb50005pvi1go59v379"},{"name":"Android","_id":"cji2hzkb60007pvi128nge7qh"},{"name":"学习笔记","_id":"cji2hzkb70009pvi1t2qxvrvr"}]}}