<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>dart快速上手</title>
      <link href="/2019/01/25/dart%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2019/01/25/dart%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      <content type="html"><![CDATA[<p>dart语言用于flutter开发，所以最近在dart的语法学习的过程中总结一点从其他语言到dart的异同点，以便少踩坑。（语法参考的是官方文档）</p><a id="more"></a><h3 id="1-字符串中引用变量或者表达式的值："><a href="#1-字符串中引用变量或者表达式的值：" class="headerlink" title="1. 字符串中引用变量或者表达式的值："></a>1. 字符串中引用变量或者表达式的值：</h3><p>C语言的printf函数中是使用%符号作为变量或者表达式的引用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf('a`s value is %d ', a);</span><br></pre></td></tr></table></figure></p><p>在dart中是这样的：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'a`s value is $a'</span>);</span><br><span class="line"><span class="comment">//dart使用的是$符号。</span></span><br></pre></td></tr></table></figure></p><h3 id="2-final和const"><a href="#2-final和const" class="headerlink" title="2.final和const"></a>2.final和const</h3><p>const也是final类型的，不过const是编译时常量，final是在第一次使用的时候初始化的，第一次赋值的时候就确定下来了，之后再不能修改了。所以实例变量可以是final但是不可以是const修饰。</p><p>const变量如果声明在类中，最好直接定义为static const。<br>除此之外，const还用来声明一些不变的值（不可变对象、数组等）。</p><h3 id="3-bool类型很重要"><a href="#3-bool类型很重要" class="headerlink" title="3.bool类型很重要"></a>3.bool类型很重要</h3><p>在其他的语言中，有时候是很习惯用一些空值or非空值变量本身作为判断条件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a != 0"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样看也没什么问题，如果a的值是0，条件判断会为假。</p><p>但是在dart中就不一样了，dart的判断条件只认正经bool类型，所以对于如上代码，dart总会判断为假，因为a变量是一个int类型，压根就不是bool类型，更不可能为true对象。</p><p>所以在dart中，需要显式判断数据，然后返回一个布尔值作为if、while等的判断条件。</p><h3 id="4-方法定义"><a href="#4-方法定义" class="headerlink" title="4.方法定义"></a>4.方法定义</h3><p>诚然在类中还是不可以再定义一个类，不过dart的方法定义中是可以再定义一个方法的。</p><h3 id="5-默认参数语法的版本变动"><a href="#5-默认参数语法的版本变动" class="headerlink" title="5.默认参数语法的版本变动"></a>5.默认参数语法的版本变动</h3><p>1.21之前的dartSDK版本是用 ：冒号指定可选参数的默认值，后来版本更新了以后，需要用 = 等号来指定。如果遇到了升级版本后出现的语法错误，需要注意一下这里。</p><h3 id="6-级联操作符"><a href="#6-级联操作符" class="headerlink" title="6.级联操作符"></a>6.级联操作符</h3><p>dart也有支持类似链式调用的语法，区别于其他常见语言的 “.”点号，dart使用的是“..”，叫级联操作符（然而实际上并不是一个操作符，而是一个语法）。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">'#button'</span>) <span class="comment">// Get an object.</span></span><br><span class="line">  ..text = <span class="string">'Confirm'</span>   <span class="comment">// Use its members.</span></span><br><span class="line">  ..classes.add(<span class="string">'important'</span>)</span><br><span class="line">  ..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure></p><p>（偷官方那个例子用嘻嘻）<br>第一个方法返回一个对象，然后后面的操作语句的对象都是第一个返回的那个对象（的成员变量），并且后续操作的返回值都忽略掉了。</p><p>级联操作符可以嵌套使用。</p><h3 id="7-类的构造方法"><a href="#7-类的构造方法" class="headerlink" title="7.类的构造方法"></a>7.类的构造方法</h3><p>dart的面向对象是单继承。dart提供了一个语法糖可以简化构造方法的一些比较枯燥单一的赋值操作：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="comment">// There's a better way to do this, stay tuned.</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>语法糖如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Syntactic sugar for setting x and y</span></span><br><span class="line">  <span class="comment">// before the constructor body runs.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>并且子类并不继承父类的构造方法。</p><p><strong>在构造函数调用其他函数的时候，在 ：之后调用其他的方法：</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point.alongXAxis(<span class="built_in">num</span> x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p><strong>需要调用父类的初始化方法，并且父类只有一个命名初始化方法时，则必须</strong> ：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Son.fromJson(<span class="built_in">Map</span> data) : <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'in Son Class'</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><strong>dart提供了初始化列表的语法：</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Son.fromJson(<span class="built_in">Map</span> jsonMap)</span><br><span class="line">      : x = jsonMap[<span class="string">'x'</span>],</span><br><span class="line">        y = jsonMap[<span class="string">'y'</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'In Son.fromJson(): ($x, $y)'</span>); <span class="comment">//用:开始参数列表的赋值，用逗号分隔参数，右边不能使用this引用成员变量</span></span><br></pre></td></tr></table></figure></p><p><strong>几种构造方法的调用顺序如下：</strong></p><p>-&gt;<br>initializer list（初始化参数列表） </p><p>-&gt;<br>superclass’s no-arg constructor（超类的无名构造函数）</p><p>-&gt;<br>main class’s no-arg constructor（主类的无名构造函数）</p><p><strong>如果该对象的实例是一个不可变的对象，使用常量构造函数</strong><br>在构造函数之前声明const关键字，并且所有成员变量为final。</p><p><strong>如果要使用工厂模式的构造方法，可以使用factory关键字</strong><br>工厂模式的构造方法并不是每次都直接生成一个实例。有时候是需要从缓存中找到一个实例并返回，有的时候是需要返回某一个子类的实例（比如iOS开发中的UIButton，工厂方法返回的是UIButton的子类的实例）</p><h3 id="7-类的访问控制"><a href="#7-类的访问控制" class="headerlink" title="7.类的访问控制"></a>7.类的访问控制</h3><p>dart并没有关键字来表示私有还是开放访问，所以只是比较简单使用“ _ ” 来标识私有成员</p><h3 id="mixins-混合"><a href="#mixins-混合" class="headerlink" title="mixins 混合"></a>mixins 混合</h3><p>要重复使用类中的代码但是又不用走继承方式，那么就可以使用mixins方式去组合两个类：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用with关键字，表示类C是由类A和类B混合而构成</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> = <span class="title">A</span> <span class="title">with</span> <span class="title">B</span>;</span></span><br></pre></td></tr></table></figure></p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>类方法需要用static关键字来实现为静态函数，当然类方法中是不可以访问this的。</p><h3 id="包的引入支持懒加载"><a href="#包的引入支持懒加载" class="headerlink" title="包的引入支持懒加载"></a>包的引入支持懒加载</h3><p>可以用deferred as 来标识要懒加载的包。然后在使用的时候用loadLibrary（）函数来加载库（可以指定是同步方式还是异步方式）。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>当然双斜线还是可以用的啦～</p><blockquote><p>(<em>之后有空还会更新哦～</em>)</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>2018 年终总结</title>
      <link href="/2019/01/01/2018-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/01/2018-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>终于还是又到了年末，回想这一年，好像没有发生什么不得了的大事，但是我还是想总结一下这一年，告别总还是要有仪式感的嘛。<br><a id="more"></a></p><p><strong>这一年是大三和大四的一年。</strong></p><p>大一大二的时候总觉得时间还长，毕业似乎遥遥无期，所以一部分时间在不紧不慢地学习。但是到了大三，一下子好像感觉毕业就在眼前。大学还是一个温室，可以供着我们慵懒，可以包容我们犯错。所以最后我明白，其实对于毕业临近的感觉更多是一种对于外面世界的位置的天生恐惧。但是毕业总是要来的呀，工作也是要找的呀，既然躲不开，那就来吧。</p><p><strong>这一年是找工作的一年。</strong></p><p>去年过年的时候，就准备复习，去做好知识储备和整理，好让这一年的招聘不那么被动。结果寒假果然还是没能完成计划好的部分。好像我的执行力也没有想象中的那么强。</p><p>开学以后，春招很快就开始了，而且比我想象的还要快。<br>寒假之前就有学长学姐们帮内推，但一直都还没有任何回应，所以刚刚开学的时候，甚至还是有些松懈的，有空就看看书，累了就看看电影打打游戏什么的。然后在一个周五的晚上，我接到了京东的面试电话。</p><p>表达糟糕，逻辑混乱，大脑一片空白。十分钟的面试一下子叫醒了我，该来的总会来的，春招，就这么开始了。</p><p>那天晚上没有睡好，我躺在床上，从一开始的焦虑中慢慢冷静下来，尽量客观地评估了一下自己：基础知识掌握的还可以，知识储备也有在做但是没有好好整理，一些点没有串联起来，导致没能形成完整的知识体系，自然面试的时候不能逻辑清晰地表达出来。好，问题差不多找到了，那以现在的进度，能不能赶得上这一波春招呢。我心里没数。</p><p>然后接下来的两个月的时间，大概是大学生活里最辛苦也最充实的生活了。<br>有一句话说：每天叫醒你的，不应该是闹钟，而应该是梦想（差不多就是这个意思吧）。只不过对于我来说，梦想还谈不上，更多的其实是压力，一种危机感。</p><p>坚持每天九点之前起床，然后开始一天的学习计划，其实学校安排的课有一些之前已经自己学过了，我选择逃掉，去自习室看书，做笔记，然后每天晚上总结。那段时间补了很多平是没有注意到的细节，尤其是一些实现原理。之前看博客去学习的时候，博主们可能会漏掉一些看起来好像不是很重要的内容（那部分不是真的不重要，而是博主已经掌握了，可能觉得没有必要再赘述），但是静下心来看书，一行一行分析源码，才能获得自己的领悟。<br>所以我要说三遍：避免看二手内容学第一遍！！！避免看二手内容学第一遍！！！避免看二手内容学第一遍！！！<br>这个过程并没有想象中那么枯燥，反而不时有一种恍然大悟的感觉。我还是很享受这种感觉的。<br>当然这个过程也花费了比我想象中更多的时间－－欠下的果然总是要还得。</p><p>要说努力有什么结果的话，我觉得更多的是对自己能力的把握。换句话说就是，心里越来越有数。</p><p>然后后面开始了大波的春招面试笔试，我还是在一边学习一边准备。特别幸运身边有一群一起学习一起找工作的小伙伴们，大家一起交流学习经验一边互相加油打气，还能从更优秀的小伙伴身上看到自己的不足然后花时间马上补起来。</p><p>面试中的种种，也只有经历过了才懂，这部分没有更多可说的了，我很感激自己，在回头看的时候，也没有什么遗憾，毕竟能做的努力也都做了，无论结局如何，这段时光都是充实而美好的。</p><p>春招的结尾，也拿到了几个理想的暑假实习offer。</p><p><strong>春招至此告一段落</strong></p><p>有点流水账哈哈哈，但是人生可能本来就是流水账而已，要说有点什么意义在里面的话，可能也是对于自己的意义远大于自己对于别人的意义。</p><p>春招结束后，找时间和女票一起去成都玩了几天，这好像也是我大学这几年里为数不多去省外玩。<br>有很多大学的小伙伴经常在社交圈里发他们又去哪里玩啦，我有羡慕他们能去看看大好河山，但是也不知道我为啥这几年也没有什么出游计划，可能之前也去过挺多地方吧，也可能是单纯的懒。</p><p>我们凑了一点钱，搭着西成高铁去看大熊猫逛宽窄巷子吃火锅吃串儿……<br>我看着她，心想，我好喜欢好喜欢你呀。</p><p>然后过了不久，她就毕业了，去了魔都，我们的距离一下子拉长了好远。</p><p><strong>然后暑假我就要动身去深圳实习了</strong></p><p>行李很轻，只带了一点衣服，一个电脑，一叠笔记，两本书。<br>一起实习的是三个211的研究生，就我一个双非本科小菜鸡。<br>而且，我一个iOS技术栈的小菜鸡转岗到了Android组，做小程序……</p><p>其实在去之前，或者更早一些，拿到实习offer的时候，我是打算好好争取实习留用的机会直接拿转正offer的。但是看这个情况，太玄了。</p><p>入职之后也有萌生退意，想着我要不就撤吧，回学校继续学习，然后争取秋招时候能拿到不错的offer，这毕竟是我比较有把握的一条路。转念一想，留用也是一个机会，我现在的争取其实可以多一个机会，等我发现自己对留用的确没有一点点把握的时候，我回学校再拼一拼，更废寝忘食一些，也还是来得及的。</p><p><strong>然后就是实习了</strong></p><p>实践中暴露出来了很多问题，有的是我之前没发现的，有的是发现了但是没有多在意的。总之，实习还是挺累的，每天晚上回到青旅都要再挤时间学习新东西，因为第二天可能就要用得到，等到用的时候再学就来不及了。期间也自我怀疑过，也在犹豫要不要回学校，不过好在每次都想着，再试试，再试试，就坚持了下去。</p><p>期间我的生日恰好是一个工作日，组里的前辈们在会议室准备了surprise，蛋糕，生日歌……想想我好像也挺久没和小伙伴们一起过生日了，随着长大，好像生日也变得没有那么那么重头戏了。不过还是很感动，没想到异国他乡（呸我又没出国）还能和大家一起过生日，我也要好好加油呀，总不能辜负大家的一片好心呀。</p><p>最后的考核也来的很早，时间提前再提前，于是匆匆准备PPT，准备答辩内容，准备语言表达……<br>要说能通过考核的功劳，其实很大一部分也是前辈们的帮助鼓励，和信任。<br>我知道自己掌握的程度还远远不够，这段时间中暴露出的问题，我回学校还有机会去改进，毕竟在学校，我就是学生，学生的工作就是学习。能够有时间可以专门用来学习，是多么轻松美好的事情啊。</p><p>然后就开学了，我就一不小心成了大四的老学长。<br>学校这学期还安排了几门课程，所以只能再匆匆赶回学校。<br>再见到小伙伴们，大多也是从实习的公司回到学校的。秋招的大潮已经在靠近了，大家再准备投秋招的简历，我考虑女票在上海，就多投了几家上海的公司，结果很多公司的截至时间已经到了，结果上海的面试机会很少，我还是拿起了笔记和代码去复习，好在这几个月虽然没怎么看，竟然也不至于多么生疏，最终也拿到了几家还不错的offer。综合考虑了之后，还是考虑签去实习的公司。</p><p><strong>就这样，秋招也就结束了。</strong></p><p>该来的总会来，这一年的求职之路加上运气的加持，也算是走到了终点－－其实也是起点。</p><p>这一年没有写日记，这个好习惯从大学开始不久就荒废掉了，怪可惜的。</p><p>这一年练字坚持了一个多月，最终还是废在了半路上。</p><p>这一年开始异地恋，吵过很凶的架，也说着很甜的话。</p><p>这一年读了几本书，也没顿悟到什么大道理。</p><p>这一年没回几次家，没好好陪陪家人，下一年却要离家更远。</p><p>这一年……</p><p><strong>这一年已经匆匆远去啦。</strong></p><hr><h3 id="2019，你好。"><a href="#2019，你好。" class="headerlink" title="2019，你好。"></a>2019，你好。</h3><h3 id="2018，再见。"><a href="#2018，再见。" class="headerlink" title="2018，再见。"></a>2018，再见。</h3>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初识SVN</title>
      <link href="/2018/07/18/%E5%88%9D%E8%AF%86SVN/"/>
      <url>/2018/07/18/%E5%88%9D%E8%AF%86SVN/</url>
      <content type="html"><![CDATA[<p>之前使用的一直是git，以至于一直以为git是绝大部分开发者的选择，直到后来知道了也会有不少人选择用SVN去做版本控制。于是我就学习了一下SVN，去了解一下这个SVN和git有什么异同。<br><a id="more"></a></p><h1 id="SVN是什么"><a href="#SVN是什么" class="headerlink" title="SVN是什么"></a>SVN是什么</h1><p>Apache Subversion 是SVN的全称。在这之前还有一个传统的版本管理工具是CVS，这个工具并没有分支的机制，现在已经被SVN全面超越了（看网上的资料大概是这个样子的，但是我自己实际还没有使用CVS，以后会补上相关的对比的）。</p><p>比起git，SVN更像是一个文件管理器，不过它会跟踪整个文件夹内容的修改，粒度是行，该有的分支管理、合并分支、版本控制样样都有。最大的不同是：git是一个分布式的版本控制工具，这就意味着在每一个终端上，它都有着完整的仓库，有着完整的版本控制功能。而SVN是一个中心化的版本控制器，中心化意味着需要有一个服务器来做功能的支持。这就意味着，一旦SVN服务器挂了，那整个项目的SVN使用都会受到影响。</p><p>还有一个不同的地方在于，即使服务器上面也是看不到源代码的，所有的内容都是以一种特别的方式</p><h1 id="SVN服务器"><a href="#SVN服务器" class="headerlink" title="SVN服务器"></a>SVN服务器</h1><p>因为SVN是中心化的，那就必须先要配置一个服务器，不然是无法使用SVN的，也没有办法学习。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先需要手动新建一个目录，作为所有版本库的存储位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir all_SVN_repo</span><br></pre></td></tr></table></figure><p>因为一个服务器是可以提供服务给很多个版本库的，所以这里起名字就明确为all。</p><p>切换到这个目录下，然后用命令创建一个版本库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svnadmin create ./repo_1</span><br></pre></td></tr></table></figure></p><p>这时候会发现在all_SVN_repo的文件夹下出现了一个刚新建的目录：repo_1</p><p>可以先启动这个svn服务器试试(先cd到all_SVN_repo目录下)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svnserve -d -r ./repo_1</span><br></pre></td></tr></table></figure></p><p>当然了，本篇所有的相对路径都可以换成绝对路径啦。<br>这样就可以启动这个svn服务器了！<br>这里的参数-r是单目录的启动方式。因为目前只创建了一个库。当然用多库方式启动也是可以的。</p><p>可选参数有–listen-port xxxx，表示此服务的端口是xxxx，如果不指定这个参数的话，默认会开启3690这个端口。这个端口在后面会用到，所以这里需要记好。</p><p>开启服务之后并不会占用终端的输入状态，所以这个命令一敲回车就好了，如果没有报错信息的话，它就已经在运行了。</p><p>（未完待续… …）</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>《Android第一行代码》读书笔记（下）</title>
      <link href="/2018/07/18/Android-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2018/07/18/Android-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>为什么要分个上下呢？因为在实际的使用中发现如果整篇文章过长的话，可能导致博客的性能十分低下，无论是admin的管理界面还是整个静态网页。暂时还没有精力去优化一下，就暂时分个上下篇吧。<br><a id="more"></a></p><h1 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Android中的每个app都可以对自己感兴趣的广播进行注册，这样它就可以收到它关心的广播内容。这些广播有的是来自于系统，有的是来自其他app的。</p><p>广播分为两种：<strong>标准广播、有序广播</strong></p><h3 id="标准广播"><a href="#标准广播" class="headerlink" title="标准广播"></a>标准广播</h3><p>是一种完全异步执行的广播，在广播发出之后，所有注册的接收器会在同一时间接收到这条广播，效率较高、无法截断。</p><h3 id="有序广播"><a href="#有序广播" class="headerlink" title="有序广播"></a>有序广播</h3><p>是同步执行的广播，在广播发出之后，同一时间只会有一个接受者去接受这个广播，然后剩下的接受者依次轮流接收到广播。</p><p>优先级高的广播接收者就先收到，并且有机会截断正要继续传递的广播，这样后面的接受者就接收不到了。</p><h2 id="接收系统广播"><a href="#接收系统广播" class="headerlink" title="接收系统广播"></a>接收系统广播</h2><p>Android系统内置了很多系统级别的广播，在app中可以监听这些广播来得到系统的状态。比如手机开机完成之后、电池电量发生变化、时间、时区发生变化等等情况都会发出广播。</p><p>app在注册接收器的时候有两种方式：在代码中注册，或者在在AndroidManifest中注册。</p><p>前者也称为动态注册，后者也称为静态注册。</p><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册需要一个接收器类，这个新类继承自BroadcaseReceiver，并重写onReceive（）方法，这样如果有广播到来，onReceive（）方法就会被调用。具体的处理逻辑写在这里就会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IntentFilter   intentFilter;</span><br><span class="line">    <span class="keyword">private</span> NetworkChangeReceiver networkChangeReceiver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        intentFilter.addAction(<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span>);</span><br><span class="line">        networkChangeReceiver = <span class="keyword">new</span> NetworkChangeReceiver();</span><br><span class="line">        registerReceiver(networkChangeReceiver,intentFilter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unregisterReceiver(networkChangeReceiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NetworkChangeReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(context,<span class="string">"I had received a Broadcast"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Activity类里面自定义了一个内部类NetworkChangeReceiver，继承自BroadcastReceiver，重写了父类的onReceive（）方法，这样一来就有了一个接收器类。</p><p>然后Activity加了一个该类的实例，然后加了一个意图过滤器，去捕获系统的某个事件广播。</p><p>最后调用registerReceiver的方法注册一个接受者，传入两个参数：接收器、过滤器。</p><p><strong>在Activity被销毁的时候需要手动移除通知接受者。</strong></p><p>运行程序，可以看到在注册完成的时候会调用一遍onReceive方法，之后就是在网络状态发生改变的时候会调用。</p><p><strong>除此之外，我们还可以获取当前网络的可用状态</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityManager connectivityManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();</span><br><span class="line"><span class="keyword">if</span>(networkInfo != <span class="keyword">null</span>&amp;&amp;networkInfo.isConnected())&#123;</span><br><span class="line">Toast.makeText(context,<span class="string">"network is available"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Toast.makeText(context,<span class="string">"network is disable"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先通过getSystemService（）方法得到ConnectivityManager的实例，这个是一个专门管理网络连接的系统服务类，然后对这个实例调用getActiveNetworkInfo（）的大搜系统的网络状态。判断这个状态，显示不同的toast就可以了。</p><p><strong>注意：Android系统为了保护用户安全和隐私，规定了如果程序需要进行一些敏感信息的操作，就必须在配置文件中声明权限，否则程序就崩了。所以就需要在AndroidManifest文件里加入权限声明：</strong><br>emmm，新版的AndroidStudio已经自动加了，很好用呀，但是还是需要知道有这个权限的存在，这个机制倒是和iOS开发里面的info.plist文件很相似。</p><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>前面的动态注册方法可以自由控制广播接收器的注册和取消很灵活，但是也有缺点：要开启广播接收器就必须要让app先运行起来。这样就没有办法实现让程序在没有启动的情况下就能接受到广播。</p><p>这就需要静态注册的方式了：</p><p>AndroidStudio提供了快捷方式去做静态注册：在java文件夹的包名文件夹下右键-New-Other-Broadcast Receiver，在弹出的窗口里选Exported和Enable选项然后Finsh就可以完成创建。</p><p>然后会有一个新的java类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BootCompleteReceiver extends BroadcastReceiver &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        // TODO: This method is called when the BroadcastReceiver is receiving</span><br><span class="line">        // an Intent broadcast.</span><br><span class="line">        Toast.makeText(context,&quot;boot complete&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个java类就是一个静态方式的广播接收器。所以覆写onReceive（）方法就可以实现自己想要的逻辑。</p><p>在此之后，还需要在AndroidManifest文件里面去声明权限，前面看到过关于网络的权限AndroidStudio已经自动写了，但是这次并没有写获取开机的通知的代码，就需要我们手动写一个这样的语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>不过AndroidStudio还是为我们自动写了一些东西的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line">android:name=&quot;.BootCompleteReceiver&quot;</span><br><span class="line">android:enabled=&quot;true&quot;</span><br><span class="line">android:exported=&quot;true&quot;&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p><p>自动添加了一个receiver的字段，声明了name等信息，不过中间的intent-filter字段是需要自己写的，这个是为了说明让接受者捕获什么样的广播。所以这里写了一个action，声明了要监听的是BOOT_COMPLETED这个特定的消息。</p><p><strong>需要注意的是：接收器的java类里面不要添加过于复杂的逻辑或者一些耗时操作，因为接收器里是不允许开启线程的，当onReceive（）的方法里运行了很长时间都没有结束，程序就会报错的。</strong></p><h2 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h2><p>前面也说过广播有标准和有序两种，接下来就通过发送广播去感受一下两种广播的不同</p><h3 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h3><p>发送标准广播很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure></p><p>新建一个意图，然后调用sengBroadcast（）方法把这个意图发送出去就好了。</p><p>而且因为是使用intent发送的广播，所以还是可以携带数据等信息给接受者。</p><h3 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h3><p>如果要发送有序广播其实只需要改动一行代码就可以实现了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendOrderedBroadcast(intent,null);</span><br></pre></td></tr></table></figure></p><p>这个方法的方法名里多了order，表示是有序的。</p><p>另外，对于接受者，就需要声明一下自己的接受优先级：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:priority =&quot;100&quot;</span><br></pre></td></tr></table></figure></p><p>表示自己的优先级设置为最高，保证可以在AnotherBroadcastReceiver之前就收到广播。</p><p>再者，如过接收器的java类的onReceive（）方法的实现中可以调用<br>abortBroadcast()方法来阻断该条有序广播的继续传播。</p><h2 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="使用本地广播"></a>使用本地广播</h2><p>前面也说过，广播机制是系统全局的，也就是说，我们app发送的广播其他的app也可以收到，其他app发的广播我们也可以收到。这样就可能带来一些安全性的问题：万一别的app获取了我们的app广播数据，或者他们一直发送大量垃圾广播。</p><p>所以Android引入了一套本地广播机制，这个机制发出的广播只能够在app内部传递，接收器也不会接受除了自己app之外的广播了。</p><p>还是从发送和接收的两个方面来看一下不同点：</p><h3 id="发送本地广播"><a href="#发送本地广播" class="headerlink" title="发送本地广播"></a>发送本地广播</h3><ul><li>首先需要一个LocalBroadcastManager的实例属性</li><li>和前面不一样的是，这里需要的这个管理器是需要用get的方法去获取实例的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localBroadcastManager = LocalBroadcastManager.getInstance(this);      </span><br><span class="line">localBroadcastManager.sendBroadcast(intent);</span><br></pre></td></tr></table></figure><ul><li>然后就是对这个管理器调用sendBroadcast（）方法去发送意图。<br>可以看到其实基本上和标准广播的发送没有什么不同，只不过多了LocalBroadcastManager类的使用。</li></ul><h3 id="接收本地广播"><a href="#接收本地广播" class="headerlink" title="接收本地广播"></a>接收本地广播</h3><p>这个其实和前面的标准广播的套路也很类似：</p><ul><li>Activity要有一个接收器类的实例</li><li>写好intent的监听条件</li><li>通过对localBroadcastManager调用registerReceiver（）方法去注册本地广播接受者。</li><li>在Activity的onDestroy（）方法里对localBroadcastManager调用unregisterReceiver（）注销接受者。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本地的广播是没有办法注册为静态方式的，因为它的存在周期也就是在app的生存周期之内，所以也没有必要用静态的方式。</p><p>本地广播对比一般广播的优势：</p><ul><li>可以明确地知道这类广播不会作用在app之外，比较安全。</li><li>其他的程序无法发送广播进来，不用担心恶意广播的安全隐患。</li><li>因为只作用在app内部，所以效率也会更高。</li></ul><h1 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>持久化存储其实就是把内存中的数据存到外外存上。</p><p>Android主要提供了三种方式去做持久化：文件、SharedPreference、数据库存储。其实还是可以把数据存在SD卡里但是后来的手机都没有SD卡的插槽了，而且也比较不安全。</p><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>文件存储是一种最基本的数据存储方式，它不对内容进行处理，直接原封不动地存储，比较适合用来存储一些简单的文本数据或者二进制数据。如果需要实现复杂的文本存储，就需要自定义格式规范。</p><h3 id="存储到文件"><a href="#存储到文件" class="headerlink" title="存储到文件"></a>存储到文件</h3><p>Context类有一个openFileOutput（）的方法，用于将数据存储到指定的文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void save()&#123;</span><br><span class="line">String data = &quot;Data to be save&quot;;</span><br><span class="line">FileOutputStream out = null;</span><br><span class="line">BufferedWriter writer = null;</span><br><span class="line">try&#123;</span><br><span class="line">out = openFileOutput(&quot;data&quot;,Context.MODE_PRIVATE);</span><br><span class="line">writer = new BufferedWriter(new OutputStreamWriter(out));</span><br><span class="line">writer.write(data);</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">try&#123;</span><br><span class="line">if (writer != null)&#123;</span><br><span class="line">writer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先有一个待存储的data字符串。然后新一个文件输出流的对象FileOutputStream类的实例。和一个BufferedWriter的实例。</p><p>openFileOutput（）方法的两个参数分别是文件名（不可包含路径）和文件操作模式（MODE_PRIVATE和MODE_APPEND），然后返回一个FileOutputStream对象，这个对象可以用java流的方式写入文件。</p><p>借助这个流对象构建一个BufferedWriter对象，这个对象就可以把某个字符串写入到文件里面了。</p><p>所以写入文件的流程其实就是三步：</p><ul><li>先打开一个到文件的输出流（文件输出流）</li><li>然后用文件输出流创建一个“输出流写入器”</li><li>再用输出流写入器创建一个“缓冲写入器”将数据写入数据流。</li></ul><p><strong>之所以不用写文件路径，是因为默认都会放到“data/data/package name/files”文件夹下</strong> </p><h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><p>从文件中读数据也是需要一个openFileInput（）方法。只接受一个参数——文件名，同样也是从data/data/package name/files文件夹下去找的。然后返回一个FileInputStream对象。</p><p>然后还是通过java流的方式读入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public String load()&#123;</span><br><span class="line">    FileInputStream fileInputStream = null;</span><br><span class="line">    BufferedReader bufferedReader = null;</span><br><span class="line">    StringBuilder content = new StringBuilder();</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        fileInputStream = openFileInput(&quot;data&quot;);</span><br><span class="line">        bufferedReader = new BufferedReader(new InputStreamReader(fileInputStream));</span><br><span class="line">        String line = &quot;&quot;;</span><br><span class="line">        while ((line  = bufferedReader.readLine()) !=null)&#123;</span><br><span class="line">            content.append(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        if(bufferedReader != null)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return content.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读入文件其实也是三步：</p><ul><li>创建文件输入流</li><li>用文件输入流创建输入流读取器 </li><li>用输入流读取器创建一个缓冲读取器</li></ul><p>然后当读入的字符不为空，就循环读取就可以了。可以用一个StringBuilder去拼接字符串。</p><p>（PS：可以用TextUtils.isEmpty（）方法来判断字符串的空值情况，这个方法可以同时判断两种情况——当字符串对象为null或者是一个空串，都可以返回true。）</p><h2 id="ShardPreferences存储"><a href="#ShardPreferences存储" class="headerlink" title="ShardPreferences存储"></a>ShardPreferences存储</h2><p>这种存储是用键值的方式去存储数据(xml格式)，支持多种不同的数据类型，比文件的存储要方便很多。</p><h3 id="数据存入"><a href="#数据存入" class="headerlink" title="数据存入"></a>数据存入</h3><p>要使用SharedPreferences存储，就需要先获取到SharePreferences对象，Android提供了三种方法去获取：Context类中的get方法、Activity类中的get方法、PreferenceManger类中的getDefaultShared方法。</p><ul><li><p>获取SharedPreferences</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getSharedPreferences(&quot;data&quot;,MODE_PRIVATE);</span><br><span class="line">//这个方法是Context类中的，接受两个参数，第一个是文件名，存放在data/data/package name/shared_prefs目录下，如果不存在就会新建一个文件，第二个参数是操作模式，这里用的是private模式，表示其他的app无权操作，其他模式已经废弃。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getPreferences(MODE_PRIVATE);</span><br><span class="line">//这个方法时Activity中的，只不过只接收一个参数，它会自动将当前活动的类名作为SharedPreferences的文件名。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PreferenceManager.getDefaultSharedPreferences(this);</span><br><span class="line">//这个是PreferenceManager类的方法，接收一个Context参数，并自动使用当前app的包名作为前缀作为文件名</span><br></pre></td></tr></table></figure></li></ul><p>上面的三个方法都是为了得到SharedPreferences的，得到之后就可以进行下一步了：</p><ul><li>对SharedPreferences对象调用edit（）方法来获取一个SharedPreferences.Editor的对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;,MODE_PRIVATE).edit();</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>向editor中添加数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">editor.putInt(&quot;age&quot;,21);</span><br><span class="line">editor.putString(&quot;name&quot;,&quot;paopao&quot;);</span><br><span class="line">editor.putBoolean(&quot;single&quot;,false);</span><br></pre></td></tr></table></figure></li><li><p>对editor调用apply（）方法将前面添加的数据提交，就完成了存储操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editor.apply();</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据取出"><a href="#数据取出" class="headerlink" title="数据取出"></a>数据取出</h3><p>取数据的步骤更为简单：</p><ul><li><p>先获取到SharedPreferences对象，和前面的方法一样。</p></li><li><p>对SharedPreferences对象调用getXXX方法，get方法传入两个参数，第一个参数为键名，第二个参数为默认值——如果对应的键没有取到值，就返回默认值。</p></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>其实这个SharedPreferences和iOS中的NSUserDefault非常相似，只不过后者用单例模式实现。但是Android中的用PreferenceManager的方法获取到的SharedPreferences其实也可以当做一个单例来使用，因为同一个app的包名是一样的。</p><h2 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h2><p>Android内置了SQLite数据库，这是一种轻量级的关系型数据库，运算速度快，占用资源少（一般几百KB内存就够了），支持标准的SQL语法，遵循ACID事务（即原子性、一致性、隔离性、持久性）。</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>Android为了能够更方便地使用数据库，专门提供了一个SQLiteOpenHelper的帮助类。它是一个抽象类。所以需要我们自己构建子类去实现具体的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MyDatabaseHelper extends SQLiteOpenHelper&#123;</span><br><span class="line">    private static final String CREATE_BOOK = &quot;create table Book (&quot;</span><br><span class="line">            +&quot;id integer primary key autoincrement, &quot;</span><br><span class="line">            +&quot;author text, &quot;</span><br><span class="line">            +&quot;price real,&quot;</span><br><span class="line">            +&quot;pages integer,&quot;</span><br><span class="line">            +&quot;name text)&quot;;</span><br><span class="line">    private Context mContext;</span><br><span class="line">    public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory,int version)&#123;</span><br><span class="line">        super(context , name , factory , version);</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(SQLiteDatabase sqLiteDatabase) &#123;</span><br><span class="line">        sqLiteDatabase.execSQL(CREATE_BOOK);</span><br><span class="line">        Toast.makeText(MainActivity.this,&quot;create database succeded&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先需要新建一个类，继承自SQLiteOpenHelper，类中需要有一个用于创建数据库的SQL语句。还要有一个context的实例变量来暂存构造方法中传入的context。</p></li><li><p>重写该类的构造方法，将参数中的context传给成员变量。四个参数的意义分别是：上下文、数据库名、自定义光标（一般为null）、数据库版本号。</p></li><li><p>重写onCreate（）方法，对SQLiteDatabase的实例调用execSQL（）方法去执行前面写好的SQL语句。</p></li><li><p>重写onUpgrade（）方法，加入想要执行的逻辑代码。</p></li></ul><p>这个数据库帮助类就基本完成了，要使用这个类去创建数据库，就要在Activity的java类中去创建一个该帮助类的实例，</p><ul><li><p>创建该类的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyDatabaseHelper myDatabaseHelper = new MyDatabaseHelper(this,&quot;BookStore.db&quot;,null,1);</span><br></pre></td></tr></table></figure></li><li><p>对实例调用创建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myDatabaseHelper.getWritableDatabase();</span><br><span class="line">//方法一：当数据库不可写入的时候，会报异常</span><br><span class="line">myDatabaseHelper.getReadableDatabase();</span><br><span class="line">//方法二：当数据库不可写入的时候，会以只读方式打开</span><br><span class="line">//两个方法都可以打开一个已存在数据库或者新建一个数据库并返回一个可读写数据库的对象。</span><br></pre></td></tr></table></figure></li></ul><h3 id="升级数据库"><a href="#升级数据库" class="headerlink" title="升级数据库"></a>升级数据库</h3><p> 前面覆写了onUpgrade（）的方法，但是没有加入逻辑代码。如果需要在原来的onCreate（）中加入别的SQL语句的操作，就会发现，已经存在了数据库之后，原来的onCreate（）不能正确执行，因为数据库已经存在。</p><p> 在onUpgrade（）方法中，先把数据表删除了，然后再调用更新了代码的onCreate（）方法。</p><p> 而且，onUpgrade（）不是手动调用的，它的触发机制是在自定义帮助类的初始化的时候，在版本参数中传入一个大于上一个版本数的数字就好了。</p><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>既然要操作数据库，当然可以用SQL语句去完成，但是为了照顾开发者的SQL水平，Android提供了不用SQl语句操作数据库的方法。</p><p>前面用getWritableDatabase（）或getReadableDatabase（）返回的是一个SQliteDatabase对象，对这个对象调用方法就可以对数据库操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDatabase db = myDatabaseHelper.getReadableDatabase();</span><br><span class="line"></span><br><span class="line">ContentValues values = new ContentValues();</span><br><span class="line">values.put(&quot;name&quot;,&quot;Android first code&quot;);</span><br><span class="line">values.put(&quot;author&quot;,&quot;paopao&quot;);</span><br><span class="line">values.put(&quot;pages&quot;,454);</span><br><span class="line">values.put(&quot;price&quot;,16.96);</span><br><span class="line">db.insert(&quot;Book&quot;,null,values);</span><br><span class="line">values.clear();</span><br></pre></td></tr></table></figure><p>新建一个ContentValue来组装单条数据项，然后对SQLiteDatabase实例调用insert（）方法，接收三个参数：表名、未指定数据给某些可为空的列自动赋值为NULL、单条数据项。</p><p>后面如果需要组装多次，可以重复使用ContentValues的实例，每次用clear方法清空数据就可以了。</p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>SQLiteDatabase还提供了update（）方法用于更新数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values.put(&quot;price&quot;,10.99);</span><br><span class="line">db.update(&quot;Book&quot;,values,&quot;name  = ?&quot;,new String[]&#123;&quot;Android first code&quot;&#125;);</span><br></pre></td></tr></table></figure></p><p>先构造需要修改的数据项，然后对SQLiteDatabase调用update（）方法去更新数据。</p><p>update（）方法接收四个参数：表名、数据项、where语句部分（这里的？是一个占位符，可以指定第四个参数去替换这里的？）、用于替换占位符的字符串。</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.delete(&quot;Book&quot;,&quot;page &gt; ?&quot;,new String[]&#123;&quot;500&quot;&#125;);</span><br></pre></td></tr></table></figure><p>删除数据就更简单，接收三个参数：表名、where语句、用于替换占位符的String对象。</p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>查询是这几种数据库操作里面最复杂的操作了。</p><p>同样的，SQLiteDatabase提供了query（）方法用于查询数据，这个方法很复杂——需要传入七个参数。(拍照渣像素，见谅)<br><img src="https://s1.ax1x.com/2018/06/23/P9iCh6.jpg" alt="P9iCh6.jpg"></p><p>然后这个函数会返回Cursor对象，包含着若干行数据。<br>可以对cursor实例对象调用moveToFirst（）和moveToNext（）方法来切换行的跳转。</p><p>对cursor对象调用getColumnIndex（）传入列名可以得到某一列在表中对应位置的索引，然后再对cursor调用getInt等方法从得到的索引中取出当前行的具体类型的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cursor cursor  = db.query(&quot;Book&quot;,null,null,null,null,null,null,);</span><br><span class="line">cursor.getString(cursor.getColumnIndex(&quot;name&quot;));</span><br></pre></td></tr></table></figure></p><p>(这个只是展示方法调用的，实际使用还需要加入一些判空等操作和行的操作)。</p><h3 id="直接使用SQL语句操作数据库"><a href="#直接使用SQL语句操作数据库" class="headerlink" title="直接使用SQL语句操作数据库"></a>直接使用SQL语句操作数据库</h3><p>Android充分考虑不同人的编程习惯，也支持开发者直接使用SQL操作数据库：</p><p>查询数据库用SQLiteDatabase的rawQuery（）方法，其他的操作都是用调用execSQL（）方法，接受两个参数，一个由语句和占位符构成的公式，一个字符串数组去逐个替换占位符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.execSQL(&quot;insert into Book(name,author,pages,price)values(?,?,?,?)&quot;,new String[]&#123;&quot;a book&quot;,&quot;me&quot;,&quot;454&quot;,&quot;16.61&quot;&#125;);</span><br><span class="line">db.rawQuery(&quot;select * from Book&quot;,null);</span><br></pre></td></tr></table></figure></p><h2 id="使用LitePal操作数据库"><a href="#使用LitePal操作数据库" class="headerlink" title="使用LitePal操作数据库"></a>使用LitePal操作数据库</h2><p>这个是一个开源库，采用了对象关系映射ORM的模式，不用编写SQL语句就可以完成建表和各种增删改查等骚操作。</p><p>鉴于这个也是第一次在Adroid开发中使用开源库，所以顺带熟悉一下怎么集成第三方框架</p><h3 id="集成第三方框架"><a href="#集成第三方框架" class="headerlink" title="集成第三方框架"></a>集成第三方框架</h3><p>很多的开源框架会提交到jcenter上面，所以只需要在app/build.gradle里面声明引用该开源库就可以了，这一点和cocoapods很相似。当然了，也是可以下载别人的开源库的源代码然后导入包的，只不过这种方式方便很多。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.litepal.android:core:1.4.1'</span></span><br></pre></td></tr></table></figure></p><ul><li><p>在dependencies字段中添加上面的语句，然后同步gradle就可以集成该库了。</p></li><li><p>接下来使用的时候，先在app/src/main目录下新建一个asset目录，然后在asset目录下新建一个litepal.xml文件，写入如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">litepal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dbname</span> <span class="attr">value</span> = <span class="string">"BookStore"</span>&gt;</span><span class="tag">&lt;/<span class="name">dbname</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span> <span class="attr">value</span> = <span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">litepal</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>其中的dbname是用于指定数据库名，version用于指定数据库的版本号，list用来指定映射模型，这个一会再写。</p><ul><li>最后在AndroidManifest.xml中配置：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:name=<span class="string">"org.litepal.LitePalApplication"</span></span><br></pre></td></tr></table></figure></li></ul><p>为什么要这样配置呢？再后面一些会说的。</p><p>到此为止就完成了，看起来其实好像要比cocoapods使用还是要麻烦一些的。</p><h2 id="创建和升级数据库"><a href="#创建和升级数据库" class="headerlink" title="创建和升级数据库"></a>创建和升级数据库</h2><p>前面提到过这个litepal是用了ORM，那和前面的数据库操作有什么不同呢？</p><p>这个对象关系映射模式，使得开发者可以用面向对象的思维来操作数据库。</p><p>试一下：</p><ul><li>先新建一个类Book，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id ;</span><br><span class="line"><span class="keyword">private</span> String author;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> pages;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>然后按Alt+Insert键，可以自动生成getter和setter方法（这么好用？！），这样这个Book类就对应数据库中的一张Book表，而每一个成员变量就对应一列</p><ul><li>接下来还需要将Book类添加到映射表中——就是前面没写完的list部分：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">litepal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dbname</span> <span class="attr">value</span> = <span class="string">"BookStore"</span>&gt;</span><span class="tag">&lt;/<span class="name">dbname</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span> <span class="attr">value</span> = <span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.example.ifan.databasetest.MainActivity.Book"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">litepal</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>这里一定要使用完整的类名。如果有多个类需要映射，就都添加到list里面就可以了。</p><ul><li>调用LitePal.getDatabase（）方法就可以创建数据库了。</li><li>要升级数据库也很简单，不用像之前一样去drop掉表然后再建新表了，直接在相关的类中做列的修改，然后在litepal.xml中修改版本号就可以了。不用担心，原来的数据还是保留下来的，不用担心数据的丢失。</li></ul><h2 id="添加数据-1"><a href="#添加数据-1" class="headerlink" title="添加数据"></a>添加数据</h2><p>之前要添加数据的时候，需要先新建一个ContentValues对象作为新的一行的数据项，然后向其中添加数据……</p><p>现在，只需要新建一个模板类的实例，对成员变量赋值，然后对对象调用save（）方法就可以了。</p><p>之前的模板类没有写所继承的父类，因为光进行表的管理操作本来就不需要继承别的类就可以实现。但是如果要进行CRUD操作，还是要继承DataSupport类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Book book = <span class="keyword">new</span> Book();</span><br><span class="line">book.setName(<span class="string">"hi you"</span>);</span><br><span class="line">book.setPrice(<span class="number">12.655</span>);</span><br><span class="line">book.save();</span><br></pre></td></tr></table></figure></p><p>最后这个save（）方法就是DataSupport类提供的，除此之外，它还提供了丰富的CRDU方法。</p><h3 id="更新数据-1"><a href="#更新数据-1" class="headerlink" title="更新数据"></a>更新数据</h3><p>更新数据有几种方法：</p><ul><li>最简单的一种是<strong>对已经存储的对象重新设值</strong><br>（PS：首先要搞清楚的是什么才算是已经存在的数据？这里的判定是通过对模板类实例调用isSaved（）方法，如果存在，就返回true。返回true有两种情况：一种是已经调用过save（）添加过数据；一种是LitePal提供了API去查询数据库，查到了就表明已经存在。）<br>所以可以对前面存储过的某条数据的部分成员变量赋值修改后的值。<br>试过之后，发现这个必须是连续操作的，重启app之后会把这一条本来表示更新的的数据重复添加。这样一来，就有了很大的局限性。</li></ul><p>那么就要用到更灵活的方法了：</p><ul><li>updateAll（）方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.updateAll(<span class="string">"name = ? and author = ?"</span>,<span class="string">"hi me"</span>,<span class="string">"me"</span>);</span><br></pre></td></tr></table></figure></li></ul><p>还是新建一个模板类，对成员变量赋值，然后用这个updataAll（）方法更新数据库，参数也比较简单，第一个参数是公式，后面若干个字符串是用于替代占位符的串。</p><p>另外，LitePal还提供了设置为默认值的方法，而不是手动设置为默认值：setToDefault（），参数中接受若干个字符串作为要重置为默认值的列名。</p><h3 id="删除数据-1"><a href="#删除数据-1" class="headerlink" title="删除数据"></a>删除数据</h3><p>对于比较简单的delete（）方法没有太大的意义，这里主要看一下另一种删除的方法：</p><p>DataSupport类提供了deleteAll（）方法来删除数据，和上面的updateAll（）用法类似，很灵活。</p><h3 id="查询数据-1"><a href="#查询数据-1" class="headerlink" title="查询数据"></a>查询数据</h3><p>前面的query（）方法里面要传入7个参数，颇为不便，LitePal做了很多优化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Book&gt; books = DataSupport.select(<span class="string">"name"</span>)</span><br><span class="line">                              .where(<span class="string">"pages &gt;30"</span>)</span><br><span class="line">                              .order(<span class="string">"price"</span>)</span><br><span class="line">                              .limit(<span class="number">10</span>)</span><br><span class="line">                              .offset(<span class="number">10</span>)</span><br><span class="line">                              .find(Book.class);</span><br></pre></td></tr></table></figure></p><ul><li><p>首先，LitePal的查询结果返回了一个模板类构成的List，这样就自动完成了赋值，后面的操作都围绕着List中的元素进行就可以了。</p></li><li><p>而且把众多的查询条件都以方法的方式封装，可以根据实际情况自由连缀使用。</p></li></ul><h1 id="内容提供器——跨程序共享数据"><a href="#内容提供器——跨程序共享数据" class="headerlink" title="内容提供器——跨程序共享数据"></a>内容提供器——跨程序共享数据</h1><p>之前的持久化存储部分提到过，文件的存储都开始使用本app独占的操作模式，就是为了保证数据安全，</p><p>但是有的时候需要和别的app共享一些数据——当然不是账号密码这种敏感数据！比如电话簿、短信等程序，需要开放一些数据以便二次开发，那就需要跨程序共享数据，这就需要用到内容提供器了（而且，这个Android实现跨程序共享数据的标准方式。）</p><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>内容提供器（Content Provider）提供了一套完整的机制，允许一个程序访问另一个程序的数据，同时还能保证被访问数据的安全。</p><p>emmm，书上说，要先了解一下运行时权限，好吧，歪一下。</p><h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><p>Android中其实一直有权限机制，但是都比较鸡肋。后来到了6.0时代，引用了运行时权限，为了更好地保护用户的安全和隐私。</p><h3 id="权限详解"><a href="#权限详解" class="headerlink" title="权限详解"></a>权限详解</h3><p>前面在用广播的时候就写过关于权限的东西——在AndroidManifest.xml中写过uses-permission的字段，有了这个字段之后，对于低于6.0系统的设备上安装时候就会提醒用户一些权限获取的信息，用户可以选择安装与否。</p><p>但是越来越多的app就是先都一股脑申请了权限，不管你用得到用不到，这样就容易被app滥用权限，但是对于一些常用、必用的app，又不得不同意。</p><p>6.0加入的运行时权限，使得用户不用一次性授权所有权限，而是可以在运行过程中，对具体的某一次申请进行授权。</p><p>Android中的权限分为两类：<strong>普通权限、危险权限</strong>。（其实还有一种特殊权限，但是使用的太少了就先不说了）</p><ul><li>普通权限：一些不会直接威胁到用户的安全和隐私的权限。这种权限系统会自动授权。</li><li>危险权限：一些可能会触及到用户隐私或者会对设备安全性造成影响的权限，如联系人、地理位置等，这类权限需要用户手动授权。</li></ul><p>危险权限实际上很少，大部分是普通权限，这里有张表列出了9组24个危险权限，除此之外，都是普通权限：<br><img src="https://s1.ax1x.com/2018/06/23/P9MLIU.jpg" alt="P9MLIU.jpg"></p><p>需要注意的是，虽然请求的是某一个具体的权限，但是最后一旦授权，那么这个权限所属的权限组都会获得权限。</p><h3 id="在运行时申请权限"><a href="#在运行时申请权限" class="headerlink" title="在运行时申请权限"></a>在运行时申请权限</h3><p>因为运行时动态授权的都是危险权限，所以这里只写获取危险权限的例子：</p><ul><li>第一步就是先判断用户是否已经授权：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>, Manifest.permission.CALL_PHONE);</span><br></pre></td></tr></table></figure></li></ul><p>这个方法接受两个参数：上下文、具体的权限名。<br>然后将返回值和PackageManager.PERMISSION_GRANTED作比较，如果相等，那就是已经授权了，反之则没有授权。</p><ul><li>如果已经被授予权限，就新建一个intent并设置所携带的数据，然后用StartActivity（）方法启动这个intent，就会跳转到目标的页面。</li><li>如果没有被授权，ActivityCompat.requestPermissions（）方法来申请权限。接受三个参数，第一个参数是Activity的实例变量、第二个是String数组，用来放要申请的权限名、第三个参数是请求码，传入一个整型唯一值就可以了。</li><li>前面的请求权限后面会唤起一个回调方法——onRequestPermissionResult，这个回调方法会携带garantResults参数，只要判断一下最后的授权结果就知道下一步是放弃操作还是用刚请求到的权限搞一搞事情。<br>（PS：这个回调方法每次请求授权的时候都会唤起，所以在方法里需要用请求码去区分到底是哪种类型的请求。然后判断grantReaults数组是否包含元素——长度&gt;0，然后判断grantResults的第0个元素是否和PackageMangeer.PERMISSION_GRANTED的值一致）</li></ul><h2 id="访问其他app的数据"><a href="#访问其他app的数据" class="headerlink" title="访问其他app的数据"></a>访问其他app的数据</h2><p>呼…终于搞完了权限相关的基础内容，下面就是本章的正文：访问别的app中的数据。</p><p>内容提供器一般有两种用法：</p><ul><li>一种是使用现有的内容提供器来读取和操作别的app中的数据。</li><li>另一种是创建自己的内容提供器为我们的app提供接口供别的app来访问我们的数据。</li></ul><h3 id="ContentResolver的基本用法"><a href="#ContentResolver的基本用法" class="headerlink" title="ContentResolver的基本用法"></a>ContentResolver的基本用法</h3><p>每个app如果想要访问内容提供器，就必须要借助ContentResolver类，这个类的实例可以通过Context中的getContentResolver（）方法获取到。</p><p>ContentResolver中提供了一系列的方法用于对数据进行CRUD操作，比如insert（）、updata（）、query（）等。</p><p>ContentResolver中的增删改查并不接受表名作为参数，而是使用一个Uri参数，这个参数被称为<strong>内容URI</strong>，这个内容URI为内容提供器的数据建立唯一标识符。</p><p>URI由两部分组成：authority和path。</p><p>authority是用于对不同的app做区分的，一般是app的包名+.provider；</p><p>path是对于同一app中provider的不同的表做区分的，一般作为authority的后缀。</p><p>举个例子：com.example.app.provider/table1，这个URI中的“com.example.app.provider”是authority部分，后面的“/table1”部分是path。</p><p>最后，为了辨认这个字符串是内容URI，还需要在首部加上协议声明，最终就变成了：</p><p>content://com.example.app.provider/table1</p><p>然后还需要把这个字符串解析成Uri对象才可以作为参数使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.example.app.provider/table1"</span>);</span><br></pre></td></tr></table></figure></p><p>现在就可以使用query方法查询表了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cursor cursor = getContentResolver().query();</span><br></pre></td></tr></table></figure></p><p>这个query（）方法接受五个参数：<br><img src="https://s1.ax1x.com/2018/06/24/P9DeN4.jpg" alt="P9DeN4.jpg"></p><p>query（）方法返回的依然是一个Cursor对象，前面已经使用过这个了，不再赘述。需要注意的是，使用完cursor对象之后要记得对对象调用close（）方法。</p><p>另外，对于其他的操作比如插入更新等等，也是构建一个ContentValues的对象作为行数据，然后调用insert（）、update（）方法去操作就可以了。</p><h2 id="创建自己的内容提供器"><a href="#创建自己的内容提供器" class="headerlink" title="创建自己的内容提供器"></a>创建自己的内容提供器</h2><p>需要自己新建一个类，继承自ContentProvider。ContentProvider类中有六个抽象方法，因此在实现子类的时候，需要全部实现这些方法：onCreate（）、query（）、insert（）、update（）、delete（）、getType（）。</p><p>onCreate（）一般做的就是一些创建和升级数据库的操作，返回true或者false表示内容提供器初始化成功与否。（只有ContentResolver要访问数据的时候才会调用初始化方法）</p><p>query（）、insert（）、update（）、delete（）都是用uri来确定要操作哪一张表，然后传入参数进行类似数据库的操作。</p><p>不同的是getType（）方法，这个方法返回一个Uri对象对应的MIME类型。MIME有三部分构成：以vnd开头+android.cursor.dir/或者android.cursor.item（选哪一个取决于Uri的结尾是路径还是id）+vnd.<em>authority</em>.<em>path</em></p><p><strong>内容提供器一定要在AndroidManifest.xml中注册才能使用，不过使用Android Studio的快捷方式去新建的话，会自动完成。</strong></p><h1 id="多媒体开发"><a href="#多媒体开发" class="headerlink" title="多媒体开发"></a>多媒体开发</h1><p>P 282，暂时先不看，后面会补。</p><h1 id="网络相关的开发"><a href="#网络相关的开发" class="headerlink" title="网络相关的开发"></a>网络相关的开发</h1><h2 id="WebView的使用"><a href="#WebView的使用" class="headerlink" title="WebView的使用"></a>WebView的使用</h2><p>WebView也是控件之一，所以也可以在布局文件里正常书写。不过还需要做一些设置才能正常加载网页：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebView webView= (WebView) findViewById(R.id.webview);    webView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">webView.setWebViewClient(<span class="keyword">new</span> WebViewClient());</span><br><span class="line">webView.loadUrl(<span class="string">"https://www.baidu.com"</span>);</span><br></pre></td></tr></table></figure></p><p>getSetting()方法可以设置一些浏览器的属性。<br>SetJavaScriptEnabled（）是让WebView支持JS脚本。</p><p>调用WebView的setWebViewClien</p><p>t（）方法并传入一个WebViewClient的实例变量是表示当一个网页要跳转到另一个网页的时候，还是在这个WebView中，而不是打开系统的浏览器。</p><p>调用loadUrl方法并传入一个用作URL的字符串，就可以让这个WebView加载指定的网页。</p><p><strong>因为访问网页是需要网络权限的，所以还需要AndroidManifest.xml中添加INTERNET权限</strong></p><h2 id="使用HTTP访问网络"><a href="#使用HTTP访问网络" class="headerlink" title="使用HTTP访问网络"></a>使用HTTP访问网络</h2><h3 id="使用HttpURLConnection"><a href="#使用HttpURLConnection" class="headerlink" title="使用HttpURLConnection"></a>使用HttpURLConnection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">HttpURLConnection connection = (HttpURLConnection)url.openConnection();</span><br><span class="line">connection.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">connection.setConnectTimeout(<span class="number">8000</span>);</span><br><span class="line">connection.setReadTimeout(<span class="number">8000</span>);</span><br><span class="line">InputStream in= connection.getInputStream();</span><br><span class="line">connection.disconnect();</span><br></pre></td></tr></table></figure><ul><li>先通过一个字符串创建一个URL对象。</li><li>然后对url调用openConnection（）方法开启一个http连接并赋值给一个HttpUrlConnection对象。</li><li>对这个HttpUrlConnection对象设置各种属性。</li><li>从HttpUrlConnection对象获取一个输入流。</li><li>新建一个输入流读取器。</li><li>从上一步的输入流读取器新建一个BufferedReader对象</li><li>对BufferedReader实例循环调用readLine（）来读入字符串，需要的话用StringBuilder变量拼接起来，作为http请求的response体。</li><li>完成请求之后调用disconnect（）关闭连接。</li></ul><p>上面的步骤如果直接写，就是同步请求，如果要写异步请求后面多线程的部分会说到。</p><p><strong>用http请求去访问网络同样需要网络的权限，需要和前面一样去AndroidManifest.xml文件里声明权限。</strong></p><h3 id="使用OKHttp进行网络请求"><a href="#使用OKHttp进行网络请求" class="headerlink" title="使用OKHttp进行网络请求"></a>使用OKHttp进行网络请求</h3><p>这个又是一个第三方框架，不仅在接口封装上做的简单易用，而且底层实现上也自成一派。</p><ul><li>第一步还是先配置第三方库：在gradle里面添加“com.squareup.okhttp3:okhttp:3.4.1”的依赖</li><li>首先要创建一个OKHttpClient实例。</li><li>创建一个Request对象，Request的Builder（）之后可以连缀很多个方法来丰富这个请求体。</li><li>对OKHttpClient对象调用newCall（）方法传入前面=创建好的请求体，并调用execute（）方法来发送这个请求，execute（）的返回值用一个Response类的对象接收。</li><li>可以对Response对象调用body（）方法获取响应体，然后调用string（）方法来返回一个字符串。</li></ul><p>以上就是一个GET请求的过程，说着感觉过程很多，但是代码很简洁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder().url(<span class="string">"http://www.google.com"</span>).build();</span><br><span class="line">Response response = okHttpClient.newCall(request).execute();</span><br><span class="line">String responseData = response.body().string();</span><br></pre></td></tr></table></figure></p><p>如果需要写POST请求，就需要构建一个RequestBody对象来存放请求体的参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RequestBody requestBody = <span class="keyword">new</span> FormBody.Builder().add(<span class="string">"username"</span>,<span class="string">"admin"</span>)</span><br><span class="line">  .add(<span class="string">"password"</span>,<span class="string">"123456"</span>)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure></p><p>然后在requset的连缀方法里多加一个post（），传入请求体，之后就和和GET的操作一样了。</p><h3 id="解析XML"><a href="#解析XML" class="headerlink" title="解析XML"></a>解析XML</h3><p>P.321 暂时先不看。</p><h3 id="解析Json"><a href="#解析Json" class="headerlink" title="解析Json"></a>解析Json</h3><ul><li>新建一个JSONArry或者JSONObject（取决于具体的json数据的结构）</li><li>对于JSONArray，可以遍历其中的数据，每个元素都是JSONObject</li><li>对于JSONObject，直接调用getString（）方法取出字符串就可以了。</li></ul><h3 id="用GSON解析JSON"><a href="#用GSON解析JSON" class="headerlink" title="用GSON解析JSON"></a>用GSON解析JSON</h3><p>GSON是一个google提供的开源库，好处是可以直接映射赋值到某个类的成员变量。</p><ul><li>先配置第三方库，在gradle里添加‘com.google.code.gson:x.x’</li><li>新建一个Gson对象</li><li>对Gson对象调用fromJson（）方法，传入两个参数：jsondata原字符串、模板类.class。</li><li>如果结构里面有数组结构，用TypeToken将目标类型传入fromJson（）方法中：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; people = gson.fromJson(jsonData,<span class="keyword">new</span> TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType());</span><br></pre></td></tr></table></figure></li></ul><h3 id="回调机制"><a href="#回调机制" class="headerlink" title="回调机制"></a>回调机制</h3><p>回调机制普遍存在在各种语言的设计中，总的来说就是A调用B的方法，B在耗时操作这个方法，然后方法执行完了以后B再调用A的某个方法，这样的机制就是回调。</p><p>java中的实现是依靠interface的特性实现的。</p><ul><li><p>新建接口类CallBackListener：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallBackListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnFinished</span><span class="params">(String callBackData)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(IOException e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>让A类实现接口类的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">CallBackListener</span></span></span><br></pre></td></tr></table></figure></li></ul><p>然后重写接口中的方法，作为收到回调之后的处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnFinished</span><span class="params">(String callBackData)</span> </span>&#123;</span><br><span class="line">Log.d(<span class="string">"A"</span>,<span class="string">"callback succeed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(IOException e)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在B类中写耗时操作，并对传入的接口类实例调用接口定义中的方法“；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verySlow</span><span class="params">(CallBackListener callback,String question)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++);<span class="comment">//模拟耗时操作</span></span><br><span class="line"></span><br><span class="line">        String string = <span class="string">"i am very slow , but i had finished it "</span> + question;</span><br><span class="line">        callback.OnFinished(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果要使用回调，就在A类里持有一个B类的实例，然后新开一个线程，在A类中调用B类的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">justDoIt.verySlow(MainActivity.<span class="keyword">this</span>,<span class="string">"1+1"</span>);</span><br><span class="line">Log.d(<span class="string">"MainActivity"</span>,<span class="string">"call finished"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p><h1 id="后台服务"><a href="#后台服务" class="headerlink" title="后台服务"></a>后台服务</h1><p>服务是Android中能够让程序后台运行的办法，这种方法很适合去做那种不需要用户交互的、长期运行的任务。</p><p>服务不是一个独立运行的进程是，而是依赖于创建服务的那个进程。所以如果创建服务的进程被杀死之后，这一票依赖于这个进程的服务都会挂掉。</p><p>服务不会自己开启线程，所有的代码默认在主线程里运行。所以就需要手动去创建子线程。</p><h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><h3 id="线程的基本用法"><a href="#线程的基本用法" class="headerlink" title="线程的基本用法"></a>线程的基本用法</h3><p>定义一个新的线程只需要新建一个类继承自Thread，然后重写run（）方法，并在里面编写耗时操作的逻辑代码就好。</p><p>新建完线程类之后，如果想让这个线程启动，对线程对象调用start（）方法就可以。</p><p>但是这样写会导致较高的耦合性，更多的时候其实是通过实现Runnable（）接口的方式来自定义线程的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">extends</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.v(<span class="string">"MyThread"</span>,<span class="string">" run myThread with interface Runnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者如果不想另外新建一个类去实现接口的方法，也可以直接使用匿名类（而且使用场景更多）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="在子线程中更新UI"><a href="#在子线程中更新UI" class="headerlink" title="在子线程中更新UI"></a>在子线程中更新UI</h3><p><strong> Android的UI线程是不安全的，如果想要更新UI元素，就必须在主线程中进行，否则会出现异常</strong></p><p>但是有的时候，我们会开启一个用于处理耗时操作的子线程，然后在子线程处理完之后改变UI的内容。对于这种情况，Android提供了一套异步消息处理的机制。</p><p>先看看怎么使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UPDATE_TEXT = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> TextView textView;</span><br><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line"><span class="keyword">case</span> UPDATE_TEXT:</span><br><span class="line">textView.setText(<span class="string">"changed"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>先在Activity类中新增三个成员变量：一个是用来标识“更新某个控件”这个动作的标志变量、一个是对目标控件的引用、一个是Handler变量，在新建的时候就可以创建一个代码部分，里面实现了handleMessage（）方法，这个代码就是先判断传入的Message实例是哪一个操作，然后写UI的更新逻辑代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message();</span><br><span class="line">message.what = UPDATE_TEXT;</span><br><span class="line">handler.sendMessage(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p><p>这个部分就是异步开启一个线程，然后新建一个Message对象，指定Message对象的what属性为前面用来标识更新某个UI控件的标志变量，然后对Handler的成员变量实例调用sendMessage（）方法，传入刚才新建好的message对象，就可以了。</p><h3 id="异步消息机制的原理简析"><a href="#异步消息机制的原理简析" class="headerlink" title="异步消息机制的原理简析"></a>异步消息机制的原理简析</h3><p>前面了解了Handler的用法，现在再来看一下异步消息处理的机制是怎么一回事，为什么这种机制能够处理UI线程。</p><p>这种机制由四部分构成：Message、Handler、MessageQueue、Looper。</p><h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p>Message是线程之间传递的<strong>消息</strong>，可以携带少量数据。上面在构建Message对象的时候，设置过一个what的属性，除此之外还可以使用arg1、arg2来携带整型数据、用obj属性携带一个Object对象。</p><h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>用于发送和处理消息，发送消息一般是使用Handler的sendMessage（）方法，之后消息兜兜转转，最终会回到HandleMessage（）方法。所以上面在声明Handler对象的时候就自己实现了handleMessage（）方法，因为这个是最终要执行的方法。</p><h4 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h4><p>消息队列，用于存放所有通过Handler发送的消息，这些消息们会一直存在在这个队列中，等待着被一个接一个的处理掉。</p><p><strong>每个线程只有一个MessageQueue对象</strong></p><h4 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h4><p>Looper是每个线程中的MessageQueue的管家，调用Looper的loop（）方法，就会让Looper把MessageQueue中的message循环取出并传递到Handler的handleMessage（）方法中。</p><p><strong>每个线程也只有一个Looper</strong></p><h3 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h3><p>Android还基于异步消息处理机制封装了AsyncTask以便从子线程切换到主线程，AsyncTask是一个抽象类，如果需要使用，就需要子类去继承它。</p><p>三个泛型参数：</p><ul><li>Params：在执行AsysncTask时传入的参数，可以在后台任务中使用。</li><li>Progress：如果需要 在界面上显示当前进度，这个泛型参数就是进度的单位。</li><li>Result：指定返回值的类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>,<span class="title">Integer</span>,<span class="title">Boolean</span>&gt;</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onPreExecute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Boolean <span class="title">doInBackground</span><span class="params">(Void... voids)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onProgressUpdate(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Boolean aBoolean)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onPostExecute(aBoolean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写了四个方法:</p><ul><li>onPreExecute：在后台任务开始之前调用，做一些初始化操作，弹出显示进度条、对话框等。</li><li>doInBackground：这个方法中的代码都会在子线程中，可以用来处理耗时任务，完成之后就可以通过return预计来返回结果。因为在子线程中，所以这里不能更新UI，如果要更新UI元素，可以调用publishProgress（）方法来实现。</li><li>onProgressUpdate：该方法中携带的参数是在后台的publishProgress（）方法发送过来的，这个方法中可以对UI进行操作。</li><li>onPostExcute：这个方法也是出于主线程的，当后台任务执行完return回来的时候就会调用这个方法，这个方法可以提示后台任务的执行结果或者关闭进度条等等。</li></ul><h2 id="服务的基本用法"><a href="#服务的基本用法" class="headerlink" title="服务的基本用法"></a>服务的基本用法</h2><p>作为Android四大组件之一，服务也是很重要的一部分。</p><h3 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="定义一个服务"></a>定义一个服务</h3><p>可以使用Android Studio的快捷方法去新建一个服务类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Return the communication channel to the service.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not yet implemented"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建的服务类还需要重写一些方法去完成功能，这里重写了onCreate（）、onStartCommand（）、onDestroy（）方法，也很好理解，就不细说了。</p><p>服务也需要在AndroidManifest.xml文件中注册，不过因为用的是IDE的快捷方法，它已经自己写好了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">".MyService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="启动和停止服务"><a href="#启动和停止服务" class="headerlink" title="启动和停止服务"></a>启动和停止服务</h3><p>前面已经创建好了一个服务，现在来启动一下这个服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent startServiceIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">startService(startServiceIntent);</span><br></pre></td></tr></table></figure><p>代码也很简单，就是新建一个Intent，参数中传入自定义service的类，然后调用startService（）方法传入这个intent就可以启动了。</p><p>停止服务也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent startServiceIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">stopService(startServiceIntent);</span><br></pre></td></tr></table></figure><p>和上面一样，可以这样手动停止。</p><p>另外，可以在MyService类中的任意位置调用stopSelf（）方法就可以让服务自己停下来。</p><h3 id="活动和服务的通信"><a href="#活动和服务的通信" class="headerlink" title="活动和服务的通信"></a>活动和服务的通信</h3><p>前面的启动和停止都是Activity调用方法去控制服务的开始和结束，但是中间的具体执行细节、进度等等信息Activity并没有得知。如果需要Activity和服务有更紧密的联系，就需要使用onBind（）方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.v(<span class="string">"MyService"</span>,<span class="string">"startDownload"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProgress</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.v(<span class="string">"Myservice"</span>,<span class="string">"getProgress"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用的具体方法时新建一个内部类，然后在service类的内部新建一个Binder子类的成员变量，在onBind（）方法中返回这个成员变量。</p><p>这样就完成了service类的部分，如果需要实现活动和服务的通信还需要在Activity类中写一些的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MyService.DownloadBinder downloadBinder;</span><br><span class="line"><span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;</span><br><span class="line">        downloadBinder = (MyService.DownloadBinder) iBinder;</span><br><span class="line">        downloadBinder.startDownload();</span><br><span class="line">        downloadBinder.getProgress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在Activity类中添加一个成员变量：一个service内部类Binder的实例。和一个ServiceConnection的匿名类，在匿名类里面重写了onServiceConnected（）方法和onServiceDissconnected（）方法。这两个方法会在 活动和服务绑定和解绑时候调用。</p><p>这样，就可以通过在Activity中对Binder实例这个成员变量调用方法，实现在服务里执行某个方法。</p><p>最后就是将服务和Activity绑定起来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">bindService(bindIntent,connection,BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure><p>依照惯例，先新建一个intent对象，然后用bindService（）方法将intent、ServiceConnection的实例绑定起来，第三个参数是表示Activity和通知绑定起来之后会自动新建服务，这时候Service类中的onCreate（）方法会被回调执行，但是onStartCommand（）方法不会执行。</p><p>要解绑也很简单，直接调用unbindService（）传入ServiceConnection的实例就可以解绑了。</p><p>**任何服务在整个APP的范围内都是通用的，一个服务可以和任意活动绑定，绑定后获取到的Service的bind子类实例是相同的。</p><h3 id="服务的生命周期"><a href="#服务的生命周期" class="headerlink" title="服务的生命周期"></a>服务的生命周期</h3><ul><li>服务开始于create，回调onCreate（）方法</li><li>然后在app的任何位置调用了startService（）方法，该服务就会启动起来，并并回调onStartCommand（）方法。</li><li>启动之后服务会一直运行，直到stopService（）方法或者service类内部的stopSelf（）方法调用。</li><li>当startService（）调用后，再调用stopService（）方法，就会回调onDestory（）方法，表示服务被销毁。或者在bindService（）之后再调用unbindService（）方法也会被销毁。如果同时startService（）和bindService（）都被调用过，那销毁服务就需要stopService（）和unbindService（）方法都调用。</li></ul><p><strong>每个服务只会存在一个实例，所以无论对同一个服务启动了多少次，实际上只有一个，调用一次stopService（）或者stopSelf（）就停止运行了。</strong></p><h3 id="服务的使用技巧"><a href="#服务的使用技巧" class="headerlink" title="服务的使用技巧"></a>服务的使用技巧</h3><h4 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h4><p>服务几乎都是在后台工作，它的系统优先度其实比较低，如果系统内存不足的时候，可能就会回收掉正在运行的服务。</p><p>如果希望服务可以一直保持运行，就可以使用<strong>前台服务</strong></p><p>前台服务和后台服务的一个区别在于，前台服务会有一个正在运行的图标在系统的状态栏显示，很类似通知的效果。</p><p>前台服务的使用并不仅仅是为了避免被回收，比如天气类的app，它就需要这样一种的效果——在后台更新天气数据的时候，还可以在状态栏一直显示当前的天气信息。</p><ul><li>在Service类中加入如下代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MainActivity.class);</span><br><span class="line">NotificationChannel  channel = <span class="keyword">new</span> NotificationChannel(<span class="string">"5555"</span>,<span class="string">"foreground"</span>,</span><br><span class="line">NotificationManager.IMPORTANCE_HIGH);</span><br><span class="line">PendingIntent pi = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,<span class="number">0</span>);</span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification.Builder(<span class="keyword">this</span>,<span class="string">"5555"</span>)</span><br><span class="line">                .setContentTitle(<span class="string">"this is content title"</span>)</span><br><span class="line">                .setContentText(<span class="string">"this is content text"</span>)</span><br><span class="line">                .setWhen(System.currentTimeMillis())</span><br><span class="line">                .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher))</span><br><span class="line">                .setContentIntent(pi)</span><br><span class="line">                .build();</span><br><span class="line">startForeground(<span class="number">1</span>,notification);</span><br></pre></td></tr></table></figure><p>书上的方法有的部分已经被废弃了，这个是新一些的方法：新键了一个intent，然后新建了一个Notification的Channel并，为后面的通知实例指定这个channel 的id，然后调用service的startForeground（）方法，传入这个notification的实例，就可以启动一个前台服务。</p><h4 id="使用IntentService"><a href="#使用IntentService" class="headerlink" title="使用IntentService"></a>使用IntentService</h4><p>因为服务使用的还是在主进程的主线程，所以如果用服务去执行耗时操作，就会出现ANR（Application Not Responding，未响应）情况。</p><p>所以如果需要使用后台服务去执行耗时操作，就需要在service的类中开启新的线程去执行耗时任务。这时候新的线程开了以后就没有办法去控制了，除非直接停止这个服务。</p><p>所以就可以在耗时操作后调用stopSelf（）方法。</p><p>实际上，Android提供了一个专门用于开启带线程的后台任务的类：IntentService</p><p>新建一个类继承自InetntService，然后重写其onHandleintent方法，这个里面就可以写一些耗时操作，然后构造方法和onDestory（）方法就执行父类的方法就可以（看具体情况）。</p><p><strong>这个类可以自动开辟新的线程去执行任务，而且最后的onDestory（）方法也可以自动执行。</strong></p><h1 id="Material-Design-风格的UI"><a href="#Material-Design-风格的UI" class="headerlink" title="Material Design 风格的UI"></a>Material Design 风格的UI</h1><p>2014年，google推出了一套全新的UI设计语言，包括视觉设计、运动、互动效果等等。想让各个app的设计都采用这套设计语言（可惜的很多公司还是没有接受这个…）</p><p>简而言之，它实际上也是包括了一套UI，这套控件体现了Material Design 的UI风格。</p><h2 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h2><p>之前的所有默认的Activity都会有一个ActionBar的控件，就是最上面的一个条。官方已经不再推荐使用ActionBar了，转而推荐ToolBar。ToolBar继承了ActionBar的所有功能，而且灵活性很高，可以配合其他空间去完成Material Design的效果。</p><h3 id="ToolBar-的简单体验"><a href="#ToolBar-的简单体验" class="headerlink" title="ToolBar 的简单体验"></a>ToolBar 的简单体验</h3><p>Activity默认带的ActionBar是由AndroidManifest.xml中的android:theme属性中指定的AppTheme主题而来的。这个AppTheme在res/values/styles.xml文件中定义的，这个文件长这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>@color/colorPrimaryDark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>@color/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，定义的AppTheme的parent主题是Theme.AppCompat.Light.DarkActionBar，所以之前的Activity带有ActionBar是因为指定了这个主题。</p><p>这里如果想要使用ToolBar代替ActionBar，就需要设置这个AppTheme为NoActionBar。</p><p>然后就需要在activity的布局代码中写一个toolbar的控件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimary"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark.ActionBar"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:popupTheme</span>= <span class="string">"@style/Theme.AppCompat.Light"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v7.widget.Toolbar</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到和一般的控件有一些不太一样的地方，不过都大同小异。</p><p>再然后就是在activity的代码中写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Toolbar toolbar = (Toolbar)findViewById(R.id.toolbar);</span><br><span class="line">setSupportActionBar(toolbar);</span><br></pre></td></tr></table></figure><p>可能会有报错的提示，只需要把包含的库改为import android.support.v7.widget.Toolbar;就可以了，因为setSupportActionBar是个库提供的，而自动包含可能写成另一个ToolBar的库。</p><p>目前为止，实现了一个ToolBar，但是看上去的实现效果和ActionBar并无二致，这是因为暂时还没有应用到ToolBar的一些效果，但是实际上就已经有可以实现Material Design的能力。</p><p>如果想要实现更丰富的ToolBar就需要自定义ToolBar了：</p><h3 id="自定义ToolBar"><a href="#自定义ToolBar" class="headerlink" title="自定义ToolBar"></a>自定义ToolBar</h3><p>先新建一个toolbar.xml布局文件作为自定义ToolBar的布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/backup"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_launcher_background"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"Backup"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span> = <span class="string">"always"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/delete"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_launcher_background"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"Delete"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">"ifRoom"</span></span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/settings"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_launcher_background"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"Settings"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">"never"</span></span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和前面的控件的布局不同的地方在于：多了一个app:showAsAction来指定按钮的显示位置，因为这里也用到了app的字段，所以在开头需要用xmlns去指定这个命名空间。</p><p>showAsAction主要有几种值可选：</p><ul><li>always：表示永远显示在ToolBar中，如果屏幕空间不够就不显示了。</li><li>ifRoom：如果屏幕空间足够，就显示在ToolBar中，如果不够的话就显示在菜单中。</li><li>nerver：永远显示在菜单中。</li></ul><p><strong>ToolBar中的action按钮只显示图标，菜单中的action只显示文字</strong></p><h2 id="滑动菜单"><a href="#滑动菜单" class="headerlink" title="滑动菜单"></a>滑动菜单</h2><p>滑动菜单其实就是侧滑栏，iOS中并没有提供原生的侧滑栏，但是安卓提供了一个Drawerlayout控件，就可以借助这个控件来实现侧滑栏。</p><h3 id="Drawerlayout"><a href="#Drawerlayout" class="headerlink" title="Drawerlayout"></a>Drawerlayout</h3><p>这个DrawerLayout是一个布局，在布局中允许防止两个直接子控件：主屏幕中显示的内容、滑动菜单中显示的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span> = <span class="string">"@+id/drawer_layout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimary"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark.ActionBar"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popupTheme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Light"</span></span></span><br><span class="line"><span class="tag">            &gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">android.support.v7.widget.Toolbar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"start"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"123456"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"30sp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#FFF"</span>   /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在的activity的布局文件变成了这样，最外层是DrawerLayout，然后在里面写了一个ToolBar作为主屏幕的显示内容，在侧滑栏里写了一个TextView。</p><p>**对于第二个控件的layout_gravity的属性是必须指定的，表示了侧滑栏的滑出位置。</p><p>但是如果用户没有划出来就不知道是否有侧滑栏的存在。所以建一个做法是在ToolBar的最左边加一个导航按钮，这样点击导航按钮也可以打开侧滑栏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">drawerLayout = (DrawerLayout)findViewById(R.id.drawer_layout);</span><br><span class="line">ActionBar actionBar = getSupportActionBar();</span><br><span class="line"><span class="keyword">if</span> (actionBar!=<span class="keyword">null</span>)&#123;</span><br><span class="line">actionBar.setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br><span class="line">actionBar.setHomeAsUpIndicator(R.drawable.ic_launcher_background);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，先获取到这个DrawerLayout的实例，再获取到可用的ActionBar，因为现在用的ToolBar去实现ActionBar，所以获取到的实际上就是ToolBar。然后让ActionBar实例把HomeAsUp按钮显示出来。</p><p>现在就设置好了ToolBar上的显示，最后让点击到这个按钮时候显示出DrawerLayout就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId())&#123;</span><br><span class="line">        <span class="keyword">case</span> android.R.id.home:</span><br><span class="line">            drawerLayout.openDrawer(GravityCompat.START);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对DrawerLayout实例调用openDrawer（）方法就可以打开侧滑栏了，传入的参数表示的依旧是打开侧滑栏的方向。</p><h3 id="NavigationView"><a href="#NavigationView" class="headerlink" title="NavigationView"></a>NavigationView</h3><p>NavigationView是DesignSupport库中提供的一个控件，可以更为简单的实现滑动菜单的页面。</p><p>暂时先不看，等到具体需要使用的时候回回来补笔记。因为目前看到的国内的很多app也并没有使用这套设计语言，所以使用场景暂时还是很受限的，当然了，如果要去制作个人的app还是很不错的一种app的设计风格，可能会和原生系统UI统一而高效。</p><h2 id="悬浮按钮和可交互提示"><a href="#悬浮按钮和可交互提示" class="headerlink" title="悬浮按钮和可交互提示"></a>悬浮按钮和可交互提示</h2><h3 id="FloatingActionButton"><a href="#FloatingActionButton" class="headerlink" title="FloatingActionButton"></a>FloatingActionButton</h3><p>默认使用colorAccent作为按钮的颜色。可以在布局文件中设置其阴影效果（借此来表示悬浮高度）。其他的也没有什么特性，和普通的按钮使用效果是一样的。暂时不做样例代码的学习。</p><h3 id="Snackbar"><a href="#Snackbar" class="headerlink" title="Snackbar"></a>Snackbar</h3><p>这个是在屏幕下方显示一个条状视图和一个按钮，用于用户交互（比如相机删除照片后会有一个Snackbar提示要不要撤销。</p><h3 id="Coordinatorlayout"><a href="#Coordinatorlayout" class="headerlink" title="Coordinatorlayout"></a>Coordinatorlayout</h3><p>这个可以说是一个加强版的Framelayout，也是有Design Support库提供的，可以监听所有子控件的各种事件，然后做出合理的响应，比如避免控件遮挡的自动偏移操作等等。并且替换原来的FrameLayout也很简单，能够向下兼容，直接换掉关键字字段皆可以了。</p><h2 id="卡片式布局"><a href="#卡片式布局" class="headerlink" title="卡片式布局"></a>卡片式布局</h2><p>卡片式布局的意思就是，让页面中的元素看起来就像在卡片中一样，并且还有圆角和投影。</p><h3 id="CardView"><a href="#CardView" class="headerlink" title="CardView"></a>CardView</h3><p>由appcompat库提供的一个重要控件，实际上它也是一个FrameLayout，知识额外提供了圆角和阴影效果，看上去有立体的感觉。</p><h3 id="AppBarLayout"><a href="#AppBarLayout" class="headerlink" title="AppBarLayout"></a>AppBarLayout</h3><p>上一个CardView的RecyclerView会遮挡住ToolBar，为了不遮挡，还有另外一种解决办法——AppBarLayout，它是一个垂直方向上的LinearLayout，内部做了很多滚动事件的封装，也应用了一些Material Design的设计理念。</p><p>具体使用其实就是两步：</p><ul><li>将ToolBar嵌套到AppBarLayout中。</li><li>给RecyclerView指定一个布局行为app:layout_behavior=“@string/appbar_scrolling_view_behavior”</li></ul><p>这样就不会遮挡了。</p><p>（PS:在TollBar中可以指定一个app:layout_scrollFlags=“scroll|enterAlways|snap”的字段属性，这样就可以实现上划时候自动隐藏ToolBar，在下划的时候又自动显示。）</p><h2 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h2><p>Google提供了现成的刷新控件，用就好了。</p><p>SwipeRefreshLayout是用来实现这个效果的核心类，由support-v4库提供。只要把想要实现下拉刷新的控件放到SwipeRefreshLayout中就可以了。</p><p>要实现这个控件的效果的第一步就是在想要下拉刷新的RecyclerView布局代码的部分的外层包裹一层SwipeRefreshLayout的布局代码。</p><p>然后在Activity的内部持有一个SwipeRefreshLayout成员变量，然后通过findViewById（）方法和布局文件中的控件对应起来。</p><p>再然后对这个SwipeRefreshLayout的成员变量调用setOnRefreshListener（）方法来处理下拉动作触发的回调事件（注意不要直接把耗时操作写在这个里面，可能会导致ANR的！）。</p><h2 id="可折叠式标题栏"><a href="#可折叠式标题栏" class="headerlink" title="可折叠式标题栏"></a>可折叠式标题栏</h2><h3 id="CollapsingToolbarLayout"><a href="#CollapsingToolbarLayout" class="headerlink" title="CollapsingToolbarLayout"></a>CollapsingToolbarLayout</h3><p>这是一个可以极大扩充ToolBar的使用效果的布局，不过它无法直接存在，而是要作为AppBarLayout的直接子布局来使用。进一步地，AppBarLayout又必须作为CoordinatorLayout的子布局。</p><p>这个布局实现的效果就是微信朋友圈的那种效果。</p><h3 id="充分利用状态栏的空间"><a href="#充分利用状态栏的空间" class="headerlink" title="充分利用状态栏的空间"></a>充分利用状态栏的空间</h3><p>这个是要实现将系统的状态栏做成全透明的，和前面的CollapsingToolbarLayout实现效果融为一体。</p><h1 id="一些其他的技巧"><a href="#一些其他的技巧" class="headerlink" title="一些其他的技巧"></a>一些其他的技巧</h1><h2 id="全局获取Context的技巧"><a href="#全局获取Context的技巧" class="headerlink" title="全局获取Context的技巧"></a>全局获取Context的技巧</h2><p>Android开发中几乎处处要用到context，在目前的学习中，似乎获取到context不算多难，因为activity类就是context对象。</p><p>但是后面的开发会逐渐脱离activity类，如果这时候需要context，就有点不那么容易从activity获取context了。</p><p>Android提供了一个类——Application类，每当程序启动的时候，系统就会自动将这个类初始化，所以我们可以定制一个自己的Application类，以便于管理程序内部的全局状态信息。比如全局Context。</p><ul><li>新建一个类继承自Application</li><li>重写onCreate（）方法，并提供get方法。</li><li>在AndroidManifest.xml中的application字段指定我们刚刚新建新建的自定义Application子类。</li><li>之后需要使用的时候，就对新建的Application类调用get方法就可以了。</li><li>如果和其他的Application类冲突的话，在自定义Application类的初始化方法里调用别的Application的初始化方法就可以了。<strong>一个App只能配置一个Application</strong>。</li></ul><h2 id="使用Intent传递对象"><a href="#使用Intent传递对象" class="headerlink" title="使用Intent传递对象"></a>使用Intent传递对象</h2><h3 id="Serializable方式"><a href="#Serializable方式" class="headerlink" title="Serializable方式"></a>Serializable方式</h3><p>序列化一个对象，将其转化为可存储或者可传输的状态。</p><p>要实现序列化，只要让这个需要被传递的类去实现Serializable接口就可以了。然后还是按照常规的put方法传递这个对象，但是在接收的时候取值就不同了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = (Person) getIntent().getSerializableExtra(<span class="string">"Person_data"</span>);</span><br></pre></td></tr></table></figure><h3 id="Parcelable方式"><a href="#Parcelable方式" class="headerlink" title="Parcelable方式"></a>Parcelable方式</h3><p>这种方式比上一种要复杂一些，但是上一种要全部对象都序列化，这个是只对需要的</p><p>首先还是要实现Parcelable的接口，必须重写两个方法：describeContents（）、writeToParcel（）。</p><p>第一个方法返回0就可以了。第二个需要调用Parcel的writeXXX（）方法，将本类的成员变量一个个写入进去。</p><p>然后还需必须提供一个CREATOR的常量，创建Parcelable.Creator的接口实现，指定泛型为Person。</p><p>实现接口就需要重写两个方法：createFromParcle（）、newArray（）。</p><p>在createFromParcle（）方法中需要确定格式：读取刚才写的成员变量字段，并创建一个本类对象返回。（调用read的顺序一定要和前面的write（）方法顺序一致）。</p><p>在newArray（）方法的实现：只需要new 出一个Person数组就可以了。</p><h2 id="定制自己的日志工具"><a href="#定制自己的日志工具" class="headerlink" title="定制自己的日志工具"></a>定制自己的日志工具</h2><p>前面的学习中，为方便调试，在代码中插入了很多日志，但是如果发布包的时候还带有这些日志信息的话，可能会导致信息泄露或者APP的效率下降。</p><p>所以就需要有一个工具，在开发调试阶段有日志的打印信息，但是在发布的时候就把日志去掉。</p><p>实现方法是自定义一个类，去实现一些Log的逻辑，用一个level变量去控制打印信息，默认设置为verbose，到时候如果需要发布，就修改这个level值，这样就会避免打印log。</p><h2 id="调试Android-APP"><a href="#调试Android-APP" class="headerlink" title="调试Android APP"></a>调试Android APP</h2><p>从IDE的运行选项届可以选择Debug按钮，然后在IDE里面就能看到各种信息，这个在后面的使用中会慢慢熟悉。</p><h2 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h2><p>定时任务的实现一般有两种方式：Java里的Timer、Android里面的Alarm机制。</p><p>Timer有一个明显的短板，不太适合那些长期在后台运行的任务，容易被休眠策略影响。</p><p>而Alarm有唤醒CPU的功能 ，保证大部分情况下，可以正常工作。</p><h3 id="Alarm机制"><a href="#Alarm机制" class="headerlink" title="Alarm机制"></a>Alarm机制</h3><p>借助AlarmMangager类实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AlarmManager manager = (AlarmManager)getSystemService(Context.ALARM_SERVICE);</span><br><span class="line"><span class="keyword">long</span> triggerAtTime = SystemClock.elapsedRealtime() + <span class="number">10</span>*<span class="number">1000</span>;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,LongRunningServices.class);</span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getService(<span class="keyword">this</span>,<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,triggerAtTime,pendingIntent);</span><br></pre></td></tr></table></figure><p>（上面的代码仅仅是一个演示，参数需要根据实际情况去写）</p><p>因为时间的单位是毫秒，所以这里的秒数需要乘1000。然后在manger的set方法的三个参数分别传入：</p><ul><li>用于指定AlarmManger的工作方式。可选ELAPSED_REALTIME（触发时间从系统开机算起，不会唤醒CUP）、ELAPSED_REALTIME_WAKEUP（可以唤醒CPU）、RTC（触发时间从1970年1月1日0点开始算起，不唤醒）、RTC_WAKEUP（可以唤醒）。</li><li>SystemClock.elapseRealtime（）方法可以获取到系统开机到现在为止经过的毫秒数。（同样的，调用System.currentTimeMillis（）方法可以获取到从1970年1月1日0点至今所经历的毫秒数）</li><li>获取到一个广播或者服务，这样在定时任务执行的时候，对应的服务的onStartCommand（）或者服务的onReceive（）方法就能得到执行。</li></ul><p><strong>在Android4.4开始，这个Alarm方式的触发开始变得不准确，不过这个不是bug，而是系统的省电优化，把附近几个时段的Alarm一块执行。如果仍然需要准确执行，可以用setExact来代替set方法。而且考虑到逻辑代码的顺序执行带来的时间误差，可以用多线程的方式保证逻辑代码能够在触发后及时地被执行。</strong></p><h3 id="Doze模式"><a href="#Doze模式" class="headerlink" title="Doze模式"></a>Doze模式</h3><p>Android一直在优化耗电控制，但是还是挡不住后台服务的滥用，所以在Android6.0加入了Doze模式，可以大幅度优化耗电量过大的问题。</p><p>简单来说，就是系统在检测到手机没有充电，而且关闭了屏幕一段时间，就会进入Doze模式，系统这时候会对CPU、网络、Alarm等活动进行限制。</p><p>系统也不会一直处于Doze状态，而是会隔段时间唤醒一次，但是间隔会越来越长。</p><p>在Doze模式下：</p><ul><li>网络不能访问</li><li>忽略唤醒CPU或者屏幕操作</li><li>系统停止扫描WIFI</li><li>停止同步服务</li><li>Alarm任务会在下次推出Doze模式的时候执行</li></ul><h2 id="多窗口模式编程"><a href="#多窗口模式编程" class="headerlink" title="多窗口模式编程"></a>多窗口模式编程</h2><p>多窗口其实就是分屏，其实默认都是支持分屏的，只不过在分屏模式下，很多控件的尺寸会发生变化，所以这时候就要考虑在写布局的时候，多使用match_parent属性、RecyclerView等空控件，尽量避免出现屏幕尺寸变化过大带来的程序异常显示。</p><h3 id="多窗口模式下的生命周期"><a href="#多窗口模式下的生命周期" class="headerlink" title="多窗口模式下的生命周期"></a>多窗口模式下的生命周期</h3><p>其实App的生命周期并没有发生大的改变，只是：同时出现的两个APP，当用户和其中的一个交互的时候，另外一个虽然也是处于完全可见的状态，但是还是进入到了onPause（）的回调模式中。所以在一些视频播放的APP开发，就不要在onPause（）的方法中暂停掉播放。</p><p>另外，APP进入多窗口模式的时候Activity会被重新创建。要是想改变这种默认的机制，可以在AndroidManifest.xml中对Activity的配置加入configChanges字段进行配置。这样一来，屏幕发生变化的事件会回调Activity的onConfigurationChanged（）方法中，可以根据具体情况去重写这个方法。</p><h3 id="禁用多窗口"><a href="#禁用多窗口" class="headerlink" title="禁用多窗口"></a>禁用多窗口</h3><p>有的时候我们不希望APP在多窗口状态下运行，就可以在AndroidManifest.xml文件中配置application或者Activity的resizeableActivity字段为false，表示不支持。</p><p>上述方法只在targetSdkVersion24以及更高的版本中生效，在低版本的系统中，会提示可能不能正常工作，但是还是会进入多窗口模式。不过，在低版本的规定中，如果不允许横竖屏切换就不能进入多窗口模式。所以低版本的设置可以在AndroidManifest.xml中声明screenOrientation字段为portrait（只支持竖屏）或者landscape（只支持横屏）就可以了。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>这个是java8新引入的特色功能。而且，这个功能最低支持到Android2.3呢。而其他的stream API等却只能支持7.0之上的系统版本，兼容性就很不好，所以项目的开发中能够使用的也就是这个Lambda表达式了。</p><p>来一个具体的使用场景感受一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(v -&gt; &#123;</span><br><span class="line"><span class="comment">//do something </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而原来的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>只要是只有一个待实现的方法的接口，都可以使用Lambda表达式去写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda:</span></span><br><span class="line">Runnable runnable = () -&gt;&#123;</span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><p>啊… …</p><p>终于告一段落了，这本《第一行代码》我本来是打算尽快过一遍的，但是不断的学习中，发现还是有很多地方和iOS有很大的不同，当然也有很多联系，但是在这个过程中，我喜欢一边学习Android的设计，一边和iOS开发中的一些设计对应起来，所以进度慢了很多。</p><p>而且其实有一部分的内容没有涉及到，比如多媒体的部分和定位的部分。这一块我打算后面如果有时间的话，会补上这部分的内容，因为这些其实偏向于模块，不会影响到正常的逻辑开发等等。</p><p>不过好的一点是，现在在看完这本书，能够上手去做一些简单的事情——比如创建项目，跟着示例去完成一些功能和效果等等。还有一个重要的收获就是，慢慢熟悉了Android的开发环境和开发思维，虽然目前接触到的开发的知识还很少，也还没有真正地开始写项目，不可避免地手生。但是在能够上手之后，就是快速积累实际经验的时候，希望这部分的学习能对之后的工作和学习有所增益，就算没有增益也没啥关系，学的越多，眼界就越开阔。</p><p>总而言之，过了一遍课本，积累了一点点零散的开发知识，后面就是去上手写一个简单的APP，然后在不断的踩坑中进步。加油呀自己~~~</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>《Android第一行代码》读书笔记（上）</title>
      <link href="/2018/06/04/Android%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E8%8F%9C%E9%B8%A1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>/2018/06/04/Android%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E8%8F%9C%E9%B8%A1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>很久没有更新这个博客了，好不容易搭建的差不多，还没有来的及修改一些细节部分，不过还好，不影响使用，之后有空了再改吧。后面会把一些学习的历程、学习笔记或者一些乱七八糟的感想什么的等等东西更新上来，应该也没有什么人来看吧~<br><a id="more"></a></p><ul><li>这个Android的学习历程其实并不是我学客户端开发的开头——虽然博客里之前也并没有写关于其他的学习历程。。。我其实之前学的是iOS开发，OC写了挺久，最近也在接触Swift，本来是做好了做一个正经的iOS开发实习生（虽然我从来没有过iPhone），但是呢，今天实习公司的导师加了微信，我才得知我去了之后是要做Android的。一开始有点懵，我没写过这个东西呀，Java也掌握的很一般很一般，这意味着我有很多东西需要学习。那，如果我实习留不下呢？我写了一个月的Android然后回来匆匆忙忙复习iOS再投秋招的iOS岗位么？有点纠结，也很难抉择。</li><li>后来一想，反正实习还是要去的，那我现在开始了解一些开发Android相关的东西，去了以后能调岗位就最好，不能调的话就尽量争取留下来吧。也问了一些学长的看法作为参考。这不过就是一次挑战而已，总不可能事事如意，这个就当是一个学习能力的挑战吧，能不能在固定的一段时间里学到尽量多的东西。反正iOS的学习基本上也到了瓶颈期，不如，换换口味？</li><li>再者说，我也算个安卓机的爱好者吧，因为穷我用的从来都是安卓机，也很早开始折腾安卓系统，root、刷系统、玩xposed……算是从安卓2.x一直到8.1的体验者了。</li><li>塞翁失马，焉知非福</li><li>那就这么开始学习安卓吧</li></ul><h1 id="开始前的准备"><a href="#开始前的准备" class="headerlink" title="开始前的准备"></a>开始前的准备</h1><h2 id="教材"><a href="#教材" class="headerlink" title="教材"></a>教材</h2><p>我用的是学长推荐的《第一行代码Android》</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>用了很久的黑苹果10.12.6，AS最新版，不想用模拟器，就用了我刷了8.1的一加2</p><h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><p>新建了一个只有一个Activity的项目，它自己就写了“hello，world” 所以其实不算是我自己写的。<br>但是比起新建一个EmptyActivity什么都没有一脸懵逼来说好很多了</p><h2 id="项目文件夹结构"><a href="#项目文件夹结构" class="headerlink" title="项目文件夹结构"></a>项目文件夹结构</h2><h3 id="gradle-和-idea"><a href="#gradle-和-idea" class="headerlink" title=".gradle 和 .idea"></a>.gradle 和 .idea</h3><p>自动生成的文件，不用管</p><h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><p>主要文件都在这里</p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>也是编译生成的文件，更多更杂，不用管</p><h4 id="libs"><a href="#libs" class="headerlink" title="libs"></a>libs</h4><p>第三方包的文件夹，会自动加到构建的路径里</p><h4 id="src"><a href="#src" class="headerlink" title="src"></a>src</h4><p>这个文件里的东西是编写的时候需要关注的文件夹，需要自己写的内容基本上都在这里面</p><h5 id="androidTest"><a href="#androidTest" class="headerlink" title="androidTest"></a>androidTest</h5><p>可以在这里写测试用例，可以自动化测试</p><h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><p>基本上java文件就都在这里了</p><h6 id="java"><a href="#java" class="headerlink" title="java"></a>java</h6><p>java文件就在这个文件夹下，比如刚才创建的Activity.java</p><h6 id="res"><a href="#res" class="headerlink" title="res"></a>res</h6><p>项目里要用到的所有图片（drawable）、布局（layout）、字符串（values）等</p><h6 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h6><p>这个是整个项目的配置文件，在程序里定义的所有的四大组件都需要在这里注册，另外还可以写权限声明，这个要经常用到</p><h5 id="test"><a href="#test" class="headerlink" title="test"></a>test</h5><p>又是一个测试，先不管</p><h5 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h5><p>git忽略的文件</p><h5 id="app-imi"><a href="#app-imi" class="headerlink" title="app.imi"></a>app.imi</h5><p>不用管</p><h5 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h5><p>app这个模块的构建脚本</p><h5 id="proguard-rules-pro"><a href="#proguard-rules-pro" class="headerlink" title="proguard-rules.pro"></a>proguard-rules.pro</h5><p>用于指定混淆规则，厉害了，用于防止代码被破解</p><h3 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h3><p>编译时自动生成的文件，不用管</p><h3 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h3><p>包含了gradle wrapper的配置文件，默认不启用这个方式</p><h3 id="gitignore-1"><a href="#gitignore-1" class="headerlink" title="gitignore"></a>gitignore</h3><p>git的忽略文件</p><h3 id="build-gradle-1"><a href="#build-gradle-1" class="headerlink" title="build.gradle"></a>build.gradle</h3><p>全局gradle构建脚本，gradle是一个自动化构建脚本，一般不用改</p><h3 id="gradle-properties"><a href="#gradle-properties" class="headerlink" title="gradle.properties"></a>gradle.properties</h3><p>全局gradle配置文件，会影响整个项目的编译</p><h3 id="gradlew和gradlew-bat"><a href="#gradlew和gradlew-bat" class="headerlink" title="gradlew和gradlew.bat"></a>gradlew和gradlew.bat</h3><p>是用来执行gradle的，不用管</p><h3 id="XXX-imi"><a href="#XXX-imi" class="headerlink" title="XXX.imi"></a>XXX.imi</h3><p>是这个IDE的存在感的标识，不用管</p><h3 id="local-properties"><a href="#local-properties" class="headerlink" title="local.properties"></a>local.properties</h3><p>指定本机的Android SDK的路径，是自动生成的一般不用改</p><h3 id="setting-gradle"><a href="#setting-gradle" class="headerlink" title="setting.gradle"></a>setting.gradle</h3><p>用来指定项目中所有引入的模块，目前为止一共就用了app这么一个模块，所以现在还就只写了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:app&apos;</span><br></pre></td></tr></table></figure></p><p><strong> 好了，关于文件目录就是这些，总结起来就是外层的文件夹什么的基本上先不用管，要注意的就是app这个文件夹里的 </strong></p><h2 id="如何运行起来的"><a href="#如何运行起来的" class="headerlink" title="如何运行起来的"></a>如何运行起来的</h2><p>先看Android-Manifest.xml里做了什么</p><h3 id="Android-Manifest-xml"><a href="#Android-Manifest-xml" class="headerlink" title="Android-Manifest.xml"></a>Android-Manifest.xml</h3><p>里面有一部分代码长这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.MainActivity&quot;&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p><p>指定了点击应用之后首先启动哪个Activity，这里当然是MainActivity这个类<br>那MainActivity这个类里面做了什么操作呢？</p><h3 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是一个继承自AppCompatActivity的类，这个类类似于iOS里的ViewController<br>这个类的onCreate方法是一个Activity被创建的时候一定会执行的方法（类似于iOS里的ViewDidLoad）<br>这里并没有看到“hello world”的字样。<br>Android编程讲究逻辑和视图分离，所以setContentView这个方法引入了一个布局文件（res/layout）</p><h3 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h3><p>这个文件里面有一部分是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;Hello World!&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>表示布局里添加了一个TextView的控件，设置了ndroid:text=”Hello World!”所以会显示出Hello World。这个控件类似于iOS里的UILable</p><p><strong> 这样就大致搞清楚了HelloWorld是怎么运行起来的，并且各种文件是怎么组织起来的。其实和iOS类似的地方很多，AndroidManifest.xml有些类似APPDelegate，Activity类似于ViewController，activity_main.xml类似于xib，但是之前都是直接用代码写的布局类，所以这种的还需要适应一下 </strong></p><p><strong> 大致过程大概就是，先在AndroidManifest.xml配置Activity，然后在布局文件里面写界面相关的代码，然后在Activity.java里面写对布局里面的控件的操控，也是类似MVC的经典的逻辑分离的设计方法。 </strong></p><h1 id="从0开始自己构建一个APP"><a href="#从0开始自己构建一个APP" class="headerlink" title="从0开始自己构建一个APP"></a>从0开始自己构建一个APP</h1><p>前面的HelloWorld是人机自动生成的，这一次开始自己从0开始写一个，选择Empty，这时候没有Acitvity，所以不会有显示的。</p><h2 id="新建一个Activity"><a href="#新建一个Activity" class="headerlink" title="新建一个Activity"></a>新建一个Activity</h2><p>在app/src/main/java/com.example.ifan.activitytest右键从new里面选择一个EmptyActivity。这里新建的Activity是会自动在AndroidManifest.xml里面自动添加注册的代码的，但是不会自动设置为最先启动后展示的第一个页面，所以还需要在activity的标签里手动添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line">    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure></p><p>这样，新添加的acticity就是启动页了。</p><h2 id="新建页面布局文件"><a href="#新建页面布局文件" class="headerlink" title="新建页面布局文件"></a>新建页面布局文件</h2><p>虽然已经有了一个空的Activity，但是还没有东西可以显示。<br>在res文件夹立新建一个layout文件夹，用来存放布局文件，然后新建一个Layout resources file，是一个xml格式的文件，在这里写布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">        android:id=&quot;@+id/button_1&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;Button 1&quot;</span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure></p><p>添加了一个button，然后在标签里写的id是这个空间的唯一标示，layout_width和layout_height是控件的大小（match_parent是屏幕宽度，wrap_content是刚好能容纳控件内容的高度），text就是button上面显示的文字</p><h2 id="在Activity里操作布局里面的控件"><a href="#在Activity里操作布局里面的控件" class="headerlink" title="在Activity里操作布局里面的控件"></a>在Activity里操作布局里面的控件</h2><p>刚才已经建好了一个button，我们可以在Activity里面操作这个控件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setContentView(R.layout.first_layout);</span><br><span class="line">Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">button1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">@Override</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">    Toast.makeText(FirstActivity.this,&quot;You Clicked Me!&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ul><li>第一行的setContentView是把布局文件添加到当前Activity里面，R.layout.xxx是在引用res里面的layout文件夹里面的资源文件。</li><li>第二行从布局文件里面获取一个View，然后显式转换为button类型赋值给一个button类的实例变量。</li><li>第三行setOnClickListener是对button实例变量调用的方法（监听器），传入的一个参数为新建的View.onClickListener，然后对这个setOnClickListener方法进行覆写。</li><li>后面的onClick是button监听器里的默认会执行的单击方法，所以在这个方法里写Toast</li><li>Toast.makeText（）是一个静态方法，传入（上下文，文本内容，显示时长），然后调用show（）方法显示出来</li></ul><h3 id="Activity的基本使用"><a href="#Activity的基本使用" class="headerlink" title="Activity的基本使用"></a>Activity的基本使用</h3><p>刚才已经使用了Toast，还有一个常用的控件Menu</p><h4 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h4><ul><li>首先在res文件夹下新建文件夹menu文件夹，再在menu文件夹下新建Menu resource file</li><li>在这个文件里添加：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;item</span><br><span class="line">      android:id=&quot;@+id/add_item&quot;</span><br><span class="line">      android:title=&quot;Add&quot;</span><br><span class="line">      /&gt;</span><br><span class="line">  &lt;item</span><br><span class="line">      android:id=&quot;@+id/remove_item&quot;</span><br><span class="line">      android:title=&quot;Remove&quot;</span><br><span class="line">      /&gt;</span><br></pre></td></tr></table></figure></li></ul><p>在Menu的布局里添加了两个item，分别设置它们的id和title</p><ul><li><p>回到Activity.java的文件里，重写onCreateOptionsMenu（）方法，先getMenuInflater（）获取到一个菜单展开器，然后调用inflate把资源文件里的menu展开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public boolean onCreateOptionsMenu(Menu menu) &#123;</span><br><span class="line">       getMenuInflater().inflate(R.menu.main,menu);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>返回值表示是否允许创建的菜单显示出来<br>上面的代码能够将menu显示出来，如何响应按钮的item?</p></li><li><p>覆写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onOptionsItemSelected(MenuItem item) &#123;</span><br><span class="line">    switch (item.getItemId())</span><br><span class="line">    &#123;</span><br><span class="line">        case R.id.add_item:</span><br><span class="line">        Toast.makeText(FirstActivity.this,&quot;You clicked item named add&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">            break;</span><br><span class="line">        case R.id.remove_item:</span><br><span class="line">            Toast.makeText(FirstActivity.this,&quot;You clicked item named remove&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过switch判断不同的item的id去做不同的动作响应</p><h4 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h4><p>Intent不仅是各组件中交互的重要方式，可以指明当前组件想要执行的动作，还可以在组件之间传递数据。<br><strong> Intent 一般可以用于启动活动、启动服务、发送广播等场景 </strong></p><h5 id="显式Intent"><a href="#显式Intent" class="headerlink" title="显式Intent"></a>显式Intent</h5><ul><li>在某一个触发事件里可以创建一个Intent的实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(FirstActivity.this , SecondActivity.class);</span><br></pre></td></tr></table></figure></li></ul><p>第一个参数提供启动活动的上下文，第二个参数是目标活动</p><ul><li>Activity类提供了一个方法，专门用于启动活动，接受一个intent参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li></ul><p>至于如何返回（即销毁当前的Activity），可以手动绑定方法去执行finish（），也可以是手机上的返回键</p><h5 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h5><p>隐式的用法是通过AndroidManifest.xml中的Activity的配置相关信息，然后在Activity.java中调用符合配置的Activity，而不是直接指定某个Activity的类。<br>下面举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.SecondActivity&quot;&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot;/&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p><p>然后在FirstAcitvity.java里面写的和显式的不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent1 = new Intent(&quot;com.example.activitytest.ACTION_START&quot;);</span><br><span class="line">startActivity(intent1);</span><br></pre></td></tr></table></figure></p><p>直接写为Activity支持的action名。<br><strong> 另外，每个intent只可以对应一个action，但是可以对应多个category，只有当category和action同时满足范围的时候才可以正常调用，否则会崩溃并抛出异常 </strong></p><p>其实还有别的隐式intent的用法，比如跨应用唤起某个页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent1 = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent1.setData(Uri.parse(&quot;http://google.com&quot;));</span><br><span class="line">startActivity(intent1);</span><br></pre></td></tr></table></figure></p><p>这样就可以唤起浏览器并打开<a href="http://google.com" target="_blank" rel="noopener">http://google.com</a><br>ACTION_VIEW是安卓系统内置的动作，然后Uri.parse（）是将字符串解析为Uri对象，最后用setDdata（）把Uri对象传入。</p><p>除此之外，还可以在<intent-filter>中配置 data 标签，实现更精确地响应：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.SecondActivity&quot;&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">        &lt;data android:scheme=&quot;&quot;/&gt;</span><br><span class="line">        &lt;data android:host=&quot;&quot;/&gt;</span><br><span class="line">        &lt;data android:port=&quot;&quot;/&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></intent-filter></p><p>这里的action的值配置为；鹅Intent.ACTION_VIEW的常量值，同时data字段也配置了可以响应的协议类型等字段，假如我们设置的scheme字段是http，那么用户在打开一个http网页的时候，会提示用户选择我们的这个Activity打开。</p><p>安卓系统内部其实有很多中intent.ACTION的类型，有唤起地理位置界面的、拨号的等等。</p><h4 id="页面间传值"><a href="#页面间传值" class="headerlink" title="页面间传值"></a>页面间传值</h4><p>Intent不仅可以用来启动Activity，还可以在页面跳转同时传值</p><p>Intent提供了一系列对putExtra（）的重载，可以在调度Activity的同时把数据暂存在Intent中，到达了另外一个Activity的时候，再由目的Activity把数据从Intent中取出就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent2.putExtra(&quot;string_from_firstActivity&quot;, &quot;hello second&quot;);</span><br></pre></td></tr></table></figure></p><p>上面的这是设值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = getIntent();</span><br><span class="line">Log.v(&quot;SecondActivty&quot;,intent.getStringExtra(&quot;string_from_firstActivity&quot;));</span><br></pre></td></tr></table></figure></p><p>这是取值</p><p>这种适合用来做单向正向传值。除了这种之外还有反向传值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivityForResult(intent2,1);</span><br></pre></td></tr></table></figure></p><p>这个方法能够期望SecondActivity销毁时能够返回结果给FirstActivity。<br>然后需要在FirstActivity中覆写onActivityResult方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    switch (requestCode)&#123;</span><br><span class="line">        case 1:</span><br><span class="line">            if (resultCode==RESULT_OK)&#123;</span><br><span class="line">                Log.v(&quot;FirstActivity&quot;,data.getStringExtra(&quot;back_to_first&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>通过对Intent data调用getStringExtra方法得到返回回来的数据。、<br>requestCode是前面写的数字。用来标示从FirstACtivity跳转到的不同Activity<br>resultCode是SecondActivity返回数据时传入的参数。用来标示是否处理成功。<br>data就是携带的数据。</p><p>对于SecondActivity来说，只要设值，然后调用setResult（）就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intent.putExtra(&quot;back_to_first&quot;,&quot;hello,first&quot;);</span><br><span class="line">setResult(RESULT_OK,intent);</span><br></pre></td></tr></table></figure></p><p>除此之外，还可以直接监听到返回键的事件来处理响应的事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onBackPressed() &#123;</span><br><span class="line">Toast.makeText(SecondActivity.this,&quot;onBackPassed&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h3><h4 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h4><p>Android也是用栈的方式去管理Activity，用Task去管理，返回栈是BackStack</p><h4 id="活动的四个状态"><a href="#活动的四个状态" class="headerlink" title="活动的四个状态"></a>活动的四个状态</h4><p>每个Activity有四种状态：</p><h5 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h5><p>最栈顶的Activity就是处于运行状态的，系统最不喜欢回收这种状态的Activity</p><h5 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h5><p>因为并不是所有的Activity都是全屏状态，所以会存在一个Activity是可见的，但是上面有一个小的Activity部分遮挡，这样一来，后面的Activity既不在栈顶（非运行态），又是可见的。这种状态就是暂停状态。一般系统也是不考虑去回收这种状态的Activity，只有在内存极低的时候才有可能被系统回收。</p><h5 id="停止状态"><a href="#停止状态" class="headerlink" title="停止状态"></a>停止状态</h5><p>如果一个活动在栈中，并且完全不可见的时候，就处于停止状态，系统会保存Activity的状态和成员变量。这个时候它并不是完全可靠的，当内存不足的时候就可能被系统回收。</p><h5 id="销毁状态"><a href="#销毁状态" class="headerlink" title="销毁状态"></a>销毁状态</h5><p>如果一个Activity从返回栈中被移除掉的话，它就会成为销毁状态，系统最优先回收这种状态的Activity。</p><h4 id="活动在三种生存期的七个回调方法"><a href="#活动在三种生存期的七个回调方法" class="headerlink" title="活动在三种生存期的七个回调方法"></a>活动在三种生存期的七个回调方法</h4><h5 id="完整生存期"><a href="#完整生存期" class="headerlink" title="完整生存期"></a>完整生存期</h5><p>从onCreate（）开始到onDestory（）结束</p><h6 id="onCreate（）"><a href="#onCreate（）" class="headerlink" title="onCreate（）"></a>onCreate（）</h6><p>每个Activity中都重写这个方法，它会在每个Activity创建的时候调用，所以这个方法中应该完成一些例如加载布局文件、绑定事件等初始化操作。</p><h6 id="onDestory（）"><a href="#onDestory（）" class="headerlink" title="onDestory（）"></a>onDestory（）</h6><p>这个方法在Activity被销毁之前调用，调用完成之后Activity就进入销毁状态</p><h5 id="可见生存期"><a href="#可见生存期" class="headerlink" title="可见生存期"></a>可见生存期</h5><p>Activity从onStart（）到onStop（）之间的部分就是可见生存期。可见生存期的可见二字就意味着Activity是显示的，就算不能交互，也要算在内。<br>开发者就可以通过在onStart（）方法中加载资源，在onStop（）方法中释放资源，来保证停止状态的Activity不会占用过多的资源。</p><h6 id="onStart（）"><a href="#onStart（）" class="headerlink" title="onStart（）"></a>onStart（）</h6><p>这个方法在Activity由不可见变成可见的时候调用</p><h6 id="onStop（）"><a href="#onStop（）" class="headerlink" title="onStop（）"></a>onStop（）</h6><p>相反的，当Activity变得<strong>完全</strong>不可见的时候调用</p><h5 id="前台生存期"><a href="#前台生存期" class="headerlink" title="前台生存期"></a>前台生存期</h5><p>在onResume（）方法和onPause（）方法之间的Activity就是前台生存期。这时候Activity子那个是处于运行状态，可以与用户交互</p><h6 id="onResume（）"><a href="#onResume（）" class="headerlink" title="onResume（）"></a>onResume（）</h6><p>这个方法是Activity已经准备好和用户交互的时候调用。这个时候的Activity在栈顶并且一定是运行状态。</p><h6 id="onPause（）"><a href="#onPause（）" class="headerlink" title="onPause（）"></a>onPause（）</h6><p>这个方法是系统准备去启动某个Activity或者恢复到某个Activity的时候调用，这个方法中一般用于把一些消耗系统资源的释放掉，或者保存一些关键数据，但是这个方法里执行的不能是一些耗时操作。<br><strong>如果是一个对话框出现在某个Activity上面的时候，如果没有完全遮挡，那么会调用onPause（）而不是onStop（）</strong></p><p>除此之外，还有一个独立在这三种生存期之外的回调方法：</p><h6 id="onRestart（）"><a href="#onRestart（）" class="headerlink" title="onRestart（）"></a>onRestart（）</h6><p>这个方法是Activity在由停止状态重新变成运行状态的时候调用的。</p><p>下面附一张Activity的生命周期图（书上原图）：<br><img src="https://s1.ax1x.com/2018/06/07/CH124K.jpg" alt="Activity的生命周期"></p><p>下面做一个测试用于FirstActivity到SecondActivity然后再跳转回来的一个状态跟踪打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">06-07 14:45:16.457 16551-16551/com.example.ifan.activitytest V/life: onCreate is called</span><br><span class="line">06-07 14:45:16.736 16551-16551/com.example.ifan.activitytest V/life: onStart is called</span><br><span class="line">06-07 14:45:16.742 16551-16551/com.example.ifan.activitytest V/life: onResume is called</span><br><span class="line">06-07 14:45:29.731 16551-16551/com.example.ifan.activitytest V/life: onPause is called</span><br><span class="line">06-07 14:45:30.536 16551-16551/com.example.ifan.activitytest V/life: onStop is called</span><br><span class="line">06-07 14:46:24.588 16551-16551/com.example.ifan.activitytest V/life: onRestart is called</span><br><span class="line">06-07 14:46:24.590 16551-16551/com.example.ifan.activitytest V/life: onStart is called</span><br><span class="line">06-07 14:46:24.591 16551-16551/com.example.ifan.activitytest V/life: onResume is called</span><br><span class="line">06-07 14:46:41.625 16551-16551/com.example.ifan.activitytest V/life: onPause is called</span><br><span class="line">06-07 14:46:42.003 16551-16551/com.example.ifan.activitytest V/life: onStop is called</span><br><span class="line">06-07 14:46:42.004 16551-16551/com.example.ifan.activitytest V/life: onDestory is called</span><br></pre></td></tr></table></figure></p><p>可以看出来从FirstActivity到SecondActivity的时候，经过了onPause（）和onStop（）的方法的调用；从SecondActivity回到FirstActivity的时候，经过了onRestart（）、onStart（）和onResume（）的调用</p><p>再做一个部分遮挡的例子：SecondActivity是一个对话框式的Activity时候，从FirstActivity到SecondActivity打印出来的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">06-07 14:56:10.743 17244-17244/com.example.ifan.activitytest V/life: onCreate is called</span><br><span class="line">06-07 14:56:11.011 17244-17244/com.example.ifan.activitytest V/life: onStart is called</span><br><span class="line">06-07 14:56:11.019 17244-17244/com.example.ifan.activitytest V/life: onResume is called</span><br><span class="line">06-07 14:56:14.760 17244-17244/com.example.ifan.activitytest V/life: onPause is called</span><br><span class="line">06-07 14:56:24.734 17244-17244/com.example.ifan.activitytest V/life: onResume is called</span><br></pre></td></tr></table></figure></p><p>可以看到这种情况少了onStop（）、onRestart（）和onStart（）的调用过程。</p><p>另外还可以看到在按返回键的时候的调用过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">06-07 15:22:38.832 18596-18596/com.example.ifan.activitytest V/life: onPause is called</span><br><span class="line">06-07 15:22:39.261 18596-18596/com.example.ifan.activitytest V/life: onStop is called</span><br><span class="line">06-07 15:22:39.262 18596-18596/com.example.ifan.activitytest V/life: onDestory is called</span><br></pre></td></tr></table></figure></p><p>看到有博客说按home、返回、在后台杀进程的调用过程会有差异。<br>另外在onStop（）的覆写中如果不写对父类方法的调用会导致Activity直接被回收，下一次还需要重新create。也很好理解，因为不调用父类方法的话其实就少了状态、变量的保存过程，所以会出现这样的结果。</p><h4 id="Activity在停止状态被回收的情况"><a href="#Activity在停止状态被回收的情况" class="headerlink" title="Activity在停止状态被回收的情况"></a>Activity在停止状态被回收的情况</h4><p>Activity在活动状态是可能被回收的，也就是可能存在以下场景：<br>A跳转到B，然后A进入停止状态，但是A被销毁了，这时候从B回来就不会调用onRestart（）方法，而是调用onCreate（）方法。这时候因为A在onStop（）方法里写入的数据也随着之前停止状态的Activity被销毁了，所以这时候从B回去之后看到的A就是一个新创建的A了。<br>怎么解决呢？<br>Activity提供了一个onSaveInstanceState（）的回调方法，这个方法能够保证在Activity被Destory之前一定会被执行。所以我们可以在在这里保存A的Stop数据。</p><p>这个onSaveInstanceState（）携带一个Bundle类型的参数，Bundle提供了一系列用于保存数据的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">outState.putString(&quot;FirstActivityDataOut&quot;,&quot;help~&quot;);</span><br><span class="line">    super.onSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在onCreate（）方法中携带的Bundle类型的参数里获取这个Bundle中的数据就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(savedInstanceState.getString(&quot;FirstActivityDataOut&quot;)!=null)</span><br><span class="line">Log.v(&quot;FirstActivityDataOut&quot;,savedInstanceState.getString(&quot;FirstActivityDataOut&quot;));</span><br></pre></td></tr></table></figure></p><p>除此之外，在Intent的使用中也可以使用Bundle来传值。</p><h3 id="Activity的四种启动模式"><a href="#Activity的四种启动模式" class="headerlink" title="Activity的四种启动模式"></a>Activity的四种启动模式</h3><p>四种启动模式是在AndroidManifest.xml里面的Activity对应的标签里面指定的。</p><h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>标准模式，也就是默认模式，在一个Activity建好的初始设置就是这个，每次启动一个新的Activity的时候，它就在返回栈中入栈，处于栈顶位置。这样的话，当此Activity递归地跳转到本类的Activity，栈中也会不停地新建、入栈。</p><h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>栈顶单例，顾名思义，处于栈顶的Activity在进行上面的操作的时候，会被直接使用本activity，而不是不断新建、入栈。但是前提条件必须是：<strong> 当前的Activity必须处于栈顶。</strong></p><p><strong>一个有意思的现象是使用startActivityForResult（）去启动这个singleTop的Activity的时候，是无视它的singleTop模式的，google这样设计的原因可能是考虑到回调的内容没有接受者</strong></p><h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>上一种的singleTop是只检查栈顶，避免了单个Activity的递归启动。除此之外还可以让某个Activity在整个返回栈中成为唯一的一个Activity。<br>例如：</p><p>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;B</p><p>如果B的启动类型为singleTask，那么在从E到B的时候实际上是回到了最前面B，而且最前面的B之后的都会被从栈里弹出。</p><h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>这个是不同于上面的三种的一种特殊的启动方式——这种启动模式的Activity会启用一个另外的返回栈去管理这个活动。应用场景就是当别的程序要共享访问这个Activity，其他的三种模式就不能完成了。（每个程序都有自己的返回栈，如果访问了这个Activity，那必定是在当前的程序和别的那个程序里面都会分别加入一个新建的这个Activity，那就是不同的实例了，达不到共享的目的。）</p><p>而这个singleInstance就是解决这种情况的——<strong>它会连同Activity一块返回一个单独的返回栈，然后任何一个应用来访问这个Activity，都公用同一个返回栈。</strong><br>例如：</p><p>A -&gt; B -&gt; C</p><p>如果B的启动模式为singleInstance的话，实际的栈是这样的：<br>A — C<br>B<br>第一个栈是本程序自己的栈，因为A、C都是普通的模式，所以都默认入栈到程序自己的默认栈里了。而第二个栈就是随着B一同创建的新栈，这个栈是所有程序调用时公用的。</p><p>所以返回键连续按下之后，先是C所在的栈先出栈C，然后是A，因为是同一个栈，最后才是B，因为程序自己所在的栈已经空了，就轮到B所在的栈出栈了。</p><h3 id="一些实践"><a href="#一些实践" class="headerlink" title="一些实践"></a>一些实践</h3><p>了解了Activity的基础知识后，这里还有一些关于Activity的应用技巧。</p><h4 id="获知当前所处Activity"><a href="#获知当前所处Activity" class="headerlink" title="获知当前所处Activity"></a>获知当前所处Activity</h4><p>当拿到别人的代码时候，可能就不方便知道当前的界面是处于哪一个Activity了，一个个对应也很麻烦，所以有一个办法去获知当前所处的Activity：<br>使用间接继承的原理，新建一个中间类BaseActivity继承自AppCompatActivity，在onCreate（）的方法中扩展一个打印当前类的语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log.v(&quot;BaseActivity&quot;,getClass().getSimpleName());</span><br></pre></td></tr></table></figure></p><p>然后让所有的Activity都继承自这个BaseActivity，然后就可以显示出当前类的类名了。<br><strong>但是同时也有一个让人没有办法接受的缺点：难道我拿到别人的代码要把所有的Activity的继承类都修改一遍么？！</strong></p><h4 id="退回到任意Activity"><a href="#退回到任意Activity" class="headerlink" title="退回到任意Activity"></a>退回到任意Activity</h4><p>用一个List去手动维护一个返回栈，从而能够对这个返回栈的Activity手动操控，就可以返回到任意Activity：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static boolean backToIndexOfStack(int index)&#123;</span><br><span class="line">        if (index&gt;=activityList.size())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = activityList.size()-1;i &gt; index;i--)&#123;</span><br><span class="line">            activityList.get(i).finish();</span><br><span class="line">            activityList.remove(activityList.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>index从0开始，这里依次从栈里finsh（）掉Activity，并且从手动维护的栈中remove掉。</p><h4 id="启动Activity的最佳写法"><a href="#启动Activity的最佳写法" class="headerlink" title="启动Activity的最佳写法"></a>启动Activity的最佳写法</h4><p>在多人协作开发的时候，协定传参总是一个要考虑的点。可以在启动Activity的时候封装一个activityStart（）方法，专门用来构建Intent，这样一来参数就在这个activityStart（）方法的参数列表里体现出来了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void activityStart(Context context,String firstName,String lastName)&#123;</span><br><span class="line">       Intent intent = new Intent(context,SecondActivity.class);</span><br><span class="line">       intent.putExtra(&quot;param1&quot;,&quot;hello&quot;);</span><br><span class="line">       intent.putExtra(&quot;param2&quot;,&quot;there&quot;);</span><br><span class="line">       startActivity(intent);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h1 id="Android-UI的开发"><a href="#Android-UI的开发" class="headerlink" title="Android UI的开发"></a>Android UI的开发</h1><p>前面的一节是从探究Activity的角度去了解Activity的用法和特点。接下来就是学习如何编写UI，结合Activity去编写完整的UI已经交互逻辑。</p><h2 id="常用控件的使用"><a href="#常用控件的使用" class="headerlink" title="常用控件的使用"></a>常用控件的使用</h2><h3 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h3><p>这个控件类似于iOS里面的UILabel，用于展示文字信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:id=&quot;@+id/text_view&quot;</span><br><span class="line">    android:text=&quot;This is a TextView&quot;</span><br><span class="line">    android:gravity=&quot;center&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>android:layout_width、android:layout_height这两个属性是所有控件里面都有的，就像iOS里面的Frame一样用来设置大小，但是这个只是表示了大小并不明位置。<br>后面的值可选三种值：</p><ul><li>match_parent：表示让当前的控件和父布局的大小一样大。</li><li>fill_parent：和match_parent的意义一样，现在官方推荐使用match_parent。</li><li>wrap_content：表示让控件的大小刚好能包含控件中展示的内容，控件大小由控件内容决定。</li></ul><p>当然了，也可以手动指定固定值作为width、height的值，但是这样会导致适配出现问题。</p><p><strong>gravity</strong>：指定的是对齐方式，和iOS里TextAlignment类似。可选的有top、bottom、left、right、center。（center是默认指定”center_vertical|center_horizontal”的，表示垂直和水平方向都居中）</p><p><strong>textSize</strong>：指定文字大小。在Android里字体大小是使用sp作单位的。其实在打出24这个将要指定大小的数字的时候，自动补全了几个选项：dp、in、mm、pt、px、sp。好奇这几个有什么区别。之后我会另外开一个文去写这个的。<br><strong>textColor</strong>：#+6位16进制数表示颜色。</p><p>更多的使用细节去查文档就好。</p><h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><p>它在布局文件里的写法大同小异，它有一个textAllCaps属性，如果不设置为false的话默认为true就会把所有出现的字母都变为大写的。<br>然后就可以在Activity的类里面去获取这个控件了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">      button1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onClick(View view) &#123;</span><br><span class="line">              //点击之后的代码</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></p><p>这是一种类似闭包的方式，其实还有一种通过实现接口的方式，需要在本类的声明部分写明实现哪一个接口，然后在设置button的监听者为本类，然后覆写onClick（）方法，方法内部通过判断id来分别实现不同button的点击事件。</p><h3 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h3><p>这个控件实际上就是iOS里的TextView，支持多行输入和排版。<br>特别的属性：</p><p><strong>hint</strong>：这一个是iOS里面的TextView里面没有的类似于placeHolder的设置。</p><p><strong>maxLines</strong>：EditText如果高度不是定值，就会随着输入内容的增多而拉长。如果指定了这个属性，则EditText不会被拉长，但是内容视图的长度还是会被拉长。而且，它只是限制了EditText这个控件的最大显示行数，并没有限制内容的行数。</p><p>另外，还可以在Activity里面获取到EditText里面的文字信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EditText editText = findViewById(R.id.edit_text);</span><br><span class="line">editText.getText().toString()</span><br></pre></td></tr></table></figure></p><h3 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h3><p>这个倒是和iOS里的UIImageView差别不大,不过现在资源大多都同意放在res目录下的drawable目录下，但是这个目录没有制定具体的分辨率，所以书上的建议是新建一个drawable-xhdpi文件夹，然后把图片放进去。</p><p>对于图片的设置有两种方法，一种是直接写在布局文件里，一种是在Activity类里去修改。这两种可以同时使用。</p><p><strong>有意思的是，Android的图片文件并不能带大写字母，不然会报错说只支持小写字母、数字和下划线。</strong></p><p>同时对文件名里带“.”的文件也不能支持，会报错。</p><p><strong>另外，在一开始设置的height为wrap_content其实也没有起作用。</strong></p><h3 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h3><p>显示一个进度条（默认样式是一个不断循环转动的圈圈）。布局文件里写的是默认可见的（当然也可以手动指定为其他值），就可以在Activity里去判断它当前是否是可见的，如果是可见的，可以设为不可见。</p><p>在布局文件里设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:visibility=&quot;invisible&quot;</span><br></pre></td></tr></table></figure></p><p>在Activity里设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (findViewById(R.id.progress_bar).getVisibility() ==View.VISIBLE)&#123;</span><br><span class="line">          findViewById(R.id.progress_bar).setVisibility(View.INVISIBLE);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>对于ProgressBar来说有三种可见选项：visible、invisible、gone</p><p><strong>visible</strong>：可见的。</p><p><strong>invisible</strong>：不可见，但是还占据着原来的位置和大小，可以理解为透明状态。</p><p><strong>gone</strong>：不仅是不可见的，而且完全从屏幕上消失。</p><p>除了上面的那种圈圈的样式，还有一种样式是条状的。可以通过在布局文件里设置style为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style=&quot;?android:progressBarStyleHorizontal&quot;</span><br></pre></td></tr></table></figure></p><p>对于这种样式，可以设置一个最大值，以便在Activity中动态的改变进度条的状态。</p><p>布局文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android:max=&quot;100&quot;</span><br></pre></td></tr></table></figure></p><p>Activity：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProgressBar progressBar = findViewById(R.id.progress_bar);</span><br><span class="line">progressBar.setProgress(progressBar.getProgress()+10);</span><br></pre></td></tr></table></figure></p><h3 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h3><p>弹出一个对话框，一般用于警告用户，下方有三个按钮可以响应用户的点击事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog.Builder dialog = new AlertDialog.Builder(FirstActivity.this);</span><br><span class="line">dialog.setTitle(&quot;this will change image&quot;);</span><br><span class="line">dialog.setMessage(&quot;this is very importent&quot;);</span><br><span class="line">dialog.setCancelable(true);</span><br><span class="line"></span><br><span class="line">dialog.setNeutralButton(&quot;NeutralButton&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(DialogInterface dialogInterface, int i) &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dialog.setNegativeButton(&quot;Cancle&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(DialogInterface dialogInterface, int i) &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">@Override</span><br><span class="line">    public void onClick(DialogInterface dialogInterface, int i) &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dialog.show();</span><br></pre></td></tr></table></figure></p><p>可以在示例代码中看到，使用一般是三个步骤，先用Builder新建一个AlertDialog实例出来（指定Activity），然后设置标题、信息内容、可否在点击别的空白处取消这个AlertDialog。</p><p>然后分别设置三个按钮（从左到右依次为NeutralButton、NegativeButton、PositiveButton）的点击回调事件。</p><h3 id="ProgressDialog"><a href="#ProgressDialog" class="headerlink" title="ProgressDialog"></a>ProgressDialog</h3><p>和上面的那个AlertDialog很类似，也可选两种样式——转圈圈或者一个条状的进度条。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProgressDialog progressDialog = new ProgressDialog(FirstActivity.this);</span><br><span class="line">progressDialog.setTitle(&quot;progressDialog&quot;);</span><br><span class="line">progressDialog.setMessage(&quot;this is a progressDialog&quot;);</span><br><span class="line">progressDialog.setCancelable(true);</span><br><span class="line">progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span><br><span class="line">progressDialog.setMax(256);</span><br><span class="line">progressDialog.show();</span><br></pre></td></tr></table></figure></p><p>这种的是和前面的ProgressBar是一样的，可以设置最大的长度、动态改变进度状态。<br>默认是转圈的样式。</p><p><strong>需要注意的是，如果这个也设置为不允许失焦取消，那不知道何时会结束的progressDialog就会导致当前应用卡死，无法继续交互。如果设置为允许失焦消失，那就要处理好消失的逻辑，是否是用户选择取消当前进度？如果误操作怎么处理？如果是取消应该处理当前进度的任务？</strong></p><h2 id="四种基本布局"><a href="#四种基本布局" class="headerlink" title="四种基本布局"></a>四种基本布局</h2><p>布局是一种可用于放置很多控件的容器。布局是可以嵌套的。可以通过布局的嵌套来完成一些复杂的布局效果。这一部分将用一个新的项目去学习和练习。</p><h3 id="线性布局-LinearLayout"><a href="#线性布局-LinearLayout" class="headerlink" title="线性布局-LinearLayout"></a>线性布局-LinearLayout</h3><p>是一种非常常用的布局，这种布局会将内部包含的控件在线性方向上依次排列。<br>还记得最开始接触布局文件么？那个就是默认的线性布局（因为是根元素），有横向和竖向两种。</p><p>可以通过orientation来指定线性到底是竖向还是横向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:orientation=&quot;horizontal&quot;</span><br><span class="line">android:orientation=&quot;vertical&quot;</span><br></pre></td></tr></table></figure></p><p><strong>需要注意的是，这时候控件的size就要设置合理。比如水平线性布局的时候，控件的宽度就不能match_parent了</strong></p><p>layout的几个重要属性：</p><h4 id="layout-gravity"><a href="#layout-gravity" class="headerlink" title="layout_gravity"></a>layout_gravity</h4><p>和gravity属性有点相似，但是其实完全没有关系。</p><p><strong>gravity</strong>属性是指定某个控件内部的内容（如文字）在控件内是靠向哪一边的。</p><p><strong>gravity_layout</strong>是指定当前控件在父布局中的位置是在如何对齐的。<br>同样的，在父布局已经处于某种方式的时候要做合理的设置，例如：父布局是水平布局（horizontal），只有设置控件在竖向位置的对齐（top、center、bottom等）才会生效。</p><h4 id="layout-weight"><a href="#layout-weight" class="headerlink" title="layout_weight"></a>layout_weight</h4><p>这个属性是用比例的方式去指定控件的大小的，有一些自动布局的感觉。<br>需要区别的是控件的width属性，虽然可能长的像，但是二者是完全不同的：</p><p><strong>width</strong>：用数值或者一些定义过的常量或者宏指定宽度。</p><p><strong>weight</strong>：用比例去指定当前控件在水平方向上占用多少比例。</p><p>当weight存在的时候，width是不生效的，也就是随便写多少都没用，但是比较规范的写法是写为0dp。（dp是Android里用于指定控件大小、间距的单位）</p><p>然后weight里写的是比例，如果控件1里面写的是1，另一个控件里写的2，那么就表示两个控件的宽度比例是1:2。</p><p>有的控件里没有写weight，只写了width为wrap，这时候就还是保证控件的宽度刚够包含控件自己的内容。</p><p>如果控件1写了weight的值为1，控件2没有写weight但是写了width为wrap，那就是控件1尽量宽，然后控件2的宽度刚够包含自己的内容。</p><h3 id="相对布局：RelativeLayout"><a href="#相对布局：RelativeLayout" class="headerlink" title="相对布局：RelativeLayout"></a>相对布局：RelativeLayout</h3><p>这种布局也是非常常用的布局，这种布局更随意一些，它可以用相对定位的方式让控件出现在布局的任意位置。</p><p>正因如此，相对布局的属性就多了一些，但是好在都是有规律的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">       android:text=&quot;hello3&quot;</span><br><span class="line">       android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">       android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">       android:layout_alignParentEnd=&quot;true&quot;</span><br><span class="line">       android:layout_alignParentTop=&quot;true&quot;</span><br><span class="line">       /&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到，里面的位置相关的代码里面有Parent字段，也就是说，这些控件是相对于父布局来定位的。当然了也可以不依据父布局进行定位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">       android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">       android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">       android:layout_above=&quot;@+id/text_view&quot;</span><br><span class="line">       android:layout_toLeftOf=&quot;@+id/text_view&quot;</span><br><span class="line">       android:text=&quot;hello1&quot;</span><br><span class="line">       /&gt;</span><br></pre></td></tr></table></figure></p><p>可以通过id去选定相对的参考控件，去选择相对位置。<br><strong>但是只能去参考前面出现过的控件，不然就找不到id了。</strong></p><p>另外还有layout_alignLeft表示和目标控件左对齐，其他的其他方向都是一样的。</p><h3 id="帧布局-FrameLayout"><a href="#帧布局-FrameLayout" class="headerlink" title="帧布局 FrameLayout"></a>帧布局 FrameLayout</h3><p>这种布局非常简单，相比前面的两种来说，使用场景也较少。</p><p>这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角。多个控件按照默认方式放置会重叠在一起。</p><p>当然，也可以用layout_gravity属性去指定控件的对齐方式，但是比起前面的几种来说还是太简单了，导致实际的应用场景也不是那么多。</p><h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><p>安卓引用了一种全新的布局方式来解决线性布局不够强大的比例式布局的缺点，这种布局中，可以不再用wrap_content、match_parent等方式去指定控件的大小，而是直接指定控件在布局中所占的百分比，这样就可以轻松实现任意比例分割布局了。</p><p>百分比布局对FrameLayout和RelativeLayout进行了功能扩展，提供了PercentFrameLayout和PercentRelativeLayout的全新布局。</p><p>为了让这种布局方式能够兼容就的安卓版本上使用，这种布局定义在support库中，只需要在项目的build.gradle中添加百分比布局的依赖保证兼容性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.percent.PercentFrameLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/text_view&quot;</span><br><span class="line">        android:layout_gravity=&quot;start&quot;</span><br><span class="line">        app:layout_widthPercent=&quot;50%&quot;</span><br><span class="line">        app:layout_heightPercent=&quot;50%&quot;</span><br><span class="line">        android:text=&quot;hello~&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&lt;/android.support.percent.PercentFrameLayout&gt;</span><br></pre></td></tr></table></figure></p><p>这里的app并没有补全，想来应该是因为这个并不在内置在系统的SDK中的，所以没有自动补全。</p><p><strong>这种布局有一个大坑：写50%的时候总是先写50再写%，写这里的时候我写了50然后手抖后面多跟了个0，成了500，然后就直接卡死，告诉我Out of Memory。其实也很好解释，因为AndroidStudio是可以自动预览布局的，所以这里还来不及修改的时候，已经自动按照500去算百分比了，1是100%，那么500就是50000%，所以就内存不够了。</strong></p><p>对于另一种PercentRelativeLayout，它继承了RelativeLayout的所有属性并且加入了app:layout_widthPercent和app:layout_heightPercent来指定控件的宽高。</p><h3 id="约束布局——ConstraintLayout"><a href="#约束布局——ConstraintLayout" class="headerlink" title="约束布局——ConstraintLayout"></a>约束布局——ConstraintLayout</h3><p>因为书上的几种布局方式比较老，其实在现在的AndroidStudio里面新建一个project的时候，已经默认设置为这种约束布局了，所以换句话说，这个应该重点学习，它被默认支持一定是有它的优点的。</p><p>之前一直是用代码去编写布局，是因为前面的几种布局对于用代码的表达更好一些。但是归根结底来说，布局这种的用可视化去编辑是最直观最合适的，所以这个就是为了解决这种问题的一种新的布局方式。（这个书的作者也说了，当时在写书的时候这个布局方式刚出来，就没有加入到书里。）</p><p>这种布局方式是使用控件的相对位置去布局的，有点类似相对布局，但是比相对布局还要强大。</p><p>这种布局同时还解决了传统的几种布局的嵌套问题。传统布局要实现复杂的布局往往需要多重嵌套，但是多重嵌套会降低性能，所以这种布局应对复杂布局的时候可能会更好。</p><p>这种布局暂时看到的教程都说适合用Design界面去拖拽完成布局操作，所以这里就先不写了。</p><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><p>和iOS一样，Android里的控件也都是直接或者间接的继承自View，所有的布局都是直接或间接继承自ViewGroup。View是Android里的最基本的UI组件。ViewGroup是一种特殊的View，可以包含很多子View和ViewGroup，是用于防止控件和布局的容器。</p><p>需要接触几个前面没有接触到的属性：</p><p><strong>background</strong>：为布局或者控件指定一个背景，可以使颜色或者图片。</p><p><strong>margin</strong>：指定控件在四个方向的偏移量，也可以用margin_left等指定单一某个方向上的偏移量。</p><p>先写好某一个自定义布局，然后在另一个布局里面引用这个布局就可以了。</p><p>title.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity=&quot;center&quot;</span><br><span class="line">        android:layout_margin=&quot;5dp&quot;</span><br><span class="line">        android:text=&quot;Back&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;0dp&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity=&quot;center&quot;</span><br><span class="line">        android:layout_weight=&quot;1&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:text=&quot;title&quot;</span><br><span class="line">        android:textSize=&quot;24sp&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity=&quot;center&quot;</span><br><span class="line">        android:layout_margin=&quot;5dp&quot;</span><br><span class="line">        android:text=&quot;edit&quot;</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>activity_miain.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include layout=&quot;@layout/title&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>这个的实现效果就是自定义了个ActionBar并且加载到主布局中。</p><h2 id="最常用、最难用的控件——ListView"><a href="#最常用、最难用的控件——ListView" class="headerlink" title="最常用、最难用的控件——ListView"></a>最常用、最难用的控件——ListView</h2><p>这里的ListView就类似于iOS里面的UITableView，重要性不用多说。</p><p>先从最简单的用法开始：</p><h3 id="ListView的简单用法"><a href="#ListView的简单用法" class="headerlink" title="ListView的简单用法"></a>ListView的简单用法</h3><p>先在布局里面写一个ListView进去，这里先写好大小和id就可以。</p><p>然后在Activity里面写一个和这个listView相关的实例，把它的适配器指定为某个适配器的实例就好了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListView listView = findViewById(R.id.list_view);</span><br><span class="line">ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(</span><br><span class="line">MainActivity.this,</span><br><span class="line">    android.R.layout.simple_list_item_1,</span><br><span class="line">    data</span><br><span class="line">    );</span><br><span class="line">listView.setAdapter(adapter);</span><br></pre></td></tr></table></figure></p><p>这个适配器只是众多适配器中的一种，这个据说是最好用的，可以通过泛型来指定钥匙胚的数据类型，然后在构造函数里传参进去。</p><p>ArrayAdapter有很多重载，这里是因为用到的数据都是String类型，所以这里写 了String。然后依次传入当前的上下文、listView的id，以及具体的数据数组。</p><p>这里的android.R.layout.simple_list_item_1相当于是iOS里面UITableView的style，可以有很多种style，根据具体的使用场景自行切换。</p><h3 id="自定义ListView的界面"><a href="#自定义ListView的界面" class="headerlink" title="自定义ListView的界面"></a>自定义ListView的界面</h3><p>自定义的过程和iOS的自定义cell的基本上相似，都是新建一个布局，然后让ListView去加载这个布局作为item，然后把构造好的数据展示到界面上就好了。</p><ul><li>先新建一个布局：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/fruit_image&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:background=&quot;@drawable/ic_launcher_background&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/fruit_textview&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity=&quot;center_vertical&quot;</span><br><span class="line">        android:layout_margin=&quot;10dp&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></li></ul><p>这个就是cell（也就是item）的展示布局。</p><ul><li>新建一个容器类<br>这个容器类就是作为ListView的适配器类型：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Fruit &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int imageId;</span><br><span class="line"></span><br><span class="line">    public Fruit(String name,int imageId)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.imageId = imageId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getImageId() &#123;</span><br><span class="line">        return imageId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这个部分就相当于model类的部分，用来存储ListView将来要展示的数据。</p><ul><li>新建一个适配器类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123;</span><br><span class="line">    private int resourceId;</span><br><span class="line">    public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt;object)&#123;</span><br><span class="line">        super(context,textViewResourceId,object);</span><br><span class="line">        resourceId = textViewResourceId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123;</span><br><span class="line">        Fruit fruit = getItem(position);</span><br><span class="line">        View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);</span><br><span class="line">        ImageView fruitImage = (ImageView)view.findViewById(R.id.fruit_image);</span><br><span class="line">        TextView fruitName=(TextView)view.findViewById(R.id.fruit_textview);</span><br><span class="line">        fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">        fruitName.setText(fruit.getName());</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可以看到这个适配器类是继承自ArrayAdapter的，声明了一个私有属性resourceId，然后在这个类的构造函数里传入三个参数：上下文、textViewResourceId、和一个model类的List对象。调用父类的方法，对私有属性赋值。</p><p>然后需要重写一个父类的方法getView（），这个方法就相当于iOS里面的cellForRowAtIndex，在每次item要出现在屏幕上的时候就会调用。</p><p>这个getView传入了三个参数：position相当于是index，因为前面在构造函数里面已经设置过了List对象，所以这个方法是把数组中当前要处理的cell的对应元素取出来。</p><p>然后要新建一个View对象，这个view是：先获取到Activity的布局渲染器，然后对这个布局渲染器LayoutInflater调用inflate方法。inflate方法需要传三个参数：resourceId（具体的item的那个布局的xml文件）、parent（父布局，和缓存有关）、false（表示这个resourceId所引用的布局是不带父布局的，因为如果带了父布局，就不能添加到目标要添加的父布局了）。</p><p>然后从这个view中通过findViewById的方法去找到具体的控件，接着分别从对应顺序的model的元素（第一行的getItem方法已经取出来了的那个）里面取出需要显示在item上面的值，赋值给对应的控件，然后返回这个view作为ListView的item。</p><ul><li>在Activity中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;Fruit&gt; fruits = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    ListView listView = findViewById(R.id.list_view);</span><br><span class="line"></span><br><span class="line">    initFruit();</span><br><span class="line">    FruitAdapter adapter = new FruitAdapter(MainActivity.this,R.layout.fruit_item,fruits);</span><br><span class="line"></span><br><span class="line">    listView.setAdapter(adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void initFruit()&#123;</span><br><span class="line">for (int i =0;i&lt;100;i++)&#123;</span><br><span class="line">    Fruit fruit = new Fruit(&quot;apple&quot;+i,R.drawable.ic_launcher_background);</span><br><span class="line">        fruits.add(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的其实都是准备的工作，要生效还是在Activity里面建立数据数组，然后对数据数组进行初始化，然后新建一个自定义的适配器，最后把listview的适配器设置为刚才建立好的自定义适配器实例。</p><p>要实现更复杂的item，只要修改model和item的布局文件就可以了。</p><h3 id="提升ListView的效率"><a href="#提升ListView的效率" class="headerlink" title="提升ListView的效率"></a>提升ListView的效率</h3><p>ListView之所以难用就是因为它的使用初看比较简单，但是实际上有很多可以优化的点，比如提升效率。</p><p>前面写的代码的运行效率就很低，因为在适配器的代码中，每次item出现的时候，都会调用的getView方法中都会加载一遍布局。当ListView快速滑动的时候，就会带来不小的负担。</p><p>其实前面没有注意到的是，getView还有一个参数：convertView。</p><p>这个参数是将之前加载好的布局缓存起来，以便之后再次使用。</p><p>所以其实可以这样用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">View view;</span><br><span class="line">if (convertView == null)</span><br><span class="line">LayoutInflater.from(getContext()).inflate(resourceId,parent,false);</span><br><span class="line">else</span><br><span class="line">    view = convertView;</span><br></pre></td></tr></table></figure></p><p>这样一来，就不会每次都不分青红皂白地去加载布局了，而是先判断缓存的布局是不是为空，如果为空，再去加载布局，如果不为空，就直接变动要显示的数据就好了。</p><p><strong>纵使这样，代码的性能还能继续优化：</strong><br>虽然已经可以不用重复地去加载布局了，但是对于getView方法，还是需要每次从view里面通过findViewById去找到具体的控件。所以这里就可通过新建一个ViewHolder类去缓存每个控件了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">@Override</span><br><span class="line">public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123;</span><br><span class="line">Fruit fruit = getItem(position);</span><br><span class="line"></span><br><span class="line">    ViewHolder viewHolder;</span><br><span class="line">    View view;</span><br><span class="line">    if (convertView == null)&#123;</span><br><span class="line">    view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);</span><br><span class="line">    viewHolder = new ViewHolder();</span><br><span class="line">        viewHolder.fruitImage = (ImageView)view.findViewById(R.id.fruit_image);</span><br><span class="line">        viewHolder.fruitName = (TextView)view.findViewById(R.id.fruit_textview);</span><br><span class="line">        view.setTag(viewHolder);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">    view = convertView;</span><br><span class="line">        viewHolder = (ViewHolder)view.getTag();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert fruit != null;</span><br><span class="line">    viewHolder.fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">    viewHolder.fruitName.setText(fruit.getName());</span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ViewHolder&#123;</span><br><span class="line">ImageView fruitImage;</span><br><span class="line">    TextView fruitName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这里的ViewHolder类也很简单，和Fruit类一一对应，只不过Fruit里面是数据，这个里面是需要改变数据的item的控件。</p><p>在原来优化的基础上，对于新加载布局的情况：把从view里面寻找对应的控件，然后存到viewHolder里面，最后把viewHolder实例设置为view的tag；</p><p>对于不用重新加载布局的view：直接通过getTag方法获取viewHolder，然后取出viewHolder里面的控件进行操作。</p><h3 id="ListView的点击事件"><a href="#ListView的点击事件" class="headerlink" title="ListView的点击事件"></a>ListView的点击事件</h3><p>也很好理解，就和iOS里面的cell监听方法一样的。</p><p>对于Android的ListView，就是实现ListView的setOnItemClickListener方法参数中的闭包。</p><p>前面的优化都是在自定义适配器里写的，这里就要回到Activity里面了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;</span><br><span class="line">@Override</span><br><span class="line">    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;</span><br><span class="line">    Fruit fruit = fruits.get(position);</span><br><span class="line">        Toast.makeText(MainActivity.this,&quot;this is &quot;+fruit.getName(),Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个方法是在参数中传入了一个闭包，覆写了onItemClick的方法，传入了三个参数：一个适配器类型的变量、一个当前的item的view，一个当前的index，一个id。</p><p>然后如果要让点击之后发生点什么，就在这个onItemClick方法里写就好。</p><h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><p>终于过了那个ListView大户，然后又来了一个传说中更强大的控件——RecycleView。</p><p>ListView其实有着很多不够强大的地方——一是需要用一些技巧去优化它的性能，二是它只能实现竖向的滚动，不能实现横向的滑动。</p><p>所以，Android就提供了一个更强大的控件，这个可以看做一个增强版的ListView，可以轻松实现ListView的效果，还优化了ListView里面的各种不足之处。目前就连Android官方都更加推荐RecycleView。</p><h3 id="RecyclerView的简单用法"><a href="#RecyclerView的简单用法" class="headerlink" title="RecyclerView的简单用法"></a>RecyclerView的简单用法</h3><p>因为这个也是官方SDK里没有默认提供的控件，所以需要在app/build.gradle里面写明依赖库。</p><p>然后就是在布局文件里面写这个控件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.RecyclerView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:id=&quot;@+id/recyclerview&quot;&gt;</span><br><span class="line">    &lt;/android.support.v7.widget.RecyclerView&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>也是很简单的写法。</p><p>因为想要用这个RecylerView实现ListView，所以依然需要一个适配器类。然后之前的item和model类是通用的，直接拿过来用就好。</p><p>新建一个FruitAdapter类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123;</span><br><span class="line">    private List&lt;Fruit&gt; mFruitList;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123;</span><br><span class="line">        View view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.item_layout,viewGroup,false);</span><br><span class="line">        ViewHolder holder = new ViewHolder(view);</span><br><span class="line">        return holder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onBindViewHolder(@NonNull ViewHolder viewHolder, int i) &#123;</span><br><span class="line">        Fruit fruit = mFruitList.get(i);</span><br><span class="line">        viewHolder.fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">        viewHolder.fruitName.setText(fruit.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getItemCount() &#123;</span><br><span class="line">        return mFruitList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public FruitAdapter(List&lt;Fruit&gt; fruitList)&#123;</span><br><span class="line">        mFruitList = fruitList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class ViewHolder extends RecyclerView.ViewHolder&#123;</span><br><span class="line">        ImageView fruitImage;</span><br><span class="line">        TextView fruitName;</span><br><span class="line"></span><br><span class="line">        public ViewHolder(View view)&#123;</span><br><span class="line">            super(view);</span><br><span class="line">            fruitImage = (ImageView)view.findViewById(R.id.fruit_image);</span><br><span class="line">            fruitName = (TextView)view.findViewById(R.id.fruit_textview);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码虽然比较长，但是其实理解起来不难：</p><ul><li><p>首先是这个适配器类本身是继承自RecyclerView.Adapter</p></li><li><p>这个适配器的实例拥有一个List的实例变量，由构造函数传入参数来确定。</p></li><li><p>这个适配的内部还有一个内部类ViewHolder，ViewHolder继承自RecyclerView.ViewHolder，它的作用和前面的ListView的ViewHolder的作用类似，也是为了提高性能的复用机制。</p></li><li><p>适配器的类需要重写三个方法：</p></li></ul><p>1.onCreateViewHolder（），是用来创建ViewHolder的实例。</p><p>2.onBindViewHolder（），用于将RecyclerView子项进行赋值，每个item出现在屏幕上的时候就会执行这个方法，相当于CellForRowAtIndex的iOS代理方法。 </p><p>3.getItemCount（）相当于iOS里面的numberOfRow，返回行数。</p><ul><li>然后在Activity 中写一个线性布局的管理器，用于将item线性排列，这样就能实现listView 的样式。</li></ul><p>细心的我还发现，在ListView中，可如果可滑动超过了屏幕范围，就会有一个滑动条指示当前的位置，如果是RecyclerView实现的ListView，就没有这个滑动条了。</p><h3 id="RecyclerView实现横向滚动和瀑布流"><a href="#RecyclerView实现横向滚动和瀑布流" class="headerlink" title="RecyclerView实现横向滚动和瀑布流"></a>RecyclerView实现横向滚动和瀑布流</h3><h4 id="横向滚动的实现"><a href="#横向滚动的实现" class="headerlink" title="横向滚动的实现"></a>横向滚动的实现</h4><p>前面实现了类似ListView的纵向滚动，这次来在前面的基础上实现横向滚动。</p><p>由于数据内容并没有改变，所以这个UI的变化只需要更改布局相关的代码就可以实现了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:orientation=&quot;vertical&quot;</span><br></pre></td></tr></table></figure></p><p>首先是在item的布局中，把每个item的布局改为合适的排列方式。（可选，这个看情况，并不影响功能的实现）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);</span><br></pre></td></tr></table></figure><p>然后就是在Activity的onCreate（）里让这个布局管理器的布局方式写为水平线性布局。<br>再次运行，就已经看到现在是水平滚动的RecyclerView了。</p><p>由此可见，RecyclerView的布局方式是由Activity自身去管理的，可以自由配置LayoutManager的属性。</p><p>除了上面用到的线性布局之外，RecyclerView还提供了GridLayoutManager（网格布局）、StaggeredGridLayoutManager（瀑布流布局）。</p><h4 id="瀑布流的实现"><a href="#瀑布流的实现" class="headerlink" title="瀑布流的实现"></a>瀑布流的实现</h4><p>这一次就用StaggeredGridLayoutManager去实现瀑布流的布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL);</span><br></pre></td></tr></table></figure></p><p>要改动的其实就只有布局管理器一处，前面说过，数据不变的时候就是布局与布局管理器的改动了。</p><p>这个StaggeredGridLayoutManager的构造方法里传入的两个参数分别表示：列数、布局的方向。</p><h3 id="RecyclerView的点击事件"><a href="#RecyclerView的点击事件" class="headerlink" title="RecyclerView的点击事件"></a>RecyclerView的点击事件</h3><p>这个RecyclerView的点击事件并没有提供具体的监听方法。所有的点击操作需要用户为每个item手动注册点击事件。</p><p>看似RecyclerView不及ListView设计的好，但是实际上RecyclerView有自己的考虑：如果用户点击到的是item里面的某一个说具体的子控件呢？虽然ListView也还是有办法可以处理，但是就不是那么的人性化了。</p><p>主要就是在adapter类里面进行设置：</p><ul><li>在ViewHolder里面添加View，用来响应item的项点击事件（如果需要的话）。</li><li>在onCreateViewHolder（）方法里面在每次创建ViewHolder（也就是每次新建item的时候），对item中的控件注册点击监听器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123;</span><br><span class="line">       View view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.item_layout,viewGroup,false);</span><br><span class="line"></span><br><span class="line">       final ViewHolder holder = new ViewHolder(view);</span><br><span class="line">       holder.fruitImage.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View view) &#123;</span><br><span class="line">               int position = holder.getAdapterPosition();</span><br><span class="line">               Fruit fruit = mFruitList.get(position);</span><br><span class="line">               Toast.makeText(view.getContext(),&quot;clicked __ &quot;+fruit.getName(),Toast.LENGTH_SHORT).show();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       return holder;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样就实现了具体的控件的点击事件的监听。前面对于item的view的点击注册会在没有注册过的控件的点击事件进行捕获并响应。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本的UI控件就到此为止了，安卓和iOS的设计还是有很多的相似之处，就是细节和思路的不同之处还需要多加练习以便熟练掌握，难点主要集中在ListView和RecyclerView上面，这个ListView其实比iOS的UITableView的功能差了很多，而RecyclerView和UIScrollView有一些相似，只不过iOS中的UITableView是继承自UISCrollView，但是安卓中的ListView并不是继承自RecyclerView的，后者反而是非标准的支持库的内容。</p><h1 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h1><h2 id="碎片是什么"><a href="#碎片是什么" class="headerlink" title="碎片是什么"></a>碎片是什么</h2><p>经常能见到平板上对于手机的UI的不合理拉伸效果，这个碎片可以用来重新设计HD版本的APP，可以充分利用平板的大屏幕空间。</p><p>碎片（Fragment）是一种可以嵌入到活动中的UI片段。它和活动很像，都能包含布局，也都有自己的生命周期。可以在一个活动中引入多个碎片，然后在碎片里实现不同的布局和业务逻辑。</p><h2 id="碎片的简单使用"><a href="#碎片的简单使用" class="headerlink" title="碎片的简单使用"></a>碎片的简单使用</h2><ul><li>新建fragment的布局文集散，和别的布局没有什么不同。</li><li>然后就是新建一个继承自Fragment的java类，这个就类似于activity的控制器。这里需要注意可作为父类的Fragment有两个，一个是系统内置的android.app.Fragment，一个是support-v4库中的Fragment类。这里用后者的原因是前者会导致4.2版本之前的系统无法支持这个控件而程序崩溃。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class LeftFragment extends Fragment &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.left_fragment,container, false);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>类似菜单和alert的方式，都是用一个铺开器去加载布局然后展开。</p><ul><li>在根Activity的布局文件里写对前面的fragment的布局文件的引用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;fragment</span><br><span class="line">    android:id = &quot;@+id/left_fragment&quot;</span><br><span class="line">    android:name=&quot;com.example.ifan.fragmenttest.LeftFragment&quot;</span><br><span class="line">    android:layout_width=&quot;0dp&quot;</span><br><span class="line">    android:layout_weight=&quot;1&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">&lt;/fragment&gt;</span><br></pre></td></tr></table></figure></li></ul><p>可以看到这个比一般的控件多了一个name的字段声明，这个是因为需要指定当前需要引用哪一个布局文件，也是布局文件内嵌使用的必要操作。（包名也要写全。）</p><h2 id="动态添加碎片"><a href="#动态添加碎片" class="headerlink" title="动态添加碎片"></a>动态添加碎片</h2><h3 id="动态添加碎片的五个步骤"><a href="#动态添加碎片的五个步骤" class="headerlink" title="动态添加碎片的五个步骤"></a>动态添加碎片的五个步骤</h3><p>动态添加碎片分为五个步骤：</p><ul><li>先创建待添加的fragment实例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity=&quot;center_horizontal&quot;</span><br><span class="line">        android:textSize=&quot;20sp&quot;</span><br><span class="line">        android:text=&quot;this is another right fragment&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>上面是新建的一个布局，然后新建一个继承自Fragment的java类加载这个布局作为这个新的Fragment类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AnotherRightFragment extends Fragment &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.another_right_fragment,container,false);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>获取FragmentManager。在Activity里面可以直接调用方法去获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void replaceFragment(Fragment fragment)&#123;</span><br><span class="line">    FragmentManager fragmentManager = getSupportFragmentManager();</span><br><span class="line">    FragmentTransaction transaction = fragmentManager.beginTransaction();</span><br><span class="line">    transaction.replace(R.id.right_layout,fragment);</span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启一个事务（transaction）。对FragmentManager的实例调用beginTransaction的方法。</p></li><li>向容器内添加或者替换碎片，一般用的是replace（）方法，传入容器的id和待添加的Fragment实例。<br><strong>需要注意的是</strong>：在activity的布局文件中，其实还做了一个操作是把上一个例子的另一个Fragment的布局控件改为了一个layout，这个layout控件就相当于一个容器，用来容纳新加入或者替换的Fragment。</li><li>提交这个事务（transaction），对transaction调用commit（）方法。</li></ul><h3 id="让Fragment参与到返回栈中"><a href="#让Fragment参与到返回栈中" class="headerlink" title="让Fragment参与到返回栈中"></a>让Fragment参与到返回栈中</h3><p>前面的Activity有一个返回栈，在点击back的按钮的时候就会弹出栈顶，Fragment默认是不参与到返回栈的。</p><p>如果想让Fragment也参与到返回栈的操作逻辑里的，对FragmentTransaction调用addToBackStack（）方法就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.addToBackStack(null);</span><br></pre></td></tr></table></figure></p><p>如果每一次Fragment出现的时候都添加到返回栈的话，就是类似于activity的standard模式，会一直加到栈里。</p><h3 id="Fragment和Activity之间的通信"><a href="#Fragment和Activity之间的通信" class="headerlink" title="Fragment和Activity之间的通信"></a>Fragment和Activity之间的通信</h3><p>FragmentManager提供了类似于findViewById（）的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RightFragment rightFragment = (RightFragment)getSupportFragmentManager().findFragmentById(R.id.right_layout);</span><br></pre></td></tr></table></figure></p><p>然后这个Fragment的实例就可以调用这个Fragment里的方法了。</p><p>反之：也可以在Fragment里面获取Activity的实例，来执行Activity的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivity mainActivity = (MainActivity)getActivity();</span><br></pre></td></tr></table></figure></p><p>再者，还可以不同的Fragment之间通信，可以先获取到Activity的实例，再通过Activity去获取Activity相关联的Fragment。</p><h2 id="碎片的生命周期"><a href="#碎片的生命周期" class="headerlink" title="碎片的生命周期"></a>碎片的生命周期</h2><p>碎片和活动很类似，所以这个生命周期也是很相似的，有一些细节不太相同：</p><h3 id="四个状态"><a href="#四个状态" class="headerlink" title="四个状态"></a>四个状态</h3><h4 id="运行状态-1"><a href="#运行状态-1" class="headerlink" title="运行状态"></a>运行状态</h4><p>碎片可见、并且相关的活动正处于运行态</p><h4 id="暂停状态-1"><a href="#暂停状态-1" class="headerlink" title="暂停状态"></a>暂停状态</h4><p>活动进入暂停的状态的时候，碎片也会进入暂停状态。</p><h4 id="停止状态-1"><a href="#停止状态-1" class="headerlink" title="停止状态"></a>停止状态</h4><p>活动进入停止状态的时候、或者调用FragmentTransaction的remove（）或者replace（）方法的时候，碎片会被从活动中移除掉。</p><p>但是如果碎片是通过addToBackStack（）方法加到返回栈中的，那碎片也会进入停止状态。这时碎片是完全不可见的。</p><h4 id="销毁状态-1"><a href="#销毁状态-1" class="headerlink" title="销毁状态"></a>销毁状态</h4><p>碎片是依附着活动存在的，当活动被销毁的时候，相关联的碎片就会进入到销毁状态。</p><p>或者在没有addToBackStack的情况下直接调用FragmentTransaction的remove（）、replace（）方法移除掉碎片，都会导致碎片进入销毁状态。</p><h3 id="五个回调方法"><a href="#五个回调方法" class="headerlink" title="五个回调方法"></a>五个回调方法</h3><h4 id="onAttach（）"><a href="#onAttach（）" class="headerlink" title="onAttach（）"></a>onAttach（）</h4><p>这个方法时为了让碎片和活动建立关联的。会在Activity的onCreate（）方法之前调用。</p><h4 id="onCreateView（）"><a href="#onCreateView（）" class="headerlink" title="onCreateView（）"></a>onCreateView（）</h4><p>为碎片加载布局文件的时候调用的。在Activity的onCreate（）方法之后调用。</p><h4 id="onActivityCreated（）"><a href="#onActivityCreated（）" class="headerlink" title="onActivityCreated（）"></a>onActivityCreated（）</h4><p>确保碎片依存的Activity一定已经创建完毕之后调用的。判断Activity是否已经成功创建。</p><h4 id="onDestroyView（）"><a href="#onDestroyView（）" class="headerlink" title="onDestroyView（）"></a>onDestroyView（）</h4><p>当碎片依存的视图被进入停止状态之后调用，在onStop（）之后调用。</p><p>如果是从返回栈中回到上一个碎片，下一个要出现的碎片进入onCreateView（）的回调</p><h4 id="onDetach（）"><a href="#onDetach（）" class="headerlink" title="onDetach（）"></a>onDetach（）</h4><p>当碎片和Activity接触关联的时候调用，这时候的Activity进入销毁状态。在Activity的onDestroy（）方法之后调用。在onDetach（）方法之后，碎片就被销毁了</p><h2 id="一些使用技巧"><a href="#一些使用技巧" class="headerlink" title="一些使用技巧"></a>一些使用技巧</h2><h3 id="使用限定符"><a href="#使用限定符" class="headerlink" title="使用限定符"></a>使用限定符</h3><p>在运行时判断程序是使用双页模式还是单页。</p><p>限定符是在res的资源文件里不同的标识文件夹下写不同的布局文件、资源文件。然后app会根据不同的设备自动加载不同的布局和资源。</p><p>限定符一般分为三类：</p><h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><p>从小到大依次为：small、normal、large、xlarge</p><h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h4><ul><li>120dpi以下： ldpi</li><li>120dpi~160dpi：mdpi</li><li>160dpi~240dpi：hdpi</li><li>240dpi~320dpi：xhdpi</li><li>320dpi~480dpi：xxhdpi</li></ul><h4 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h4><ul><li>land：横屏</li><li>port：竖屏</li></ul><h3 id="使用最小宽度限定符"><a href="#使用最小宽度限定符" class="headerlink" title="使用最小宽度限定符"></a>使用最小宽度限定符</h3><p>前面提到了限定符的概念，但是比如large缺少一些具体的信息，到底多大屏幕的设备会被认定为large呢？这就需要更灵活的限定了。<br>使用最小宽度限定符就是指定一个最小的宽度值（以dp为单位），然后比这个最小宽度小的就会加载一种布局，大于这个值的就会加载另外一种布局。</p><p>具体的做法是在res文件夹下新建一个layout-sw600dp的文件夹，然后在该文件夹下写一套布局文件，这样这个文件夹中的600就是一个最小宽度的限定，大于600dp宽度的设备会自动加载这个文件夹中的布局，如果没有大于600，就会加载原来的layout文件夹中的布局文件。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> 客户端 </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 0基础 </tag>
            
            <tag> 客户端 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>Leo Chang</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/warmso"><strong>github</strong></a>  |  <a href="https://www.jianshu.com/u/14dd3b028ffe" target="_blank" rel="noopener"><strong>简书</strong></a>  |  <a href="https://weibo.com/u/2616412782" target="_blank" rel="noopener"><strong>微博</strong></a></p><p>水平不高 能力有限 荒废几年 即将毕业</p><p>仔细想想好像也没有什么了不起的兴趣</p><p>不爱格子衫，也还没秃顶</p><p>玩一丢丢乐器，很菜，自娱自乐而已</p><p>读过一点书，后来却总是静不下心来</p><p>喜欢过MMORPG类的游戏，终于还是玩不动了</p><p>不怎么立flag</p><p>喜欢尝试各种各样的折腾，折腾许久也好像除了踩坑经验略丰富以外，也没有什么成果</p><p>坚定的悲观主义者</p><p>坚持了好多年写日记的习惯最后也还是丢下了</p><p>既然作为平凡大众中的又一个，也就这样咯</p><p>。</p>]]></content>
    </entry>
    
  
</search>
